/*! ActiveText ePub Renderer version 0.0.0 */
/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 0.6.11
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */
/*jslint browser:true, node:true*/
/*global define, Event, Node*/
/**
 * Instantiate fast-clicking listeners on the specificed layer.
 *
 * @constructor
 * @param {Element} layer The layer to listen on
 */
function FastClick(layer) {
    "use strict";
    var oldOnClick, self = this;
    if (/**
	 * Whether a click is currently being tracked.
	 *
	 * @type boolean
	 */
    this.trackingClick = !1, /**
	 * Timestamp for when when click tracking started.
	 *
	 * @type number
	 */
    this.trackingClickStart = 0, /**
	 * The element being tracked for a click.
	 *
	 * @type EventTarget
	 */
    this.targetElement = null, /**
	 * X-coordinate of touch start event.
	 *
	 * @type number
	 */
    this.touchStartX = 0, /**
	 * Y-coordinate of touch start event.
	 *
	 * @type number
	 */
    this.touchStartY = 0, /**
	 * ID of the last touch, retrieved from Touch.identifier.
	 *
	 * @type number
	 */
    this.lastTouchIdentifier = 0, /**
	 * Touchmove boundary, beyond which a click will be cancelled.
	 *
	 * @type number
	 */
    this.touchBoundary = 10, /**
	 * The FastClick layer.
	 *
	 * @type Element
	 */
    this.layer = layer, !layer || !layer.nodeType) throw new TypeError("Layer must be a document node");
    /** @type function() */
    this.onClick = function() {
        return FastClick.prototype.onClick.apply(self, arguments);
    }, /** @type function() */
    this.onMouse = function() {
        return FastClick.prototype.onMouse.apply(self, arguments);
    }, /** @type function() */
    this.onTouchStart = function() {
        return FastClick.prototype.onTouchStart.apply(self, arguments);
    }, /** @type function() */
    this.onTouchMove = function() {
        return FastClick.prototype.onTouchMove.apply(self, arguments);
    }, /** @type function() */
    this.onTouchEnd = function() {
        return FastClick.prototype.onTouchEnd.apply(self, arguments);
    }, /** @type function() */
    this.onTouchCancel = function() {
        return FastClick.prototype.onTouchCancel.apply(self, arguments);
    }, FastClick.notNeeded(layer) || (// Set up event handlers as required
    this.deviceIsAndroid && (layer.addEventListener("mouseover", this.onMouse, !0), 
    layer.addEventListener("mousedown", this.onMouse, !0), layer.addEventListener("mouseup", this.onMouse, !0)), 
    layer.addEventListener("click", this.onClick, !0), layer.addEventListener("touchstart", this.onTouchStart, !1), 
    layer.addEventListener("touchmove", this.onTouchMove, !1), layer.addEventListener("touchend", this.onTouchEnd, !1), 
    layer.addEventListener("touchcancel", this.onTouchCancel, !1), // Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
    // which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
    // layer when they are cancelled.
    Event.prototype.stopImmediatePropagation || (layer.removeEventListener = function(type, callback, capture) {
        var rmv = Node.prototype.removeEventListener;
        "click" === type ? rmv.call(layer, type, callback.hijacked || callback, capture) : rmv.call(layer, type, callback, capture);
    }, layer.addEventListener = function(type, callback, capture) {
        var adv = Node.prototype.addEventListener;
        "click" === type ? adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
            event.propagationStopped || callback(event);
        }), capture) : adv.call(layer, type, callback, capture);
    }), // If a handler is already declared in the element's onclick attribute, it will be fired before
    // FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
    // adding it as listener.
    "function" == typeof layer.onclick && (// Android browser on at least 3.2 requires a new reference to the function in layer.onclick
    // - the old one won't work if passed to addEventListener directly.
    oldOnClick = layer.onclick, layer.addEventListener("click", function(event) {
        oldOnClick(event);
    }, !1), layer.onclick = null));
}

!function(window) {
    "use strict";
    window.SM2_DEFER = !0;
}(window), window.Modernizr = function(window, document, undefined) {
    function setCss(str) {
        mStyle.cssText = str;
    }
    function is(obj, type) {
        return typeof obj === type;
    }
    function contains(str, substr) {
        return !!~("" + str).indexOf(substr);
    }
    function testProps(props, prefixed) {
        for (var i in props) {
            var prop = props[i];
            if (!contains(prop, "-") && mStyle[prop] !== undefined) return "pfx" == prefixed ? prop : !0;
        }
        return !1;
    }
    function testDOMProps(props, obj, elem) {
        for (var i in props) {
            var item = obj[props[i]];
            if (item !== undefined) return elem === !1 ? props[i] : is(item, "function") ? item.bind(elem || obj) : item;
        }
        return !1;
    }
    function testPropsAll(prop, prefixed, elem) {
        var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1), props = (prop + " " + cssomPrefixes.join(ucProp + " ") + ucProp).split(" ");
        return is(prefixed, "string") || is(prefixed, "undefined") ? testProps(props, prefixed) : (props = (prop + " " + domPrefixes.join(ucProp + " ") + ucProp).split(" "), 
        testDOMProps(props, prefixed, elem));
    }
    var inputElem, featureName, hasOwnProp, version = "2.7.1", Modernizr = {}, enableClasses = !0, docElement = document.documentElement, mod = "modernizr", modElem = document.createElement(mod), mStyle = modElem.style, prefixes = ({}.toString, 
    " -webkit- -moz- -o- -ms- ".split(" ")), omPrefixes = "Webkit Moz O ms", cssomPrefixes = omPrefixes.split(" "), domPrefixes = omPrefixes.toLowerCase().split(" "), ns = {
        svg: "http://www.w3.org/2000/svg"
    }, tests = {}, classes = [], slice = classes.slice, injectElementWithStyles = function(rule, callback, nodes, testnames) {
        var style, ret, node, docOverflow, div = document.createElement("div"), body = document.body, fakeBody = body || document.createElement("body");
        if (parseInt(nodes, 10)) for (;nodes--; ) node = document.createElement("div"), 
        node.id = testnames ? testnames[nodes] : mod + (nodes + 1), div.appendChild(node);
        return style = [ "&#173;", '<style id="s', mod, '">', rule, "</style>" ].join(""), 
        div.id = mod, (body ? div : fakeBody).innerHTML += style, fakeBody.appendChild(div), 
        body || (fakeBody.style.background = "", fakeBody.style.overflow = "hidden", docOverflow = docElement.style.overflow, 
        docElement.style.overflow = "hidden", docElement.appendChild(fakeBody)), ret = callback(div, rule), 
        body ? div.parentNode.removeChild(div) : (fakeBody.parentNode.removeChild(fakeBody), 
        docElement.style.overflow = docOverflow), !!ret;
    }, _hasOwnProperty = {}.hasOwnProperty;
    hasOwnProp = is(_hasOwnProperty, "undefined") || is(_hasOwnProperty.call, "undefined") ? function(object, property) {
        return property in object && is(object.constructor.prototype[property], "undefined");
    } : function(object, property) {
        return _hasOwnProperty.call(object, property);
    }, Function.prototype.bind || (Function.prototype.bind = function(that) {
        var target = this;
        if ("function" != typeof target) throw new TypeError();
        var args = slice.call(arguments, 1), bound = function() {
            if (this instanceof bound) {
                var F = function() {};
                F.prototype = target.prototype;
                var self = new F(), result = target.apply(self, args.concat(slice.call(arguments)));
                return Object(result) === result ? result : self;
            }
            return target.apply(that, args.concat(slice.call(arguments)));
        };
        return bound;
    }), tests.canvas = function() {
        var elem = document.createElement("canvas");
        return !(!elem.getContext || !elem.getContext("2d"));
    }, tests.touch = function() {
        var bool;
        return "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch ? bool = !0 : injectElementWithStyles([ "@media (", prefixes.join("touch-enabled),("), mod, ")", "{#modernizr{top:9px;position:absolute}}" ].join(""), function(node) {
            bool = 9 === node.offsetTop;
        }), bool;
    }, tests.rgba = function() {
        return setCss("background-color:rgba(150,255,150,.5)"), contains(mStyle.backgroundColor, "rgba");
    }, tests.multiplebgs = function() {
        return setCss("background:url(https://),url(https://),red url(https://)"), /(url\s*\(.*?){3}/.test(mStyle.background);
    }, tests.boxshadow = function() {
        return testPropsAll("boxShadow");
    }, tests.csstransforms = function() {
        return !!testPropsAll("transform");
    }, tests.csstransforms3d = function() {
        var ret = !!testPropsAll("perspective");
        return ret && "webkitPerspective" in docElement.style && injectElementWithStyles("@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}", function(node) {
            ret = 9 === node.offsetLeft && 3 === node.offsetHeight;
        }), ret;
    }, tests.csstransitions = function() {
        return testPropsAll("transition");
    }, tests.audio = function() {
        var elem = document.createElement("audio"), bool = !1;
        try {
            (bool = !!elem.canPlayType) && (bool = new Boolean(bool), bool.ogg = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), 
            bool.mp3 = elem.canPlayType("audio/mpeg;").replace(/^no$/, ""), bool.wav = elem.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""), 
            bool.m4a = (elem.canPlayType("audio/x-m4a;") || elem.canPlayType("audio/aac;")).replace(/^no$/, ""));
        } catch (e) {}
        return bool;
    }, tests.localstorage = function() {
        try {
            return localStorage.setItem(mod, mod), localStorage.removeItem(mod), !0;
        } catch (e) {
            return !1;
        }
    }, tests.svg = function() {
        return !!document.createElementNS && !!document.createElementNS(ns.svg, "svg").createSVGRect;
    };
    for (var feature in tests) hasOwnProp(tests, feature) && (featureName = feature.toLowerCase(), 
    Modernizr[featureName] = tests[feature](), classes.push((Modernizr[featureName] ? "" : "no-") + featureName));
    return Modernizr.addTest = function(feature, test) {
        if ("object" == typeof feature) for (var key in feature) hasOwnProp(feature, key) && Modernizr.addTest(key, feature[key]); else {
            if (feature = feature.toLowerCase(), Modernizr[feature] !== undefined) return Modernizr;
            test = "function" == typeof test ? test() : test, "undefined" != typeof enableClasses && enableClasses && (docElement.className += " " + (test ? "" : "no-") + feature), 
            Modernizr[feature] = test;
        }
        return Modernizr;
    }, setCss(""), modElem = inputElem = null, function(window, document) {
        function addStyleSheet(ownerDocument, cssText) {
            var p = ownerDocument.createElement("p"), parent = ownerDocument.getElementsByTagName("head")[0] || ownerDocument.documentElement;
            return p.innerHTML = "x<style>" + cssText + "</style>", parent.insertBefore(p.lastChild, parent.firstChild);
        }
        function getElements() {
            var elements = html5.elements;
            return "string" == typeof elements ? elements.split(" ") : elements;
        }
        function getExpandoData(ownerDocument) {
            var data = expandoData[ownerDocument[expando]];
            return data || (data = {}, expanID++, ownerDocument[expando] = expanID, expandoData[expanID] = data), 
            data;
        }
        function createElement(nodeName, ownerDocument, data) {
            if (ownerDocument || (ownerDocument = document), supportsUnknownElements) return ownerDocument.createElement(nodeName);
            data || (data = getExpandoData(ownerDocument));
            var node;
            return node = data.cache[nodeName] ? data.cache[nodeName].cloneNode() : saveClones.test(nodeName) ? (data.cache[nodeName] = data.createElem(nodeName)).cloneNode() : data.createElem(nodeName), 
            !node.canHaveChildren || reSkip.test(nodeName) || node.tagUrn ? node : data.frag.appendChild(node);
        }
        function createDocumentFragment(ownerDocument, data) {
            if (ownerDocument || (ownerDocument = document), supportsUnknownElements) return ownerDocument.createDocumentFragment();
            data = data || getExpandoData(ownerDocument);
            for (var clone = data.frag.cloneNode(), i = 0, elems = getElements(), l = elems.length; l > i; i++) clone.createElement(elems[i]);
            return clone;
        }
        function shivMethods(ownerDocument, data) {
            data.cache || (data.cache = {}, data.createElem = ownerDocument.createElement, data.createFrag = ownerDocument.createDocumentFragment, 
            data.frag = data.createFrag()), ownerDocument.createElement = function(nodeName) {
                return html5.shivMethods ? createElement(nodeName, ownerDocument, data) : data.createElem(nodeName);
            }, ownerDocument.createDocumentFragment = Function("h,f", "return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(" + getElements().join().replace(/[\w\-]+/g, function(nodeName) {
                return data.createElem(nodeName), data.frag.createElement(nodeName), 'c("' + nodeName + '")';
            }) + ");return n}")(html5, data.frag);
        }
        function shivDocument(ownerDocument) {
            ownerDocument || (ownerDocument = document);
            var data = getExpandoData(ownerDocument);
            return !html5.shivCSS || supportsHtml5Styles || data.hasCSS || (data.hasCSS = !!addStyleSheet(ownerDocument, "article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")), 
            supportsUnknownElements || shivMethods(ownerDocument, data), ownerDocument;
        }
        var supportsHtml5Styles, supportsUnknownElements, version = "3.7.0", options = window.html5 || {}, reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i, saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i, expando = "_html5shiv", expanID = 0, expandoData = {};
        !function() {
            try {
                var a = document.createElement("a");
                a.innerHTML = "<xyz></xyz>", supportsHtml5Styles = "hidden" in a, supportsUnknownElements = 1 == a.childNodes.length || function() {
                    document.createElement("a");
                    var frag = document.createDocumentFragment();
                    return "undefined" == typeof frag.cloneNode || "undefined" == typeof frag.createDocumentFragment || "undefined" == typeof frag.createElement;
                }();
            } catch (e) {
                supportsHtml5Styles = !0, supportsUnknownElements = !0;
            }
        }();
        var html5 = {
            elements: options.elements || "abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",
            version: version,
            shivCSS: options.shivCSS !== !1,
            supportsUnknownElements: supportsUnknownElements,
            shivMethods: options.shivMethods !== !1,
            type: "default",
            shivDocument: shivDocument,
            createElement: createElement,
            createDocumentFragment: createDocumentFragment
        };
        window.html5 = html5, shivDocument(document);
    }(this, document), Modernizr._version = version, Modernizr._prefixes = prefixes, 
    Modernizr._domPrefixes = domPrefixes, Modernizr._cssomPrefixes = cssomPrefixes, 
    Modernizr.testProp = function(prop) {
        return testProps([ prop ]);
    }, Modernizr.testAllProps = testPropsAll, Modernizr.testStyles = injectElementWithStyles, 
    Modernizr.prefixed = function(prop, obj, elem) {
        return obj ? testPropsAll(prop, obj, elem) : testPropsAll(prop, "pfx");
    }, docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") + (enableClasses ? " js " + classes.join(" ") : ""), 
    Modernizr;
}(this, this.document), /** Notify.js - v0.3.1 - 2013/07/05
 * http://notifyjs.com/
 * Copyright (c) 2013 Jaime Pillora - MIT
 */
function(window, document, $, undefined) {
    "use strict";
    var Notification, addStyle, blankFieldName, coreStyle, createElem, defaults, encode, find, findFields, getAnchorElement, getStyle, globalAnchors, hAligns, incr, inherit, insertCSS, mainPositions, opposites, parsePosition, pluginClassName, pluginName, pluginOptions, positions, realign, stylePrefixes, styles, vAligns, __indexOf = [].indexOf || function(item) {
        for (var i = 0, l = this.length; l > i; i++) if (i in this && this[i] === item) return i;
        return -1;
    };
    pluginName = "notify", pluginClassName = pluginName + "js", blankFieldName = pluginName + "!blank", 
    positions = {
        t: "top",
        m: "middle",
        b: "bottom",
        l: "left",
        c: "center",
        r: "right"
    }, hAligns = [ "l", "c", "r" ], vAligns = [ "t", "m", "b" ], mainPositions = [ "t", "b", "l", "r" ], 
    opposites = {
        t: "b",
        m: null,
        b: "t",
        l: "r",
        c: null,
        r: "l"
    }, parsePosition = function(str) {
        var pos;
        return pos = [], $.each(str.split(/\W+/), function(i, word) {
            var w;
            return w = word.toLowerCase().charAt(0), positions[w] ? pos.push(w) : void 0;
        }), pos;
    }, styles = {}, coreStyle = {
        name: "core",
        html: '<div class="' + pluginClassName + '-wrapper">\n  <div class="' + pluginClassName + '-arrow"></div>\n  <div class="' + pluginClassName + '-container"></div>\n</div>',
        css: "." + pluginClassName + "-corner {\n  position: fixed;\n  margin: 5px;\n  z-index: 1050;\n}\n\n." + pluginClassName + "-corner ." + pluginClassName + "-wrapper,\n." + pluginClassName + "-corner ." + pluginClassName + "-container {\n  position: relative;\n  display: block;\n  height: inherit;\n  width: inherit;\n  margin: 3px;\n}\n\n." + pluginClassName + "-wrapper {\n  z-index: 1;\n  position: absolute;\n  display: inline-block;\n  height: 0;\n  width: 0;\n}\n\n." + pluginClassName + "-container {\n  display: none;\n  z-index: 1;\n  position: absolute;\n  cursor: pointer;\n}\n\n[data-notify-text],[data-notify-html] {\n  position: relative;\n}\n\n." + pluginClassName + "-arrow {\n  position: absolute;\n  z-index: 2;\n  width: 0;\n  height: 0;\n}"
    }, stylePrefixes = {
        "border-radius": [ "-webkit-", "-moz-" ]
    }, getStyle = function(name) {
        return styles[name];
    }, addStyle = function(name, def) {
        var cssText, elem, fields, _ref;
        if (!name) throw "Missing Style name";
        if (!def) throw "Missing Style definition";
        if (!def.html) throw "Missing Style HTML";
        //    if (window.console) {
        //      console.warn("" + pluginName + ": overwriting style '" + name + "'");
        //    }
        return (null != (_ref = styles[name]) ? _ref.cssElem : void 0) && styles[name].cssElem.remove(), 
        def.name = name, styles[name] = def, cssText = "", def.classes && $.each(def.classes, function(className, props) {
            return cssText += "." + pluginClassName + "-" + def.name + "-" + className + " {\n", 
            $.each(props, function(name, val) {
                return stylePrefixes[name] && $.each(stylePrefixes[name], function(i, prefix) {
                    return cssText += "  " + prefix + name + ": " + val + ";\n";
                }), cssText += "  " + name + ": " + val + ";\n";
            }), cssText += "}\n";
        }), def.css && (cssText += "/* styles for " + def.name + " */\n" + def.css), cssText && (def.cssElem = insertCSS(cssText), 
        def.cssElem.attr("id", "notify-" + def.name)), fields = {}, elem = $(def.html), 
        findFields("html", elem, fields), findFields("text", elem, fields), def.fields = fields;
    }, insertCSS = function(cssText) {
        var elem;
        elem = createElem("style"), elem.attr("type", "text/css"), $("head").append(elem);
        try {
            elem.html(cssText);
        } catch (e) {
            elem[0].styleSheet.cssText = cssText;
        }
        return elem;
    }, findFields = function(type, elem, fields) {
        var attr;
        return "html" !== type && (type = "text"), attr = "data-notify-" + type, find(elem, "[" + attr + "]").each(function() {
            var name;
            return name = $(this).attr(attr), name || (name = blankFieldName), fields[name] = type;
        });
    }, find = function(elem, selector) {
        return elem.is(selector) ? elem : elem.find(selector);
    }, pluginOptions = {
        clickToHide: !0,
        autoHide: !0,
        autoHideDelay: 5e3,
        arrowShow: !0,
        arrowSize: 5,
        breakNewLines: !0,
        elementPosition: "bottom",
        globalPosition: "top right",
        style: "bootstrap",
        className: "error",
        showAnimation: "slideDown",
        showDuration: 400,
        hideAnimation: "slideUp",
        hideDuration: 200,
        gap: 5
    }, inherit = function(a, b) {
        var F;
        return F = function() {}, F.prototype = a, $.extend(!0, new F(), b);
    }, defaults = function(opts) {
        return $.extend(pluginOptions, opts);
    }, createElem = function(tag) {
        return $("<" + tag + "></" + tag + ">");
    }, globalAnchors = {}, getAnchorElement = function(element) {
        var radios;
        return element.is("[type=radio]") && (radios = element.parents("form:first").find("[type=radio]").filter(function(i, e) {
            return $(e).attr("name") === element.attr("name");
        }), element = radios.first()), element;
    }, incr = function(obj, pos, val) {
        var opp, temp;
        if ("string" == typeof val) val = parseInt(val, 10); else if ("number" != typeof val) return;
        if (!isNaN(val)) return opp = positions[opposites[pos.charAt(0)]], temp = pos, obj[opp] !== undefined && (pos = positions[opp.charAt(0)], 
        val = -val), obj[pos] === undefined ? obj[pos] = val : obj[pos] += val, null;
    }, realign = function(alignment, inner, outer) {
        if ("l" === alignment || "t" === alignment) return 0;
        if ("c" === alignment || "m" === alignment) return outer / 2 - inner / 2;
        if ("r" === alignment || "b" === alignment) return outer - inner;
        throw "Invalid alignment";
    }, encode = function(text) {
        return encode.e = encode.e || createElem("div"), encode.e.text(text).html();
    }, Notification = function() {
        function Notification(elem, data, options) {
            "string" == typeof options && (options = {
                className: options
            }), this.options = inherit(pluginOptions, $.isPlainObject(options) ? options : {}), 
            this.loadHTML(), this.wrapper = $(coreStyle.html), this.wrapper.data(pluginClassName, this), 
            this.arrow = this.wrapper.find("." + pluginClassName + "-arrow"), this.container = this.wrapper.find("." + pluginClassName + "-container"), 
            this.container.append(this.userContainer), elem && elem.length && (this.elementType = elem.attr("type"), 
            this.originalElement = elem, this.elem = getAnchorElement(elem), this.elem.data(pluginClassName, this), 
            this.elem.before(this.wrapper)), this.container.hide(), this.run(data);
        }
        return Notification.prototype.loadHTML = function() {
            var style;
            return style = this.getStyle(), this.userContainer = $(style.html), this.userFields = style.fields;
        }, Notification.prototype.show = function(show, userCallback) {
            var args, callback, elems, fn, hidden, _this = this;
            if (callback = function() {
                return show || _this.elem || _this.destroy(), userCallback ? userCallback() : void 0;
            }, hidden = this.container.parent().parents(":hidden").length > 0, elems = this.container.add(this.arrow), 
            args = [], hidden && show) fn = "show"; else if (hidden && !show) fn = "hide"; else if (!hidden && show) fn = this.options.showAnimation, 
            args.push(this.options.showDuration); else {
                if (hidden || show) return callback();
                fn = this.options.hideAnimation, args.push(this.options.hideDuration);
            }
            return args.push(callback), elems[fn].apply(elems, args);
        }, Notification.prototype.setGlobalPosition = function() {
            var align, anchor, css, key, main, pAlign, pMain, position;
            return position = this.getPosition(), pMain = position[0], pAlign = position[1], 
            main = positions[pMain], align = positions[pAlign], key = pMain + "|" + pAlign, 
            anchor = globalAnchors[key], anchor || (anchor = globalAnchors[key] = createElem("div"), 
            css = {}, css[main] = 0, "middle" === align ? css.top = "45%" : "center" === align ? css.left = "45%" : css[align] = 0, 
            anchor.css(css).addClass("" + pluginClassName + "-corner"), $("body").append(anchor)), 
            anchor.prepend(this.wrapper);
        }, Notification.prototype.setElementPosition = function() {
            var arrowColor, arrowCss, arrowSize, color, contH, contW, css, elemH, elemIH, elemIW, elemPos, elemW, gap, mainFull, margin, opp, oppFull, pAlign, pArrow, pMain, pos, posFull, position, wrapPos, _i, _j, _len, _len1, _ref;
            for (position = this.getPosition(), pMain = position[0], pAlign = position[1], pArrow = position[2], 
            elemPos = this.elem.position(), elemH = this.elem.outerHeight(), elemW = this.elem.outerWidth(), 
            elemIH = this.elem.innerHeight(), elemIW = this.elem.innerWidth(), wrapPos = this.wrapper.position(), 
            contH = this.container.height(), contW = this.container.width(), mainFull = positions[pMain], 
            opp = opposites[pMain], oppFull = positions[opp], css = {}, css[oppFull] = "b" === pMain ? elemH : "r" === pMain ? elemW : 0, 
            incr(css, "top", elemPos.top - wrapPos.top), incr(css, "left", elemPos.left - wrapPos.left), 
            _ref = [ "top", "left" ], _i = 0, _len = _ref.length; _len > _i; _i++) pos = _ref[_i], 
            margin = parseInt(this.elem.css("margin-" + pos), 10), margin && incr(css, pos, margin);
            if (gap = Math.max(0, this.options.gap - (this.options.arrowShow ? arrowSize : 0)), 
            incr(css, oppFull, gap), this.options.arrowShow) {
                for (arrowSize = this.options.arrowSize, arrowCss = $.extend({}, css), arrowColor = this.userContainer.css("border-color") || this.userContainer.css("background-color") || "white", 
                _j = 0, _len1 = mainPositions.length; _len1 > _j; _j++) pos = mainPositions[_j], 
                posFull = positions[pos], pos !== opp && (color = posFull === mainFull ? arrowColor : "transparent", 
                arrowCss["border-" + posFull] = "" + arrowSize + "px solid " + color);
                incr(css, positions[opp], arrowSize), __indexOf.call(mainPositions, pAlign) >= 0 && incr(arrowCss, positions[pAlign], 2 * arrowSize);
            } else this.arrow.hide();
            return __indexOf.call(vAligns, pMain) >= 0 ? (incr(css, "left", realign(pAlign, contW, elemW)), 
            arrowCss && incr(arrowCss, "left", realign(pAlign, arrowSize, elemIW))) : __indexOf.call(hAligns, pMain) >= 0 && (incr(css, "top", realign(pAlign, contH, elemH)), 
            arrowCss && incr(arrowCss, "top", realign(pAlign, arrowSize, elemIH))), this.container.is(":visible") && (css.display = "block"), 
            this.container.removeAttr("style").css(css), arrowCss ? this.arrow.removeAttr("style").css(arrowCss) : void 0;
        }, Notification.prototype.getPosition = function() {
            var pos, text, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
            if (text = this.options.position || (this.elem ? this.options.elementPosition : this.options.globalPosition), 
            pos = parsePosition(text), 0 === pos.length && (pos[0] = "b"), _ref = pos[0], __indexOf.call(mainPositions, _ref) < 0) throw "Must be one of [" + mainPositions + "]";
            return (1 === pos.length || (_ref1 = pos[0], __indexOf.call(vAligns, _ref1) >= 0 && (_ref2 = pos[1], 
            __indexOf.call(hAligns, _ref2) < 0)) || (_ref3 = pos[0], __indexOf.call(hAligns, _ref3) >= 0 && (_ref4 = pos[1], 
            __indexOf.call(vAligns, _ref4) < 0))) && (pos[1] = (_ref5 = pos[0], __indexOf.call(hAligns, _ref5) >= 0 ? "m" : "l")), 
            2 === pos.length && (pos[2] = pos[1]), pos;
        }, Notification.prototype.getStyle = function(name) {
            var style;
            if (name || (name = this.options.style), name || (name = "default"), style = styles[name], 
            !style) throw "Missing style: " + name;
            return style;
        }, Notification.prototype.updateClasses = function() {
            var classes, style;
            return classes = [ "base" ], $.isArray(this.options.className) ? classes = classes.concat(this.options.className) : this.options.className && classes.push(this.options.className), 
            style = this.getStyle(), classes = $.map(classes, function(n) {
                return "" + pluginClassName + "-" + style.name + "-" + n;
            }).join(" "), this.userContainer.attr("class", classes);
        }, Notification.prototype.run = function(data, options) {
            var d, datas, name, type, value, _this = this;
            if ($.isPlainObject(options) ? $.extend(this.options, options) : "string" === $.type(options) && (this.options.color = options), 
            this.container && !data) return void this.show(!1);
            if (this.container || data) {
                datas = {}, $.isPlainObject(data) ? datas = data : datas[blankFieldName] = data;
                for (name in datas) d = datas[name], type = this.userFields[name], type && ("text" === type && (d = encode(d), 
                this.options.breakNewLines && (d = d.replace(/\n/g, "<br/>"))), value = name === blankFieldName ? "" : "=" + name, 
                find(this.userContainer, "[data-notify-" + type + value + "]").html(d));
                return this.updateClasses(), this.elem ? this.setElementPosition() : this.setGlobalPosition(), 
                this.show(!0), this.options.autoHide ? (clearTimeout(this.autohideTimer), this.autohideTimer = setTimeout(function() {
                    return _this.show(!1);
                }, this.options.autoHideDelay)) : void 0;
            }
        }, Notification.prototype.destroy = function() {
            return this.wrapper.remove();
        }, Notification;
    }(), $[pluginName] = function(elem, data, options) {
        return elem && elem.nodeName || elem.jquery ? $(elem)[pluginName](data, options) : (options = data, 
        data = elem, new Notification(null, data, options)), elem;
    }, $.fn[pluginName] = function(data, options) {
        return $(this).each(function() {
            var inst;
            return inst = getAnchorElement($(this)).data(pluginClassName), inst ? inst.run(data, options) : new Notification($(this), data, options);
        }), this;
    }, $.extend($[pluginName], {
        defaults: defaults,
        addStyle: addStyle,
        pluginOptions: pluginOptions,
        getStyle: getStyle,
        insertCSS: insertCSS
    }), $(function() {
        return insertCSS(coreStyle.css).attr("id", "core-notify"), $(document).on("click notify-hide", "." + pluginClassName + "-wrapper", function(e) {
            var inst;
            return inst = $(this).data(pluginClassName), inst && (inst.options.clickToHide || "notify-hide" === e.type) ? inst.show(!1) : void 0;
        });
    });
}(window, document, jQuery), $.notify.addStyle("activetext", {
    html: "<div><span data-notify-text></span></div>",
    classes: {
        base: {
            "white-space": "nowrap",
            "background-color": "white",
            padding: "5px",
            "-webkit-border-radius": "3px",
            "-moz-border-radius": "3px",
            "border-radius": "3px",
            "font-size": "0.8em"
        },
        info: {
            color: "black",
            border: "1px solid black"
        }
    }
}), $.notify.defaults({
    style: "activetext",
    className: "info",
    showAnimation: "fadeIn",
    showDuration: 100,
    hideAnimation: "fadeOut",
    hideDuration: 100
}), function() {
    /*--------------------------------------------------------------------------*/
    /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
    function baseIndexOf(array, value, fromIndex) {
        for (var index = (fromIndex || 0) - 1, length = array ? array.length : 0; ++index < length; ) if (array[index] === value) return index;
        return -1;
    }
    /**
   * An implementation of `_.contains` for cache objects that mimics the return
   * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache object to inspect.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
    function cacheIndexOf(cache, value) {
        var type = typeof value;
        if (cache = cache.cache, "boolean" == type || null == value) return cache[value] ? 0 : -1;
        "number" != type && "string" != type && (type = "object");
        var key = "number" == type ? value : keyPrefix + value;
        return cache = (cache = cache[type]) && cache[key], "object" == type ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
    }
    /**
   * Adds a given value to the corresponding cache object.
   *
   * @private
   * @param {*} value The value to add to the cache.
   */
    function cachePush(value) {
        var cache = this.cache, type = typeof value;
        if ("boolean" == type || null == value) cache[value] = !0; else {
            "number" != type && "string" != type && (type = "object");
            var key = "number" == type ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
            "object" == type ? (typeCache[key] || (typeCache[key] = [])).push(value) : typeCache[key] = !0;
        }
    }
    /**
   * Used by `_.max` and `_.min` as the default callback when a given
   * collection is a string value.
   *
   * @private
   * @param {string} value The character to inspect.
   * @returns {number} Returns the code unit of given character.
   */
    function charAtCallback(value) {
        return value.charCodeAt(0);
    }
    /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
    function compareAscending(a, b) {
        var ac = a.criteria, bc = b.criteria;
        // ensure a stable sort in V8 and other engines
        // http://code.google.com/p/v8/issues/detail?id=90
        if (ac !== bc) {
            if (ac > bc || "undefined" == typeof ac) return 1;
            if (bc > ac || "undefined" == typeof bc) return -1;
        }
        // The JS engine embedded in Adobe applications like InDesign has a buggy
        // `Array#sort` implementation that causes it, under certain circumstances,
        // to return the same value for `a` and `b`.
        // See https://github.com/jashkenas/underscore/pull/1247
        return a.index - b.index;
    }
    /**
   * Creates a cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [array=[]] The array to search.
   * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
   */
    function createCache(array) {
        var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
        if (first && "object" == typeof first && mid && "object" == typeof mid && last && "object" == typeof last) return !1;
        var cache = getObject();
        cache["false"] = cache["null"] = cache["true"] = cache.undefined = !1;
        var result = getObject();
        for (result.array = array, result.cache = cache, result.push = cachePush; ++index < length; ) result.push(array[index]);
        return result;
    }
    /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
    function escapeStringChar(match) {
        return "\\" + stringEscapes[match];
    }
    /**
   * Gets an array from the array pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Array} The array from the pool.
   */
    function getArray() {
        return arrayPool.pop() || [];
    }
    /**
   * Gets an object from the object pool or creates a new one if the pool is empty.
   *
   * @private
   * @returns {Object} The object from the pool.
   */
    function getObject() {
        return objectPool.pop() || {
            args: "",
            array: null,
            bottom: "",
            cache: null,
            configurable: !1,
            criteria: null,
            enumerable: !1,
            "false": !1,
            firstArg: "",
            index: 0,
            init: "",
            keys: null,
            leading: !1,
            loop: "",
            maxWait: 0,
            "null": !1,
            number: null,
            object: null,
            push: null,
            shadowedProps: null,
            string: null,
            top: "",
            trailing: !1,
            "true": !1,
            undefined: !1,
            useHas: !1,
            value: null,
            writable: !1
        };
    }
    /**
   * Checks if `value` is a DOM node in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
   */
    function isNode(value) {
        // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
        // methods that are `typeof` "string" and still can coerce nodes to strings
        return "function" != typeof value.toString && "string" == typeof (value + "");
    }
    /**
   * A no-operation function.
   *
   * @private
   */
    function noop() {}
    /**
   * Releases the given array back to the array pool.
   *
   * @private
   * @param {Array} [array] The array to release.
   */
    function releaseArray(array) {
        array.length = 0, arrayPool.length < maxPoolSize && arrayPool.push(array);
    }
    /**
   * Releases the given object back to the object pool.
   *
   * @private
   * @param {Object} [object] The object to release.
   */
    function releaseObject(object) {
        var cache = object.cache;
        cache && releaseObject(cache), object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null, 
        objectPool.length < maxPoolSize && objectPool.push(object);
    }
    /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE < 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
    function slice(array, start, end) {
        start || (start = 0), "undefined" == typeof end && (end = array ? array.length : 0);
        for (var index = -1, length = end - start || 0, result = Array(0 > length ? 0 : length); ++index < length; ) result[index] = array[start + index];
        return result;
    }
    /*--------------------------------------------------------------------------*/
    /**
   * Create a new `lodash` function using the given context object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns the `lodash` function.
   */
    function runInContext(context) {
        /*--------------------------------------------------------------------------*/
        /**
     * Creates a `lodash` object which wraps the given value to enable method
     * chaining.
     *
     * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
     * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
     * and `unshift`
     *
     * Chaining is supported in custom builds as long as the `value` method is
     * implicitly or explicitly included in the build.
     *
     * The chainable wrapper functions are:
     * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
     * `compose`, `concat`, `countBy`, `createCallback`, `curry`, `debounce`,
     * `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`, `forEach`,
     * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
     * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
     * `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`, `once`, `pairs`,
     * `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`, `range`, `reject`,
     * `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`, `sortBy`, `splice`,
     * `tap`, `throttle`, `times`, `toArray`, `transform`, `union`, `uniq`, `unshift`,
     * `unzip`, `values`, `where`, `without`, `wrap`, and `zip`
     *
     * The non-chainable wrapper functions are:
     * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
     * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
     * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
     * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
     * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
     * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
     * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
     * `template`, `unescape`, `uniqueId`, and `value`
     *
     * The wrapper functions `first` and `last` return wrapped values when `n` is
     * provided, otherwise they return unwrapped values.
     *
     * @name _
     * @constructor
     * @category Chaining
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns a `lodash` instance.
     * @example
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // returns an unwrapped value
     * wrapped.reduce(function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * // returns a wrapped value
     * var squares = wrapped.map(function(num) {
     *   return num * num;
     * });
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
        function lodash(value) {
            // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
            return value && "object" == typeof value && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
        }
        /**
     * A fast path for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap in a `lodash` instance.
     * @param {boolean} chainAll A flag to enable chaining for all methods
     * @returns {Object} Returns a `lodash` instance.
     */
        function lodashWrapper(value, chainAll) {
            this.__chain__ = !!chainAll, this.__wrapped__ = value;
        }
        /*--------------------------------------------------------------------------*/
        /**
     * The base implementation of `_.clone` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} [deep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates clones with source counterparts.
     * @returns {*} Returns the cloned `value`.
     */
        function baseClone(value, deep, callback, stackA, stackB) {
            var result = value;
            if (callback) {
                if (result = callback(result), "undefined" != typeof result) return result;
                result = value;
            }
            // inspect [[Class]]
            var isObj = isObject(result);
            if (isObj) {
                var className = toString.call(result);
                if (!cloneableClasses[className] || !support.nodeClass && isNode(result)) return result;
                var isArr = isArray(result);
            }
            // shallow clone
            if (!isObj || !deep) return isObj ? isArr ? slice(result) : assign({}, result) : result;
            var ctor = ctorByClass[className];
            switch (className) {
              case boolClass:
              case dateClass:
                return new ctor(+result);

              case numberClass:
              case stringClass:
                return new ctor(result);

              case regexpClass:
                return ctor(result.source, reFlags.exec(result));
            }
            // check for circular references and return corresponding clone
            var initedStack = !stackA;
            stackA || (stackA = getArray()), stackB || (stackB = getArray());
            for (var length = stackA.length; length--; ) if (stackA[length] == value) return stackB[length];
            // init cloned object
            // add array properties assigned by `RegExp#exec`
            // add the source value to the stack of traversed objects
            // and associate it with its clone
            // recursively populate clone (susceptible to call stack limits)
            return result = isArr ? ctor(result.length) : {}, isArr && (hasOwnProperty.call(value, "index") && (result.index = value.index), 
            hasOwnProperty.call(value, "input") && (result.input = value.input)), stackA.push(value), 
            stackB.push(result), (isArr ? baseEach : forOwn)(value, function(objValue, key) {
                result[key] = baseClone(objValue, deep, callback, stackA, stackB);
            }), initedStack && (releaseArray(stackA), releaseArray(stackB)), result;
        }
        /**
     * The base implementation of `_.createCallback` without support for creating
     * "_.pluck" or "_.where" style callbacks.
     *
     * @private
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     */
        function baseCreateCallback(func, thisArg, argCount) {
            if ("function" != typeof func) return identity;
            // exit early if there is no `thisArg`
            if ("undefined" == typeof thisArg) return func;
            var bindData = func.__bindData__ || support.funcNames && !func.name;
            if ("undefined" == typeof bindData) {
                var source = reThis && fnToString.call(func);
                support.funcNames || !source || reFuncName.test(source) || (bindData = !0), (support.funcNames || !bindData) && (// checks if `func` references the `this` keyword and stores the result
                bindData = !support.funcDecomp || reThis.test(source), setBindData(func, bindData));
            }
            // exit early if there are no `this` references or `func` is bound
            if (bindData !== !0 && bindData && 1 & bindData[1]) return func;
            switch (argCount) {
              case 1:
                return function(value) {
                    return func.call(thisArg, value);
                };

              case 2:
                return function(a, b) {
                    return func.call(thisArg, a, b);
                };

              case 3:
                return function(value, index, collection) {
                    return func.call(thisArg, value, index, collection);
                };

              case 4:
                return function(accumulator, value, index, collection) {
                    return func.call(thisArg, accumulator, value, index, collection);
                };
            }
            return bind(func, thisArg);
        }
        /**
     * The base implementation of `_.flatten` without support for callback
     * shorthands or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {boolean} [isArgArrays=false] A flag to restrict flattening to arrays and `arguments` objects.
     * @param {number} [fromIndex=0] The index to start from.
     * @returns {Array} Returns a new flattened array.
     */
        function baseFlatten(array, isShallow, isArgArrays, fromIndex) {
            for (var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = []; ++index < length; ) {
                var value = array[index];
                if (value && "object" == typeof value && "number" == typeof value.length && (isArray(value) || isArguments(value))) {
                    // recursively flatten arrays (susceptible to call stack limits)
                    isShallow || (value = baseFlatten(value, isShallow, isArgArrays));
                    var valIndex = -1, valLength = value.length, resIndex = result.length;
                    for (result.length += valLength; ++valIndex < valLength; ) result[resIndex++] = value[valIndex];
                } else isArgArrays || result.push(value);
            }
            return result;
        }
        /**
     * The base implementation of `_.isEqual`, without support for `thisArg` binding,
     * that allows partial "_.where" style comparisons.
     *
     * @private
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
     * @param {Array} [stackA=[]] Tracks traversed `a` objects.
     * @param {Array} [stackB=[]] Tracks traversed `b` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
        function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
            // used to indicate that when comparing objects, `a` has at least the properties of `b`
            if (callback) {
                var result = callback(a, b);
                if ("undefined" != typeof result) return !!result;
            }
            // exit early for identical values
            if (a === b) // treat `+0` vs. `-0` as not equal
            return 0 !== a || 1 / a == 1 / b;
            var type = typeof a, otherType = typeof b;
            // exit early for unlike primitive values
            if (!(a !== a || a && objectTypes[type] || b && objectTypes[otherType])) return !1;
            // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
            // http://es5.github.io/#x15.3.4.4
            if (null == a || null == b) return a === b;
            // compare [[Class]] names
            var className = toString.call(a), otherClass = toString.call(b);
            if (className == argsClass && (className = objectClass), otherClass == argsClass && (otherClass = objectClass), 
            className != otherClass) return !1;
            switch (className) {
              case boolClass:
              case dateClass:
                // coerce dates and booleans to numbers, dates to milliseconds and booleans
                // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
                return +a == +b;

              case numberClass:
                // treat `NaN` vs. `NaN` as equal
                return a != +a ? b != +b : 0 == a ? 1 / a == 1 / b : a == +b;

              case regexpClass:
              case stringClass:
                // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
                // treat string primitives and their corresponding object instances as equal
                return a == String(b);
            }
            var isArr = className == arrayClass;
            if (!isArr) {
                // unwrap any `lodash` wrapped values
                if (hasOwnProperty.call(a, "__wrapped__ ") || hasOwnProperty.call(b, "__wrapped__")) return baseIsEqual(a.__wrapped__ || a, b.__wrapped__ || b, callback, isWhere, stackA, stackB);
                // exit for functions and DOM nodes
                if (className != objectClass || !support.nodeClass && (isNode(a) || isNode(b))) return !1;
                // in older versions of Opera, `arguments` objects have `Array` constructors
                var ctorA = !support.argsObject && isArguments(a) ? Object : a.constructor, ctorB = !support.argsObject && isArguments(b) ? Object : b.constructor;
                // non `Object` object instances with different constructors are not equal
                if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB)) return !1;
            }
            // assume cyclic structures are equal
            // the algorithm for detecting cyclic structures is adapted from ES 5.1
            // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
            var initedStack = !stackA;
            stackA || (stackA = getArray()), stackB || (stackB = getArray());
            for (var length = stackA.length; length--; ) if (stackA[length] == a) return stackB[length] == b;
            var size = 0;
            // recursively compare objects and arrays (susceptible to call stack limits)
            if (result = !0, // add `a` and `b` to the stack of traversed objects
            stackA.push(a), stackB.push(b), isArr) {
                if (length = a.length, size = b.length, // compare lengths to determine if a deep comparison is necessary
                result = size == a.length, !result && !isWhere) return result;
                // deep compare the contents, ignoring non-numeric properties
                for (;size--; ) {
                    var index = length, value = b[size];
                    if (isWhere) for (;index-- && !(result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)); ) ; else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) break;
                }
                return result;
            }
            // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
            // which, in this case, is more costly
            // ensure both objects have the same number of properties
            return forIn(b, function(value, key, b) {
                // count the number of properties.
                return hasOwnProperty.call(b, key) ? (size++, result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB)) : void 0;
            }), result && !isWhere && forIn(a, function(value, key, a) {
                return hasOwnProperty.call(a, key) ? result = --size > -1 : void 0;
            }), initedStack && (releaseArray(stackA), releaseArray(stackB)), result;
        }
        /**
     * The base implementation of `_.merge` without argument juggling or support
     * for `thisArg` binding.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {Array} [stackA=[]] Tracks traversed source objects.
     * @param {Array} [stackB=[]] Associates values with source counterparts.
     */
        function baseMerge(object, source, callback, stackA, stackB) {
            (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                var found, isArr, result = source, value = object[key];
                if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                    for (// avoid merging previously merged cyclic sources
                    var stackLength = stackA.length; stackLength--; ) if (found = stackA[stackLength] == source) {
                        value = stackB[stackLength];
                        break;
                    }
                    if (!found) {
                        var isShallow;
                        callback && (result = callback(value, source), (isShallow = "undefined" != typeof result) && (value = result)), 
                        isShallow || (value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {}), 
                        // add `source` and associated `value` to the stack of traversed objects
                        stackA.push(source), stackB.push(value), // recursively merge objects and arrays (susceptible to call stack limits)
                        isShallow || baseMerge(value, source, callback, stackA, stackB);
                    }
                } else callback && (result = callback(value, source), "undefined" == typeof result && (result = source)), 
                "undefined" != typeof result && (value = result);
                object[key] = value;
            });
        }
        /**
     * The base implementation of `_.uniq` without support for callback shorthands
     * or `thisArg` binding.
     *
     * @private
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function} [callback] The function called per iteration.
     * @returns {Array} Returns a duplicate-value-free array.
     */
        function baseUniq(array, isSorted, callback) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [], isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
            if (isLarge) {
                var cache = createCache(seen);
                cache ? (indexOf = cacheIndexOf, seen = cache) : (isLarge = !1, seen = callback ? seen : (releaseArray(seen), 
                result));
            }
            for (;++index < length; ) {
                var value = array[index], computed = callback ? callback(value, index, array) : value;
                (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) && ((callback || isLarge) && seen.push(computed), 
                result.push(value));
            }
            return isLarge ? (releaseArray(seen.array), releaseObject(seen)) : callback && releaseArray(seen), 
            result;
        }
        /**
     * Creates a function that aggregates a collection, creating an object composed
     * of keys generated from the results of running each element of the collection
     * through a callback. The given `setter` function sets the keys and values
     * of the composed object.
     *
     * @private
     * @param {Function} setter The setter function.
     * @returns {Function} Returns the new aggregator function.
     */
        function createAggregator(setter) {
            return function(collection, callback, thisArg) {
                var result = {};
                if (callback = lodash.createCallback(callback, thisArg, 3), isArray(collection)) for (var index = -1, length = collection.length; ++index < length; ) {
                    var value = collection[index];
                    setter(result, value, callback(value, index, collection), collection);
                } else baseEach(collection, function(value, key, collection) {
                    setter(result, value, callback(value, key, collection), collection);
                });
                return result;
            };
        }
        /**
     * Creates a function that, when called, either curries or invokes `func`
     * with an optional `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to reference.
     * @param {number} bitmask The bitmask of method flags to compose.
     *  The bitmask may be composed of the following flags:
     *  1 - `_.bind`
     *  2 - `_.bindKey`
     *  4 - `_.curry`
     *  8 - `_.curry` (bound)
     *  16 - `_.partial`
     *  32 - `_.partialRight`
     * @param {Array} [partialArgs] An array of arguments to prepend to those
     *  provided to the new function.
     * @param {Array} [partialRightArgs] An array of arguments to append to those
     *  provided to the new function.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new bound function.
     */
        function createBound(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
            var isBind = 1 & bitmask, isBindKey = 2 & bitmask, isCurry = 4 & bitmask, isCurryBound = 8 & bitmask, isPartial = 16 & bitmask, isPartialRight = 32 & bitmask, key = func;
            if (!isBindKey && !isFunction(func)) throw new TypeError();
            isPartial && !partialArgs.length && (bitmask &= -17, isPartial = partialArgs = !1), 
            isPartialRight && !partialRightArgs.length && (bitmask &= -33, isPartialRight = partialRightArgs = !1);
            var bindData = func && func.__bindData__;
            if (bindData) return !isBind || 1 & bindData[1] || (bindData[4] = thisArg), !isBind && 1 & bindData[1] && (bitmask |= 8), 
            !isCurry || 4 & bindData[1] || (bindData[5] = arity), isPartial && push.apply(bindData[2] || (bindData[2] = []), partialArgs), 
            isPartialRight && push.apply(bindData[3] || (bindData[3] = []), partialRightArgs), 
            bindData[1] |= bitmask, createBound.apply(null, bindData);
            // use `Function#bind` if it exists and is fast
            // (in V8 `Function#bind` is slower except when partially applied)
            if (isBind && !(isBindKey || isCurry || isPartialRight) && (support.fastBind || nativeBind && isPartial)) {
                if (isPartial) {
                    var args = [ thisArg ];
                    push.apply(args, partialArgs);
                }
                var bound = isPartial ? nativeBind.apply(func, args) : nativeBind.call(func, thisArg);
            } else bound = function() {
                // `Function#bind` spec
                // http://es5.github.io/#x15.3.4.5
                var args = arguments, thisBinding = isBind ? thisArg : this;
                if ((isCurry || isPartial || isPartialRight) && (args = nativeSlice.call(args), 
                isPartial && unshift.apply(args, partialArgs), isPartialRight && push.apply(args, partialRightArgs), 
                isCurry && args.length < arity)) return bitmask |= 16, createBound(func, isCurryBound ? bitmask : -4 & bitmask, args, null, thisArg, arity);
                if (isBindKey && (func = thisBinding[key]), this instanceof bound) {
                    // ensure `new bound` is an instance of `func`
                    thisBinding = createObject(func.prototype);
                    // mimic the constructor's `return` behavior
                    // http://es5.github.io/#x13.2.2
                    var result = func.apply(thisBinding, args);
                    return isObject(result) ? result : thisBinding;
                }
                return func.apply(thisBinding, args);
            };
            return setBindData(bound, nativeSlice.call(arguments)), bound;
        }
        /**
     * Creates compiled iteration functions.
     *
     * @private
     * @param {...Object} [options] The compile options object(s).
     * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
     * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
     * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
     * @param {string} [options.args] A comma separated string of iteration function arguments.
     * @param {string} [options.top] Code to execute before the iteration branches.
     * @param {string} [options.loop] Code to execute in the object loop.
     * @param {string} [options.bottom] Code to execute after the iteration branches.
     * @returns {Function} Returns the compiled function.
     */
        function createIterator() {
            var data = getObject();
            // data properties
            data.shadowedProps = shadowedProps, // iterator options
            data.array = data.bottom = data.loop = data.top = "", data.init = "iterable", data.useHas = !0;
            // merge options into a template data object
            for (var object, index = 0; object = arguments[index]; index++) for (var key in object) data[key] = object[key];
            var args = data.args;
            data.firstArg = /^[^,]+/.exec(args)[0];
            // create the function factory
            var factory = Function("baseCreateCallback, errorClass, errorProto, hasOwnProperty, indicatorObject, isArguments, isArray, isString, keys, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString", "return function(" + args + ") {\n" + iteratorTemplate(data) + "\n}");
            // return the compiled function
            return releaseObject(data), factory(baseCreateCallback, errorClass, errorProto, hasOwnProperty, indicatorObject, isArguments, isArray, isString, data.keys, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString);
        }
        /**
     * Creates a new object with the specified `prototype`.
     *
     * @private
     * @param {Object} prototype The prototype object.
     * @returns {Object} Returns the new object.
     */
        function createObject(prototype) {
            return isObject(prototype) ? nativeCreate(prototype) : {};
        }
        /**
     * Used by `escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} match The matched character to escape.
     * @returns {string} Returns the escaped character.
     */
        function escapeHtmlChar(match) {
            return htmlEscapes[match];
        }
        /**
     * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
     * customized, this method returns the custom method, otherwise it returns
     * the `baseIndexOf` function.
     *
     * @private
     * @returns {Function} Returns the "indexOf" function.
     */
        function getIndexOf() {
            var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
            return result;
        }
        /**
     * A fallback implementation of `isPlainObject` which checks if a given value
     * is an object created by the `Object` constructor, assuming objects created
     * by the `Object` constructor have no inherited enumerable properties and that
     * there are no `Object.prototype` extensions.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     */
        function shimIsPlainObject(value) {
            var ctor, result;
            // avoid non Object objects, `arguments` objects, and DOM elements
            // avoid non Object objects, `arguments` objects, and DOM elements
            // IE < 9 iterates inherited properties before own properties. If the first
            // iterated property is an object's own property then there are no inherited
            // enumerable properties.
            // In most environments an object's own properties are iterated before
            // its inherited properties. If the last iterated property is an object's
            // own property then there are no inherited enumerable properties.
            return !value || toString.call(value) != objectClass || (ctor = value.constructor, 
            isFunction(ctor) && !(ctor instanceof ctor)) || !support.argsClass && isArguments(value) || !support.nodeClass && isNode(value) ? !1 : support.ownLast ? (forIn(value, function(value, key, object) {
                return result = hasOwnProperty.call(object, key), !1;
            }), result !== !1) : (forIn(value, function(value, key) {
                result = key;
            }), "undefined" == typeof result || hasOwnProperty.call(value, result));
        }
        /**
     * Used by `unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} match The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */
        function unescapeHtmlChar(match) {
            return htmlUnescapes[match];
        }
        /*--------------------------------------------------------------------------*/
        /**
     * Checks if `value` is an `arguments` object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
     * @example
     *
     * (function() { return _.isArguments(arguments); })(1, 2, 3);
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
        function isArguments(value) {
            return value && "object" == typeof value && "number" == typeof value.length && toString.call(value) == argsClass || !1;
        }
        /**
     * Creates a clone of `value`. If `deep` is `true` nested objects will also
     * be cloned, otherwise they will be assigned by reference. If a callback
     * is provided it will be executed to produce the cloned values. If the
     * callback returns `undefined` cloning will be handled by the method instead.
     * The callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to clone.
     * @param {boolean} [deep=false] Specify a deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the cloned `value`.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * var shallow = _.clone(stooges);
     * shallow[0] === stooges[0];
     * // => true
     *
     * var deep = _.clone(stooges, true);
     * deep[0] === stooges[0];
     * // => false
     *
     * _.mixin({
     *   'clone': _.partialRight(_.clone, function(value) {
     *     return _.isElement(value) ? value.cloneNode(false) : undefined;
     *   })
     * });
     *
     * var clone = _.clone(document.body);
     * clone.childNodes.length;
     * // => 0
     */
        function clone(value, deep, callback, thisArg) {
            // allows working with "Collections" methods without using their `index`
            // and `collection` arguments for `deep` and `callback`
            return "boolean" != typeof deep && null != deep && (thisArg = callback, callback = deep, 
            deep = !1), baseClone(value, deep, "function" == typeof callback && baseCreateCallback(callback, thisArg, 1));
        }
        /**
     * Creates a deep clone of `value`. If a callback is provided it will be
     * executed to produce the cloned values. If the callback returns `undefined`
     * cloning will be handled by the method instead. The callback is bound to
     * `thisArg` and invoked with one argument; (value).
     *
     * Note: This method is loosely based on the structured clone algorithm. Functions
     * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
     * objects created by constructors other than `Object` are cloned to plain `Object` objects.
     * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to deep clone.
     * @param {Function} [callback] The function to customize cloning values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the deep cloned `value`.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * var deep = _.cloneDeep(stooges);
     * deep[0] === stooges[0];
     * // => false
     *
     * var view = {
     *   'label': 'docs',
     *   'node': element
     * };
     *
     * var clone = _.cloneDeep(view, function(value) {
     *   return _.isElement(value) ? value.cloneNode(true) : undefined;
     * });
     *
     * clone.node == view.node;
     * // => false
     */
        function cloneDeep(value, callback, thisArg) {
            return baseClone(value, !0, "function" == typeof callback && baseCreateCallback(callback, thisArg, 1));
        }
        /**
     * This method is like `_.findIndex` except that it returns the key of the
     * first element that passes the callback check, instead of the element itself.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * _.findKey({ 'a': 1, 'b': 2, 'c': 3, 'd': 4 }, function(num) {
     *   return num % 2 == 0;
     * });
     * // => 'b' (property order is not guaranteed across environments)
     */
        function findKey(object, callback, thisArg) {
            var result;
            return callback = lodash.createCallback(callback, thisArg, 3), forOwn(object, function(value, key, object) {
                return callback(value, key, object) ? (result = key, !1) : void 0;
            }), result;
        }
        /**
     * This method is like `_.findKey` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to search.
     * @param {Function|Object|string} [callback=identity] The function called per
     *  iteration. If a property name or object is provided it will be used to
     *  create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {string|undefined} Returns the key of the found element, else `undefined`.
     * @example
     *
     * _.findLastKey({ 'a': 1, 'b': 2, 'c': 3, 'd': 4 }, function(num) {
     *   return num % 2 == 1;
     * });
     * // => returns `c`, assuming `_.findKey` returns `a`
     */
        function findLastKey(object, callback, thisArg) {
            var result;
            return callback = lodash.createCallback(callback, thisArg, 3), forOwnRight(object, function(value, key, object) {
                return callback(value, key, object) ? (result = key, !1) : void 0;
            }), result;
        }
        /**
     * This method is like `_.forIn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function Dog(name) {
     *   this.name = name;
     * }
     *
     * Dog.prototype.bark = function() {
     *   console.log('Woof, woof!');
     * };
     *
     * _.forInRight(new Dog('Dagny'), function(value, key) {
     *   console.log(key);
     * });
     * // => logs 'name' and 'bark' assuming `_.forIn ` logs 'bark' and 'name'
     */
        function forInRight(object, callback, thisArg) {
            var pairs = [];
            forIn(object, function(value, key) {
                pairs.push(key, value);
            });
            var length = pairs.length;
            for (callback = baseCreateCallback(callback, thisArg, 3); length-- && callback(pairs[length--], pairs[length], object) !== !1; ) ;
            return object;
        }
        /**
     * This method is like `_.forOwn` except that it iterates over elements
     * of a `collection` in the opposite order.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns `object`.
     * @example
     *
     * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
     *   console.log(key);
     * });
     * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
     */
        function forOwnRight(object, callback, thisArg) {
            var props = keys(object), length = props.length;
            for (callback = baseCreateCallback(callback, thisArg, 3); length--; ) {
                var key = props[length];
                if (callback(object[key], key, object) === !1) break;
            }
            return object;
        }
        /**
     * Creates a sorted array of property names of all enumerable properties,
     * own and inherited, of `object` that have function values.
     *
     * @static
     * @memberOf _
     * @alias methods
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property names that have function values.
     * @example
     *
     * _.functions(_);
     * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
     */
        function functions(object) {
            var result = [];
            return forIn(object, function(value, key) {
                isFunction(value) && result.push(key);
            }), result.sort();
        }
        /**
     * Checks if the specified object `property` exists and is a direct property,
     * instead of an inherited property.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to check.
     * @param {string} property The property to check for.
     * @returns {boolean} Returns `true` if key is a direct property, else `false`.
     * @example
     *
     * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
     * // => true
     */
        function has(object, property) {
            return object ? hasOwnProperty.call(object, property) : !1;
        }
        /**
     * Creates an object composed of the inverted keys and values of the given object.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the created inverted object.
     * @example
     *
     *  _.invert({ 'first': 'moe', 'second': 'larry' });
     * // => { 'moe': 'first', 'larry': 'second' }
     */
        function invert(object) {
            for (var index = -1, props = keys(object), length = props.length, result = {}; ++index < length; ) {
                var key = props[index];
                result[object[key]] = key;
            }
            return result;
        }
        /**
     * Checks if `value` is a boolean value.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
     * @example
     *
     * _.isBoolean(null);
     * // => false
     */
        function isBoolean(value) {
            return value === !0 || value === !1 || toString.call(value) == boolClass;
        }
        /**
     * Checks if `value` is a date.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     */
        function isDate(value) {
            return value ? "object" == typeof value && toString.call(value) == dateClass : !1;
        }
        /**
     * Checks if `value` is a DOM element.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     */
        function isElement(value) {
            return value ? 1 === value.nodeType : !1;
        }
        /**
     * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
     * length of `0` and objects with no own enumerable properties are considered
     * "empty".
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object|string} value The value to inspect.
     * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({});
     * // => true
     *
     * _.isEmpty('');
     * // => true
     */
        function isEmpty(value) {
            var result = !0;
            if (!value) return result;
            var className = toString.call(value), length = value.length;
            return className == arrayClass || className == stringClass || (support.argsClass ? className == argsClass : isArguments(value)) || className == objectClass && "number" == typeof length && isFunction(value.splice) ? !length : (forOwn(value, function() {
                return result = !1;
            }), result);
        }
        /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent to each other. If a callback is provided it will be executed
     * to compare values. If the callback returns `undefined` comparisons will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (a, b).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} a The value to compare.
     * @param {*} b The other value to compare.
     * @param {Function} [callback] The function to customize comparing values.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var moe = { 'name': 'moe', 'age': 40 };
     * var copy = { 'name': 'moe', 'age': 40 };
     *
     * moe == copy;
     * // => false
     *
     * _.isEqual(moe, copy);
     * // => true
     *
     * var words = ['hello', 'goodbye'];
     * var otherWords = ['hi', 'goodbye'];
     *
     * _.isEqual(words, otherWords, function(a, b) {
     *   var reGreet = /^(?:hello|hi)$/i,
     *       aGreet = _.isString(a) && reGreet.test(a),
     *       bGreet = _.isString(b) && reGreet.test(b);
     *
     *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
     * });
     * // => true
     */
        function isEqual(a, b, callback, thisArg) {
            return baseIsEqual(a, b, "function" == typeof callback && baseCreateCallback(callback, thisArg, 2));
        }
        /**
     * Checks if `value` is, or can be coerced to, a finite number.
     *
     * Note: This is not the same as native `isFinite` which will return true for
     * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
     * @example
     *
     * _.isFinite(-101);
     * // => true
     *
     * _.isFinite('10');
     * // => true
     *
     * _.isFinite(true);
     * // => false
     *
     * _.isFinite('');
     * // => false
     *
     * _.isFinite(Infinity);
     * // => false
     */
        function isFinite(value) {
            return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
        }
        /**
     * Checks if `value` is a function.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     */
        function isFunction(value) {
            return "function" == typeof value;
        }
        /**
     * Checks if `value` is the language type of Object.
     * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(1);
     * // => false
     */
        function isObject(value) {
            // check if the value is the ECMAScript language type of Object
            // http://es5.github.io/#x8
            // and avoid a V8 bug
            // http://code.google.com/p/v8/issues/detail?id=2291
            return !(!value || !objectTypes[typeof value]);
        }
        /**
     * Checks if `value` is `NaN`.
     *
     * Note: This is not the same as native `isNaN` which will return `true` for
     * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
        function isNaN(value) {
            // `NaN` as a primitive is the only value that is not equal to itself
            // (perform the [[Class]] check first to avoid errors with some host objects in IE)
            return isNumber(value) && value != +value;
        }
        /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(undefined);
     * // => false
     */
        function isNull(value) {
            return null === value;
        }
        /**
     * Checks if `value` is a number.
     *
     * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(8.4 * 5);
     * // => true
     */
        function isNumber(value) {
            return "number" == typeof value || toString.call(value) == numberClass;
        }
        /**
     * Checks if `value` is a regular expression.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
     * @example
     *
     * _.isRegExp(/moe/);
     * // => true
     */
        function isRegExp(value) {
            return value && objectTypes[typeof value] ? toString.call(value) == regexpClass : !1;
        }
        /**
     * Checks if `value` is a string.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
     * @example
     *
     * _.isString('moe');
     * // => true
     */
        function isString(value) {
            return "string" == typeof value || toString.call(value) == stringClass;
        }
        /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     */
        function isUndefined(value) {
            return "undefined" == typeof value;
        }
        /**
     * Recursively merges own enumerable properties of the source object(s), that
     * don't resolve to `undefined` into the destination object. Subsequent sources
     * will overwrite property assignments of previous sources. If a callback is
     * provided it will be executed to produce the merged values of the destination
     * and source properties. If the callback returns `undefined` merging will
     * be handled by the method instead. The callback is bound to `thisArg` and
     * invoked with two arguments; (objectValue, sourceValue).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The destination object.
     * @param {...Object} [source] The source objects.
     * @param {Function} [callback] The function to customize merging properties.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns the destination object.
     * @example
     *
     * var names = {
     *   'stooges': [
     *     { 'name': 'moe' },
     *     { 'name': 'larry' }
     *   ]
     * };
     *
     * var ages = {
     *   'stooges': [
     *     { 'age': 40 },
     *     { 'age': 50 }
     *   ]
     * };
     *
     * _.merge(names, ages);
     * // => { 'stooges': [{ 'name': 'moe', 'age': 40 }, { 'name': 'larry', 'age': 50 }] }
     *
     * var food = {
     *   'fruits': ['apple'],
     *   'vegetables': ['beet']
     * };
     *
     * var otherFood = {
     *   'fruits': ['banana'],
     *   'vegetables': ['carrot']
     * };
     *
     * _.merge(food, otherFood, function(a, b) {
     *   return _.isArray(a) ? a.concat(b) : undefined;
     * });
     * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
     */
        function merge(object) {
            var args = arguments, length = 2;
            if (!isObject(object)) return object;
            if (// allows working with `_.reduce` and `_.reduceRight` without using
            // their `index` and `collection` arguments
            "number" != typeof args[2] && (length = args.length), length > 3 && "function" == typeof args[length - 2]) var callback = baseCreateCallback(args[--length - 1], args[length--], 2); else length > 2 && "function" == typeof args[length - 1] && (callback = args[--length]);
            for (var sources = nativeSlice.call(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray(); ++index < length; ) baseMerge(object, sources[index], callback, stackA, stackB);
            return releaseArray(stackA), releaseArray(stackB), object;
        }
        /**
     * Creates a shallow clone of `object` excluding the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` omitting the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The properties to omit or the
     *  function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object without the omitted properties.
     * @example
     *
     * _.omit({ 'name': 'moe', 'age': 40 }, 'age');
     * // => { 'name': 'moe' }
     *
     * _.omit({ 'name': 'moe', 'age': 40 }, function(value) {
     *   return typeof value == 'number';
     * });
     * // => { 'name': 'moe' }
     */
        function omit(object, callback, thisArg) {
            var indexOf = getIndexOf(), isFunc = "function" == typeof callback, result = {};
            if (isFunc) callback = lodash.createCallback(callback, thisArg, 3); else var props = baseFlatten(arguments, !0, !1, 1);
            return forIn(object, function(value, key, object) {
                (isFunc ? !callback(value, key, object) : indexOf(props, key) < 0) && (result[key] = value);
            }), result;
        }
        /**
     * Creates a two dimensional array of an object's key-value pairs,
     * i.e. `[[key1, value1], [key2, value2]]`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns new array of key-value pairs.
     * @example
     *
     * _.pairs({ 'moe': 30, 'larry': 40 });
     * // => [['moe', 30], ['larry', 40]] (property order is not guaranteed across environments)
     */
        function pairs(object) {
            for (var index = -1, props = keys(object), length = props.length, result = Array(length); ++index < length; ) {
                var key = props[index];
                result[index] = [ key, object[key] ];
            }
            return result;
        }
        /**
     * Creates a shallow clone of `object` composed of the specified properties.
     * Property names may be specified as individual arguments or as arrays of
     * property names. If a callback is provided it will be executed for each
     * property of `object` picking the properties the callback returns truey
     * for. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The source object.
     * @param {Function|...string|string[]} [callback] The function called per
     *  iteration or property names to pick, specified as individual property
     *  names or arrays of property names.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Object} Returns an object composed of the picked properties.
     * @example
     *
     * _.pick({ 'name': 'moe', '_userid': 'moe1' }, 'name');
     * // => { 'name': 'moe' }
     *
     * _.pick({ 'name': 'moe', '_userid': 'moe1' }, function(value, key) {
     *   return key.charAt(0) != '_';
     * });
     * // => { 'name': 'moe' }
     */
        function pick(object, callback, thisArg) {
            var result = {};
            if ("function" != typeof callback) for (var index = -1, props = baseFlatten(arguments, !0, !1, 1), length = isObject(object) ? props.length : 0; ++index < length; ) {
                var key = props[index];
                key in object && (result[key] = object[key]);
            } else callback = lodash.createCallback(callback, thisArg, 3), forIn(object, function(value, key, object) {
                callback(value, key, object) && (result[key] = value);
            });
            return result;
        }
        /**
     * An alternative to `_.reduce` this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its elements
     * through a callback, with each callback execution potentially mutating
     * the `accumulator` object. The callback is bound to `thisArg` and invoked
     * with four arguments; (accumulator, value, key, object). Callbacks may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
     *   num *= num;
     *   if (num % 2) {
     *     return result.push(num) < 3;
     *   }
     * });
     * // => [1, 9, 25]
     *
     * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     * });
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
        function transform(object, callback, accumulator, thisArg) {
            var isArr = isArray(object);
            if (callback = baseCreateCallback(callback, thisArg, 4), null == accumulator) if (isArr) accumulator = []; else {
                var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                accumulator = createObject(proto);
            }
            return (isArr ? baseEach : forOwn)(object, function(value, index, object) {
                return callback(accumulator, value, index, object);
            }), accumulator;
        }
        /**
     * Creates an array composed of the own enumerable property values of `object`.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns an array of property values.
     * @example
     *
     * _.values({ 'one': 1, 'two': 2, 'three': 3 });
     * // => [1, 2, 3] (property order is not guaranteed across environments)
     */
        function values(object) {
            for (var index = -1, props = keys(object), length = props.length, result = Array(length); ++index < length; ) result[index] = object[props[index]];
            return result;
        }
        /*--------------------------------------------------------------------------*/
        /**
     * Creates an array of elements from the specified indexes, or keys, of the
     * `collection`. Indexes may be specified as individual arguments or as arrays
     * of indexes.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
     *   to retrieve, specified as individual indexes or arrays of indexes.
     * @returns {Array} Returns a new array of elements corresponding to the
     *  provided indexes.
     * @example
     *
     * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
     * // => ['a', 'c', 'e']
     *
     * _.at(['moe', 'larry', 'curly'], 0, 2);
     * // => ['moe', 'curly']
     */
        function at(collection) {
            var args = arguments, index = -1, props = baseFlatten(args, !0, !1, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
            for (support.unindexedChars && isString(collection) && (collection = collection.split("")); ++index < length; ) result[index] = collection[props[index]];
            return result;
        }
        /**
     * Checks if a given value is present in a collection using strict equality
     * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
     * offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @alias include
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {*} target The value to check for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
     * @example
     *
     * _.contains([1, 2, 3], 1);
     * // => true
     *
     * _.contains([1, 2, 3], 1, 2);
     * // => false
     *
     * _.contains({ 'name': 'moe', 'age': 40 }, 'moe');
     * // => true
     *
     * _.contains('curly', 'ur');
     * // => true
     */
        function contains(collection, target, fromIndex) {
            var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = !1;
            return fromIndex = (0 > fromIndex ? nativeMax(0, length + fromIndex) : fromIndex) || 0, 
            isArray(collection) ? result = indexOf(collection, target, fromIndex) > -1 : "number" == typeof length ? result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1 : baseEach(collection, function(value) {
                return ++index >= fromIndex ? !(result = value === target) : void 0;
            }), result;
        }
        /**
     * Checks if the given callback returns truey value for **all** elements of
     * a collection. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias all
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if all elements passed the callback check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.every(stooges, 'age');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.every(stooges, { 'age': 50 });
     * // => false
     */
        function every(collection, callback, thisArg) {
            var result = !0;
            if (callback = lodash.createCallback(callback, thisArg, 3), isArray(collection)) for (var index = -1, length = collection.length; ++index < length && (result = !!callback(collection[index], index, collection)); ) ; else baseEach(collection, function(value, index, collection) {
                return result = !!callback(value, index, collection);
            });
            return result;
        }
        /**
     * Iterates over elements of a collection, returning an array of all elements
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias select
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that passed the callback check.
     * @example
     *
     * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [2, 4, 6]
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.filter(food, 'organic');
     * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]
     *
     * // using "_.where" callback shorthand
     * _.filter(food, { 'type': 'fruit' });
     * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]
     */
        function filter(collection, callback, thisArg) {
            var result = [];
            if (callback = lodash.createCallback(callback, thisArg, 3), isArray(collection)) for (var index = -1, length = collection.length; ++index < length; ) {
                var value = collection[index];
                callback(value, index, collection) && result.push(value);
            } else baseEach(collection, function(value, index, collection) {
                callback(value, index, collection) && result.push(value);
            });
            return result;
        }
        /**
     * Iterates over elements of a collection, returning the first element that
     * the callback returns truey for. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias detect, findWhere
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.find([1, 2, 3, 4], function(num) {
     *   return num % 2 == 0;
     * });
     * // => 2
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'banana', 'organic': true,  'type': 'fruit' },
     *   { 'name': 'beet',   'organic': false, 'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.find(food, { 'type': 'vegetable' });
     * // => { 'name': 'beet', 'organic': false, 'type': 'vegetable' }
     *
     * // using "_.pluck" callback shorthand
     * _.find(food, 'organic');
     * // => { 'name': 'banana', 'organic': true, 'type': 'fruit' }
     */
        function find(collection, callback, thisArg) {
            if (callback = lodash.createCallback(callback, thisArg, 3), !isArray(collection)) {
                var result;
                return baseEach(collection, function(value, index, collection) {
                    return callback(value, index, collection) ? (result = value, !1) : void 0;
                }), result;
            }
            for (var index = -1, length = collection.length; ++index < length; ) {
                var value = collection[index];
                if (callback(value, index, collection)) return value;
            }
        }
        /**
     * This method is like `_.find` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the found element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(num) {
     *   return num % 2 == 1;
     * });
     * // => 3
     */
        function findLast(collection, callback, thisArg) {
            var result;
            return callback = lodash.createCallback(callback, thisArg, 3), forEachRight(collection, function(value, index, collection) {
                return callback(value, index, collection) ? (result = value, !1) : void 0;
            }), result;
        }
        /**
     * Iterates over elements of a collection, executing the callback for each
     * element. The callback is bound to `thisArg` and invoked with three arguments;
     * (value, index|key, collection). Callbacks may exit iteration early by
     * explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @alias each
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
     * // => logs each number and returns '1,2,3'
     *
     * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
     * // => logs each number and returns the object (property order is not guaranteed across environments)
     */
        function forEach(collection, callback, thisArg) {
            if (callback && "undefined" == typeof thisArg && isArray(collection)) for (var index = -1, length = collection.length; ++index < length && callback(collection[index], index, collection) !== !1; ) ; else baseEach(collection, callback, thisArg);
            return collection;
        }
        /**
     * This method is like `_.forEach` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias eachRight
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array|Object|string} Returns `collection`.
     * @example
     *
     * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
     * // => logs each number from right to left and returns '3,2,1'
     */
        function forEachRight(collection, callback, thisArg) {
            var iterable = collection, length = collection ? collection.length : 0;
            if (callback = callback && "undefined" == typeof thisArg ? callback : baseCreateCallback(callback, thisArg, 3), 
            isArray(collection)) for (;length-- && callback(collection[length], length, collection) !== !1; ) ; else {
                if ("number" != typeof length) {
                    var props = keys(collection);
                    length = props.length;
                } else support.unindexedChars && isString(collection) && (iterable = collection.split(""));
                baseEach(collection, function(value, key, collection) {
                    return key = props ? props[--length] : --length, callback(iterable[key], key, collection);
                });
            }
            return collection;
        }
        /**
     * Invokes the method named by `methodName` on each element in the `collection`
     * returning an array of the results of each invoked method. Additional arguments
     * will be provided to each invoked method. If `methodName` is a function it
     * will be invoked for, and `this` bound to, each element in the `collection`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|string} methodName The name of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [arg] Arguments to invoke the method with.
     * @returns {Array} Returns a new array of the results of each invoked method.
     * @example
     *
     * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invoke([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
        function invoke(collection, methodName) {
            var args = nativeSlice.call(arguments, 2), index = -1, isFunc = "function" == typeof methodName, length = collection ? collection.length : 0, result = Array("number" == typeof length ? length : 0);
            return forEach(collection, function(value) {
                result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
            }), result;
        }
        /**
     * Creates an array of values by running each element in the collection
     * through the callback. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias collect
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of the results of each `callback` execution.
     * @example
     *
     * _.map([1, 2, 3], function(num) { return num * 3; });
     * // => [3, 6, 9]
     *
     * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
     * // => [3, 6, 9] (property order is not guaranteed across environments)
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.map(stooges, 'name');
     * // => ['moe', 'larry']
     */
        function map(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0, result = Array("number" == typeof length ? length : 0);
            if (callback = lodash.createCallback(callback, thisArg, 3), isArray(collection)) for (;++index < length; ) result[index] = callback(collection[index], index, collection); else baseEach(collection, function(value, key, collection) {
                result[++index] = callback(value, key, collection);
            });
            return result;
        }
        /**
     * Retrieves the maximum value of a collection. If the collection is empty or
     * falsey `-Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * _.max(stooges, function(stooge) { return stooge.age; });
     * // => { 'name': 'larry', 'age': 50 };
     *
     * // using "_.pluck" callback shorthand
     * _.max(stooges, 'age');
     * // => { 'name': 'larry', 'age': 50 };
     */
        function max(collection, callback, thisArg) {
            var computed = -1/0, result = computed;
            if (!callback && isArray(collection)) for (var index = -1, length = collection.length; ++index < length; ) {
                var value = collection[index];
                value > result && (result = value);
            } else callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3), 
            baseEach(collection, function(value, index, collection) {
                var current = callback(value, index, collection);
                current > computed && (computed = current, result = value);
            });
            return result;
        }
        /**
     * Retrieves the minimum value of a collection. If the collection is empty or
     * falsey `Infinity` is returned. If a callback is provided it will be executed
     * for each value in the collection to generate the criterion by which the value
     * is ranked. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * _.min(stooges, function(stooge) { return stooge.age; });
     * // => { 'name': 'moe', 'age': 40 };
     *
     * // using "_.pluck" callback shorthand
     * _.min(stooges, 'age');
     * // => { 'name': 'moe', 'age': 40 };
     */
        function min(collection, callback, thisArg) {
            var computed = 1/0, result = computed;
            if (!callback && isArray(collection)) for (var index = -1, length = collection.length; ++index < length; ) {
                var value = collection[index];
                result > value && (result = value);
            } else callback = !callback && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3), 
            baseEach(collection, function(value, index, collection) {
                var current = callback(value, index, collection);
                computed > current && (computed = current, result = value);
            });
            return result;
        }
        /**
     * Reduces a collection to a value which is the accumulated result of running
     * each element in the collection through the callback, where each successive
     * callback execution consumes the return value of the previous execution. If
     * `accumulator` is not provided the first element of the collection will be
     * used as the initial `accumulator` value. The callback is bound to `thisArg`
     * and invoked with four arguments; (accumulator, value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @alias foldl, inject
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var sum = _.reduce([1, 2, 3], function(sum, num) {
     *   return sum + num;
     * });
     * // => 6
     *
     * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
     *   result[key] = num * 3;
     *   return result;
     * }, {});
     * // => { 'a': 3, 'b': 6, 'c': 9 }
     */
        function reduce(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            if (callback = baseCreateCallback(callback, thisArg, 4), isArray(collection)) {
                var index = -1, length = collection.length;
                for (noaccum && (accumulator = collection[++index]); ++index < length; ) accumulator = callback(accumulator, collection[index], index, collection);
            } else baseEach(collection, function(value, index, collection) {
                accumulator = noaccum ? (noaccum = !1, value) : callback(accumulator, value, index, collection);
            });
            return accumulator;
        }
        /**
     * This method is like `_.reduce` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @alias foldr
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function} [callback=identity] The function called per iteration.
     * @param {*} [accumulator] Initial value of the accumulator.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * var list = [[0, 1], [2, 3], [4, 5]];
     * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
        function reduceRight(collection, callback, accumulator, thisArg) {
            var noaccum = arguments.length < 3;
            return callback = baseCreateCallback(callback, thisArg, 4), forEachRight(collection, function(value, index, collection) {
                accumulator = noaccum ? (noaccum = !1, value) : callback(accumulator, value, index, collection);
            }), accumulator;
        }
        /**
     * The opposite of `_.filter` this method returns the elements of a
     * collection that the callback does **not** return truey for.
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of elements that failed the callback check.
     * @example
     *
     * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
     * // => [1, 3, 5]
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.reject(food, 'organic');
     * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]
     *
     * // using "_.where" callback shorthand
     * _.reject(food, { 'type': 'fruit' });
     * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]
     */
        function reject(collection, callback, thisArg) {
            return callback = lodash.createCallback(callback, thisArg, 3), filter(collection, function(value, index, collection) {
                return !callback(value, index, collection);
            });
        }
        /**
     * Retrieves a random element or `n` random elements from a collection.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to sample.
     * @param {number} [n] The number of elements to sample.
     * @param- {Object} [guard] Allows working with functions, like `_.map`,
     *  without using their `key` and `object` arguments as sources.
     * @returns {Array} Returns the random sample(s) of `collection`.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     *
     * _.sample([1, 2, 3, 4], 2);
     * // => [3, 1]
     */
        function sample(collection, n, guard) {
            var length = collection ? collection.length : 0;
            if ("number" != typeof length ? collection = values(collection) : support.unindexedChars && isString(collection) && (collection = collection.split("")), 
            null == n || guard) return collection ? collection[random(length - 1)] : undefined;
            var result = shuffle(collection);
            return result.length = nativeMin(nativeMax(0, n), result.length), result;
        }
        /**
     * Creates an array of shuffled values, using a version of the Fisher-Yates
     * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to shuffle.
     * @returns {Array} Returns a new shuffled collection.
     * @example
     *
     * _.shuffle([1, 2, 3, 4, 5, 6]);
     * // => [4, 1, 6, 3, 5, 2]
     */
        function shuffle(collection) {
            var index = -1, length = collection ? collection.length : 0, result = Array("number" == typeof length ? length : 0);
            return forEach(collection, function(value) {
                var rand = random(++index);
                result[index] = result[rand], result[rand] = value;
            }), result;
        }
        /**
     * Gets the size of the `collection` by returning `collection.length` for arrays
     * and array-like objects or the number of own enumerable properties for objects.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns `collection.length` or number of own enumerable properties.
     * @example
     *
     * _.size([1, 2]);
     * // => 2
     *
     * _.size({ 'one': 1, 'two': 2, 'three': 3 });
     * // => 3
     *
     * _.size('curly');
     * // => 5
     */
        function size(collection) {
            var length = collection ? collection.length : 0;
            return "number" == typeof length ? length : keys(collection).length;
        }
        /**
     * Checks if the callback returns a truey value for **any** element of a
     * collection. The function returns as soon as it finds a passing value and
     * does not iterate over the entire collection. The callback is bound to
     * `thisArg` and invoked with three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias any
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {boolean} Returns `true` if any element passed the callback check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var food = [
     *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
     *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.some(food, 'organic');
     * // => true
     *
     * // using "_.where" callback shorthand
     * _.some(food, { 'type': 'meat' });
     * // => false
     */
        function some(collection, callback, thisArg) {
            var result;
            if (callback = lodash.createCallback(callback, thisArg, 3), isArray(collection)) for (var index = -1, length = collection.length; ++index < length && !(result = callback(collection[index], index, collection)); ) ; else baseEach(collection, function(value, index, collection) {
                return !(result = callback(value, index, collection));
            });
            return !!result;
        }
        /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection through the callback. This method
     * performs a stable sort, that is, it will preserve the original sort order
     * of equal elements. The callback is bound to `thisArg` and invoked with
     * three arguments; (value, index|key, collection).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to iterate over.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of sorted elements.
     * @example
     *
     * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
     * // => [3, 1, 2]
     *
     * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
     * // => [3, 1, 2]
     *
     * // using "_.pluck" callback shorthand
     * _.sortBy(['banana', 'strawberry', 'apple'], 'length');
     * // => ['apple', 'banana', 'strawberry']
     */
        function sortBy(collection, callback, thisArg) {
            var index = -1, length = collection ? collection.length : 0, result = Array("number" == typeof length ? length : 0);
            for (callback = lodash.createCallback(callback, thisArg, 3), forEach(collection, function(value, key, collection) {
                var object = result[++index] = getObject();
                object.criteria = callback(value, key, collection), object.index = index, object.value = value;
            }), length = result.length, result.sort(compareAscending); length--; ) {
                var object = result[length];
                result[length] = object.value, releaseObject(object);
            }
            return result;
        }
        /**
     * Converts the `collection` to an array.
     *
     * @static
     * @memberOf _
     * @category Collections
     * @param {Array|Object|string} collection The collection to convert.
     * @returns {Array} Returns the new converted array.
     * @example
     *
     * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
     * // => [2, 3, 4]
     */
        function toArray(collection) {
            return collection && "number" == typeof collection.length ? support.unindexedChars && isString(collection) ? collection.split("") : slice(collection) : values(collection);
        }
        /*--------------------------------------------------------------------------*/
        /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are all falsey.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to compact.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
        function compact(array) {
            for (var index = -1, length = array ? array.length : 0, result = []; ++index < length; ) {
                var value = array[index];
                value && result.push(value);
            }
            return result;
        }
        /**
     * Creates an array excluding all values of the provided arrays using strict
     * equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {...Array} [array] The arrays of values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
     * // => [1, 3, 4]
     */
        function difference(array) {
            var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, seen = baseFlatten(arguments, !0, !0, 1), result = [], isLarge = length >= largeArraySize && indexOf === baseIndexOf;
            if (isLarge) {
                var cache = createCache(seen);
                cache ? (indexOf = cacheIndexOf, seen = cache) : isLarge = !1;
            }
            for (;++index < length; ) {
                var value = array[index];
                indexOf(seen, value) < 0 && result.push(value);
            }
            return isLarge && releaseObject(seen), result;
        }
        /**
     * This method is like `_.find` except that it returns the index of the first
     * element that passes the callback check, instead of the element itself.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * _.findIndex(['apple', 'banana', 'beet'], function(food) {
     *   return /^b/.test(food);
     * });
     * // => 1
     */
        function findIndex(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0;
            for (callback = lodash.createCallback(callback, thisArg, 3); ++index < length; ) if (callback(array[index], index, array)) return index;
            return -1;
        }
        /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of a `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * _.findLastIndex(['apple', 'banana', 'beet'], function(food) {
     *   return /^b/.test(food);
     * });
     * // => 2
     */
        function findLastIndex(array, callback, thisArg) {
            var length = array ? array.length : 0;
            for (callback = lodash.createCallback(callback, thisArg, 3); length--; ) if (callback(array[length], length, array)) return length;
            return -1;
        }
        /**
     * Gets the first element or first `n` elements of an array. If a callback
     * is provided elements at the beginning of the array are returned as long
     * as the callback returns truey. The callback is bound to `thisArg` and
     * invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias head, take
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the first element(s) of `array`.
     * @example
     *
     * _.first([1, 2, 3]);
     * // => 1
     *
     * _.first([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.first([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [1, 2]
     *
     * var food = [
     *   { 'name': 'banana', 'organic': true },
     *   { 'name': 'beet',   'organic': false },
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.first(food, 'organic');
     * // => [{ 'name': 'banana', 'organic': true }]
     *
     * var food = [
     *   { 'name': 'apple',  'type': 'fruit' },
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.first(food, { 'type': 'fruit' });
     * // => [{ 'name': 'apple', 'type': 'fruit' }, { 'name': 'banana', 'type': 'fruit' }]
     */
        function first(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if ("number" != typeof callback && null != callback) {
                var index = -1;
                for (callback = lodash.createCallback(callback, thisArg, 3); ++index < length && callback(array[index], index, array); ) n++;
            } else if (n = callback, null == n || thisArg) return array ? array[0] : undefined;
            return slice(array, 0, nativeMin(nativeMax(0, n), length));
        }
        /**
     * Flattens a nested array (the nesting can be to any depth). If `isShallow`
     * is truey, the array will only be flattened a single level. If a callback
     * is provided each element of the array is passed through the callback before
     * flattening. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to flatten.
     * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new flattened array.
     * @example
     *
     * _.flatten([1, [2], [3, [[4]]]]);
     * // => [1, 2, 3, 4];
     *
     * _.flatten([1, [2], [3, [[4]]]], true);
     * // => [1, 2, 3, [[4]]];
     *
     * var stooges = [
     *   { 'name': 'curly', 'quotes': ['Oh, a wise guy, eh?', 'Poifect!'] },
     *   { 'name': 'moe', 'quotes': ['Spread out!', 'You knucklehead!'] }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.flatten(stooges, 'quotes');
     * // => ['Oh, a wise guy, eh?', 'Poifect!', 'Spread out!', 'You knucklehead!']
     */
        function flatten(array, isShallow, callback, thisArg) {
            // juggle arguments
            return "boolean" != typeof isShallow && null != isShallow && (thisArg = callback, 
            callback = thisArg && thisArg[isShallow] === array ? null : isShallow, isShallow = !1), 
            null != callback && (array = map(array, callback, thisArg)), baseFlatten(array, isShallow);
        }
        /**
     * Gets the index at which the first occurrence of `value` is found using
     * strict equality for comparisons, i.e. `===`. If the array is already sorted
     * providing `true` for `fromIndex` will run a faster binary search.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {boolean|number} [fromIndex=0] The index to search from or `true`
     *  to perform a binary search on a sorted array.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 1
     *
     * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 4
     *
     * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
     * // => 2
     */
        function indexOf(array, value, fromIndex) {
            if ("number" == typeof fromIndex) {
                var length = array ? array.length : 0;
                fromIndex = 0 > fromIndex ? nativeMax(0, length + fromIndex) : fromIndex || 0;
            } else if (fromIndex) {
                var index = sortedIndex(array, value);
                return array[index] === value ? index : -1;
            }
            return baseIndexOf(array, value, fromIndex);
        }
        /**
     * Gets all but the last element or last `n` elements of an array. If a
     * callback is provided elements at the end of the array are excluded from
     * the result as long as the callback returns truey. The callback is bound
     * to `thisArg` and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     *
     * _.initial([1, 2, 3], 2);
     * // => [1]
     *
     * _.initial([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [1]
     *
     * var food = [
     *   { 'name': 'beet',   'organic': false },
     *   { 'name': 'carrot', 'organic': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.initial(food, 'organic');
     * // => [{ 'name': 'beet',   'organic': false }]
     *
     * var food = [
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' },
     *   { 'name': 'carrot', 'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.initial(food, { 'type': 'vegetable' });
     * // => [{ 'name': 'banana', 'type': 'fruit' }]
     */
        function initial(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if ("number" != typeof callback && null != callback) {
                var index = length;
                for (callback = lodash.createCallback(callback, thisArg, 3); index-- && callback(array[index], index, array); ) n++;
            } else n = null == callback || thisArg ? 1 : callback || n;
            return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
        }
        /**
     * Creates an array of unique values present in all provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of composite values.
     * @example
     *
     * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
     * // => [1, 2]
     */
        function intersection(array) {
            for (var args = arguments, argsLength = args.length, argsIndex = -1, caches = getArray(), index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [], seen = getArray(); ++argsIndex < argsLength; ) {
                var value = args[argsIndex];
                caches[argsIndex] = indexOf === baseIndexOf && (value ? value.length : 0) >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen);
            }
            outer: for (;++index < length; ) {
                var cache = caches[0];
                if (value = array[index], (cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                    for (argsIndex = argsLength, (cache || seen).push(value); --argsIndex; ) if (cache = caches[argsIndex], 
                    (cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) continue outer;
                    result.push(value);
                }
            }
            for (;argsLength--; ) cache = caches[argsLength], cache && releaseObject(cache);
            return releaseArray(caches), releaseArray(seen), result;
        }
        /**
     * Gets the last element or last `n` elements of an array. If a callback is
     * provided elements at the end of the array are returned as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback] The function called
     *  per element or the number of elements to return. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {*} Returns the last element(s) of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     *
     * _.last([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.last([1, 2, 3], function(num) {
     *   return num > 1;
     * });
     * // => [2, 3]
     *
     * var food = [
     *   { 'name': 'beet',   'organic': false },
     *   { 'name': 'carrot', 'organic': true }
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.last(food, 'organic');
     * // => [{ 'name': 'carrot', 'organic': true }]
     *
     * var food = [
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' },
     *   { 'name': 'carrot', 'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.last(food, { 'type': 'vegetable' });
     * // => [{ 'name': 'beet', 'type': 'vegetable' }, { 'name': 'carrot', 'type': 'vegetable' }]
     */
        function last(array, callback, thisArg) {
            var n = 0, length = array ? array.length : 0;
            if ("number" != typeof callback && null != callback) {
                var index = length;
                for (callback = lodash.createCallback(callback, thisArg, 3); index-- && callback(array[index], index, array); ) n++;
            } else if (n = callback, null == n || thisArg) return array ? array[length - 1] : undefined;
            return slice(array, nativeMax(0, length - n));
        }
        /**
     * Gets the index at which the last occurrence of `value` is found using strict
     * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
     * as the offset from the end of the collection.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
     * // => 4
     *
     * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
     * // => 1
     */
        function lastIndexOf(array, value, fromIndex) {
            var index = array ? array.length : 0;
            for ("number" == typeof fromIndex && (index = (0 > fromIndex ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1); index--; ) if (array[index] === value) return index;
            return -1;
        }
        /**
     * Removes all provided values from the given array using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {...*} [value] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3, 1, 2, 3];
     * _.pull(array, 2, 3);
     * console.log(array);
     * // => [1, 1]
     */
        function pull(array) {
            for (var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0; ++argsIndex < argsLength; ) for (var index = -1, value = args[argsIndex]; ++index < length; ) array[index] === value && (splice.call(array, index--, 1), 
            length--);
            return array;
        }
        /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to but not including `end`. If `start` is less than `stop` a
     * zero-length range is created unless a negative `step` is specified.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns a new range array.
     * @example
     *
     * _.range(10);
     * // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     *
     * _.range(1, 11);
     * // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
     *
     * _.range(0, 30, 5);
     * // => [0, 5, 10, 15, 20, 25]
     *
     * _.range(0, -10, -1);
     * // => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
        function range(start, end, step) {
            start = +start || 0, step = "number" == typeof step ? step : +step || 1, null == end && (end = start, 
            start = 0);
            for (// use `Array(length)` so engines, like Chakra and V8, avoid slower modes
            // http://youtu.be/XAqIpGU8ZZk#t=17m25s
            var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length); ++index < length; ) result[index] = start, 
            start += step;
            return result;
        }
        /**
     * Removes all elements from an array that the callback returns truey for
     * and returns an array of removed elements. The callback is bound to `thisArg`
     * and invoked with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to modify.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4, 5, 6];
     * var evens = _.remove(array, function(num) { return num % 2 == 0; });
     *
     * console.log(array);
     * // => [1, 3, 5]
     *
     * console.log(evens);
     * // => [2, 4, 6]
     */
        function remove(array, callback, thisArg) {
            var index = -1, length = array ? array.length : 0, result = [];
            for (callback = lodash.createCallback(callback, thisArg, 3); ++index < length; ) {
                var value = array[index];
                callback(value, index, array) && (result.push(value), splice.call(array, index--, 1), 
                length--);
            }
            return result;
        }
        /**
     * The opposite of `_.initial` this method gets all but the first element or
     * first `n` elements of an array. If a callback function is provided elements
     * at the beginning of the array are excluded from the result as long as the
     * callback returns truey. The callback is bound to `thisArg` and invoked
     * with three arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias drop, tail
     * @category Arrays
     * @param {Array} array The array to query.
     * @param {Function|Object|number|string} [callback=1] The function called
     *  per element or the number of elements to exclude. If a property name or
     *  object is provided it will be used to create a "_.pluck" or "_.where"
     *  style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a slice of `array`.
     * @example
     *
     * _.rest([1, 2, 3]);
     * // => [2, 3]
     *
     * _.rest([1, 2, 3], 2);
     * // => [3]
     *
     * _.rest([1, 2, 3], function(num) {
     *   return num < 3;
     * });
     * // => [3]
     *
     * var food = [
     *   { 'name': 'banana', 'organic': true },
     *   { 'name': 'beet',   'organic': false },
     * ];
     *
     * // using "_.pluck" callback shorthand
     * _.rest(food, 'organic');
     * // => [{ 'name': 'beet', 'organic': false }]
     *
     * var food = [
     *   { 'name': 'apple',  'type': 'fruit' },
     *   { 'name': 'banana', 'type': 'fruit' },
     *   { 'name': 'beet',   'type': 'vegetable' }
     * ];
     *
     * // using "_.where" callback shorthand
     * _.rest(food, { 'type': 'fruit' });
     * // => [{ 'name': 'beet', 'type': 'vegetable' }]
     */
        function rest(array, callback, thisArg) {
            if ("number" != typeof callback && null != callback) {
                var n = 0, index = -1, length = array ? array.length : 0;
                for (callback = lodash.createCallback(callback, thisArg, 3); ++index < length && callback(array[index], index, array); ) n++;
            } else n = null == callback || thisArg ? 1 : nativeMax(0, callback);
            return slice(array, n);
        }
        /**
     * Uses a binary search to determine the smallest index at which a value
     * should be inserted into a given sorted array in order to maintain the sort
     * order of the array. If a callback is provided it will be executed for
     * `value` and each element of `array` to compute their sort ranking. The
     * callback is bound to `thisArg` and invoked with one argument; (value).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([20, 30, 50], 40);
     * // => 2
     *
     * // using "_.pluck" callback shorthand
     * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
     * // => 2
     *
     * var dict = {
     *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
     * };
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return dict.wordToNumber[word];
     * });
     * // => 2
     *
     * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
     *   return this.wordToNumber[word];
     * }, dict);
     * // => 2
     */
        function sortedIndex(array, value, callback, thisArg) {
            var low = 0, high = array ? array.length : low;
            for (// explicitly reference `identity` for better inlining in Firefox
            callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity, value = callback(value); high > low; ) {
                var mid = low + high >>> 1;
                callback(array[mid]) < value ? low = mid + 1 : high = mid;
            }
            return low;
        }
        /**
     * Creates an array of unique values, in order, of the provided arrays using
     * strict equality for comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {...Array} [array] The arrays to inspect.
     * @returns {Array} Returns an array of composite values.
     * @example
     *
     * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
     * // => [1, 2, 3, 101, 10]
     */
        function union() {
            return baseUniq(baseFlatten(arguments, !0, !0));
        }
        /**
     * Creates a duplicate-value-free version of an array using strict equality
     * for comparisons, i.e. `===`. If the array is sorted, providing
     * `true` for `isSorted` will use a faster algorithm. If a callback is provided
     * each element of `array` is passed through the callback before uniqueness
     * is computed. The callback is bound to `thisArg` and invoked with three
     * arguments; (value, index, array).
     *
     * If a property name is provided for `callback` the created "_.pluck" style
     * callback will return the property value of the given element.
     *
     * If an object is provided for `callback` the created "_.where" style callback
     * will return `true` for elements that have the properties of the given object,
     * else `false`.
     *
     * @static
     * @memberOf _
     * @alias unique
     * @category Arrays
     * @param {Array} array The array to process.
     * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
     * @param {Function|Object|string} [callback=identity] The function called
     *  per iteration. If a property name or object is provided it will be used
     *  to create a "_.pluck" or "_.where" style callback, respectively.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns a duplicate-value-free array.
     * @example
     *
     * _.uniq([1, 2, 1, 3, 1]);
     * // => [1, 2, 3]
     *
     * _.uniq([1, 1, 2, 2, 3], true);
     * // => [1, 2, 3]
     *
     * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
     * // => ['A', 'b', 'C']
     *
     * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
     * // => [1, 2.5, 3]
     *
     * // using "_.pluck" callback shorthand
     * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
        function uniq(array, isSorted, callback, thisArg) {
            // juggle arguments
            return "boolean" != typeof isSorted && null != isSorted && (thisArg = callback, 
            callback = thisArg && thisArg[isSorted] === array ? null : isSorted, isSorted = !1), 
            null != callback && (callback = lodash.createCallback(callback, thisArg, 3)), baseUniq(array, isSorted, callback);
        }
        /**
     * Creates an array excluding all provided values using strict equality for
     * comparisons, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @category Arrays
     * @param {Array} array The array to filter.
     * @param {...*} [value] The values to exclude.
     * @returns {Array} Returns a new array of filtered values.
     * @example
     *
     * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
     * // => [2, 3, 4]
     */
        function without(array) {
            return difference(array, nativeSlice.call(arguments, 1));
        }
        /**
     * Creates an array of grouped elements, the first of which contains the first
     * elements of the given arrays, the second of which contains the second
     * elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @alias unzip
     * @category Arrays
     * @param {...Array} [array] Arrays to process.
     * @returns {Array} Returns a new array of grouped elements.
     * @example
     *
     * _.zip(['moe', 'larry'], [30, 40], [true, false]);
     * // => [['moe', 30, true], ['larry', 40, false]]
     */
        function zip() {
            for (var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(0 > length ? 0 : length); ++index < length; ) result[index] = pluck(array, index);
            return result;
        }
        /**
     * Creates an object composed from arrays of `keys` and `values`. Provide
     * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
     * or two arrays, one of `keys` and one of corresponding `values`.
     *
     * @static
     * @memberOf _
     * @alias object
     * @category Arrays
     * @param {Array} keys The array of keys.
     * @param {Array} [values=[]] The array of values.
     * @returns {Object} Returns an object composed of the given keys and
     *  corresponding values.
     * @example
     *
     * _.zipObject(['moe', 'larry'], [30, 40]);
     * // => { 'moe': 30, 'larry': 40 }
     */
        function zipObject(keys, values) {
            for (var index = -1, length = keys ? keys.length : 0, result = {}; ++index < length; ) {
                var key = keys[index];
                values ? result[key] = values[index] : key && (result[key[0]] = key[1]);
            }
            return result;
        }
        /*--------------------------------------------------------------------------*/
        /**
     * Creates a function that executes `func`, with  the `this` binding and
     * arguments of the created function, only after being called `n` times.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {number} n The number of times the function must be called before
     *  `func` is executed.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('Done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => logs 'Done saving!', after all saves have completed
     */
        function after(n, func) {
            if (!isFunction(func)) throw new TypeError();
            return function() {
                return --n < 1 ? func.apply(this, arguments) : void 0;
            };
        }
        /**
     * Creates a function that, when called, invokes `func` with the `this`
     * binding of `thisArg` and prepends any additional `bind` arguments to those
     * provided to the bound function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to bind.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var func = function(greeting) {
     *   return greeting + ' ' + this.name;
     * };
     *
     * func = _.bind(func, { 'name': 'moe' }, 'hi');
     * func();
     * // => 'hi moe'
     */
        function bind(func, thisArg) {
            return arguments.length > 2 ? createBound(func, 17, nativeSlice.call(arguments, 2), null, thisArg) : createBound(func, 1, null, null, thisArg);
        }
        /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method. Method names may be specified as individual arguments or as arrays
     * of method names. If no method names are provided all the function properties
     * of `object` will be bound.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...string} [methodName] The object method names to
     *  bind, specified as individual method names or arrays of method names.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *  'label': 'docs',
     *  'onClick': function() { console.log('clicked ' + this.label); }
     * };
     *
     * _.bindAll(view);
     * jQuery('#docs').on('click', view.onClick);
     * // => logs 'clicked docs', when the button is clicked
     */
        function bindAll(object) {
            for (var funcs = arguments.length > 1 ? baseFlatten(arguments, !0, !1, 1) : functions(object), index = -1, length = funcs.length; ++index < length; ) {
                var key = funcs[index];
                object[key] = createBound(object[key], 1, null, null, object);
            }
            return object;
        }
        /**
     * Creates a function that, when called, invokes the method at `object[key]`
     * and prepends any additional `bindKey` arguments to those provided to the bound
     * function. This method differs from `_.bind` by allowing bound functions to
     * reference methods that will be redefined or don't yet exist.
     * See http://michaux.ca/articles/lazy-function-definition-pattern.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Object} object The object the method belongs to.
     * @param {string} key The key of the method.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'name': 'moe',
     *   'greet': function(greeting) {
     *     return greeting + ' ' + this.name;
     *   }
     * };
     *
     * var func = _.bindKey(object, 'greet', 'hi');
     * func();
     * // => 'hi moe'
     *
     * object.greet = function(greeting) {
     *   return greeting + ', ' + this.name + '!';
     * };
     *
     * func();
     * // => 'hi, moe!'
     */
        function bindKey(object, key) {
            return arguments.length > 2 ? createBound(key, 19, nativeSlice.call(arguments, 2), null, object) : createBound(key, 3, null, null, object);
        }
        /**
     * Creates a function that is the composition of the provided functions,
     * where each function consumes the return value of the function that follows.
     * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
     * Each function is executed with the `this` binding of the composed function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {...Function} [func] Functions to compose.
     * @returns {Function} Returns the new composed function.
     * @example
     *
     * var realNameMap = {
     *   'curly': 'jerome'
     * };
     *
     * var format = function(name) {
     *   name = realNameMap[name.toLowerCase()] || name;
     *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
     * };
     *
     * var greet = function(formatted) {
     *   return 'Hiya ' + formatted + '!';
     * };
     *
     * var welcome = _.compose(greet, format);
     * welcome('curly');
     * // => 'Hiya Jerome!'
     */
        function compose() {
            for (var funcs = arguments, length = funcs.length; length--; ) if (!isFunction(funcs[length])) throw new TypeError();
            return function() {
                for (var args = arguments, length = funcs.length; length--; ) args = [ funcs[length].apply(this, args) ];
                return args[0];
            };
        }
        /**
     * Produces a callback bound to an optional `thisArg`. If `func` is a property
     * name the created callback will return the property value for a given element.
     * If `func` is an object the created callback will return `true` for elements
     * that contain the equivalent object properties, otherwise it will return `false`.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} [func=identity] The value to convert to a callback.
     * @param {*} [thisArg] The `this` binding of the created callback.
     * @param {number} [argCount] The number of arguments the callback accepts.
     * @returns {Function} Returns a callback function.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 }
     * ];
     *
     * // wrap to create custom callback shorthands
     * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
     *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
     *   return !match ? func(callback, thisArg) : function(object) {
     *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
     *   };
     * });
     *
     * _.filter(stooges, 'age__gt45');
     * // => [{ 'name': 'larry', 'age': 50 }]
     */
        function createCallback(func, thisArg, argCount) {
            var type = typeof func;
            if (null == func || "function" == type) return baseCreateCallback(func, thisArg, argCount);
            // handle "_.pluck" style callback shorthands
            if ("object" != type) return function(object) {
                return object[func];
            };
            var props = keys(func), key = props[0], a = func[key];
            // handle "_.where" style callback shorthands
            // handle "_.where" style callback shorthands
            return 1 != props.length || a !== a || isObject(a) ? function(object) {
                for (var length = props.length, result = !1; length-- && (result = baseIsEqual(object[props[length]], func[props[length]], null, !0)); ) ;
                return result;
            } : function(object) {
                var b = object[key];
                return a === b && (0 !== a || 1 / a == 1 / b);
            };
        }
        /**
     * Creates a function which accepts one or more arguments of `func` that when
     * invoked either executes `func` returning its result, if all `func` arguments
     * have been provided, or returns a function that accepts one or more of the
     * remaining `func` arguments, and so on. The arity of `func` can be specified
     * if `func.length` is not sufficient.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var curried = _.curry(function(a, b, c) {
     *   console.log(a + b + c);
     * });
     *
     * curried(1)(2)(3);
     * // => 6
     *
     * curried(1, 2)(3);
     * // => 6
     *
     * curried(1, 2, 3);
     * // => 6
     */
        function curry(func, arity) {
            return arity = "number" == typeof arity ? arity : +arity || func.length, createBound(func, 4, null, null, null, arity);
        }
        /**
     * Creates a function that will delay the execution of `func` until after
     * `wait` milliseconds have elapsed since the last time it was invoked.
     * Provide an options object to indicate that `func` should be invoked on
     * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
     * to the debounced function will return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the debounced function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to debounce.
     * @param {number} wait The number of milliseconds to delay.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
     * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // avoid costly calculations while the window size is in flux
     * var lazyLayout = _.debounce(calculateLayout, 150);
     * jQuery(window).on('resize', lazyLayout);
     *
     * // execute `sendMail` when the click event is fired, debouncing subsequent calls
     * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * });
     *
     * // ensure `batchLog` is executed once after 1 second of debounced calls
     * var source = new EventSource('/stream');
     * source.addEventListener('message', _.debounce(batchLog, 250, {
     *   'maxWait': 1000
     * }, false);
     */
        function debounce(func, wait, options) {
            var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = !1, trailing = !0;
            if (!isFunction(func)) throw new TypeError();
            if (wait = nativeMax(0, wait) || 0, options === !0) {
                var leading = !0;
                trailing = !1;
            } else isObject(options) && (leading = options.leading, maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0), 
            trailing = "trailing" in options ? options.trailing : trailing);
            var delayed = function() {
                var remaining = wait - (new Date() - stamp);
                if (0 >= remaining) {
                    maxTimeoutId && clearTimeout(maxTimeoutId);
                    var isCalled = trailingCall;
                    maxTimeoutId = timeoutId = trailingCall = undefined, isCalled && (lastCalled = +new Date(), 
                    result = func.apply(thisArg, args));
                } else timeoutId = setTimeout(delayed, remaining);
            }, maxDelayed = function() {
                timeoutId && clearTimeout(timeoutId), maxTimeoutId = timeoutId = trailingCall = undefined, 
                (trailing || maxWait !== wait) && (lastCalled = +new Date(), result = func.apply(thisArg, args));
            };
            return function() {
                if (args = arguments, stamp = +new Date(), thisArg = this, trailingCall = trailing && (timeoutId || !leading), 
                maxWait === !1) var leadingCall = leading && !timeoutId; else {
                    maxTimeoutId || leading || (lastCalled = stamp);
                    var remaining = maxWait - (stamp - lastCalled);
                    0 >= remaining ? (maxTimeoutId && (maxTimeoutId = clearTimeout(maxTimeoutId)), lastCalled = stamp, 
                    result = func.apply(thisArg, args)) : maxTimeoutId || (maxTimeoutId = setTimeout(maxDelayed, remaining));
                }
                return timeoutId || wait === maxWait || (timeoutId = setTimeout(delayed, wait)), 
                leadingCall && (result = func.apply(thisArg, args)), result;
            };
        }
        /**
     * Defers executing the `func` function until the current call stack has cleared.
     * Additional arguments will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to defer.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function() { console.log('deferred'); });
     * // returns from the function before 'deferred' is logged
     */
        function defer(func) {
            if (!isFunction(func)) throw new TypeError();
            var args = nativeSlice.call(arguments, 1);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, 1);
        }
        /**
     * Executes the `func` function after `wait` milliseconds. Additional arguments
     * will be provided to `func` when it is invoked.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay execution.
     * @param {...*} [arg] Arguments to invoke the function with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * var log = _.bind(console.log, console);
     * _.delay(log, 1000, 'logged later');
     * // => 'logged later' (Appears after one second.)
     */
        function delay(func, wait) {
            if (!isFunction(func)) throw new TypeError();
            var args = nativeSlice.call(arguments, 2);
            return setTimeout(function() {
                func.apply(undefined, args);
            }, wait);
        }
        /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided it will be used to determine the cache key for storing the result
     * based on the arguments provided to the memoized function. By default, the
     * first argument provided to the memoized function is used as the cache key.
     * The `func` is executed with the `this` binding of the memoized function.
     * The result cache is exposed as the `cache` property on the memoized function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] A function used to resolve the cache key.
     * @returns {Function} Returns the new memoizing function.
     * @example
     *
     * var fibonacci = _.memoize(function(n) {
     *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
     * });
     *
     * var data = {
     *   'moe': { 'name': 'moe', 'age': 40 },
     *   'curly': { 'name': 'curly', 'age': 60 }
     * };
     *
     * // modifying the result cache
     * var stooge = _.memoize(function(name) { return data[name]; }, _.identity);
     * stooge('curly');
     * // => { 'name': 'curly', 'age': 60 }
     *
     * stooge.cache.curly.name = 'jerome';
     * stooge('curly');
     * // => { 'name': 'jerome', 'age': 60 }
     */
        function memoize(func, resolver) {
            if (!isFunction(func)) throw new TypeError();
            var memoized = function() {
                var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
            };
            return memoized.cache = {}, memoized;
        }
        /**
     * Creates a function that is restricted to execute `func` once. Repeat calls to
     * the function will return the value of the first call. The `func` is executed
     * with the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // `initialize` executes `createApplication` once
     */
        function once(func) {
            var ran, result;
            if (!isFunction(func)) throw new TypeError();
            return function() {
                // clear the `func` variable so the function may be garbage collected
                return ran ? result : (ran = !0, result = func.apply(this, arguments), func = null, 
                result);
            };
        }
        /**
     * Creates a function that, when called, invokes `func` with any additional
     * `partial` arguments prepended to those provided to the new function. This
     * method is similar to `_.bind` except it does **not** alter the `this` binding.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var greet = function(greeting, name) { return greeting + ' ' + name; };
     * var hi = _.partial(greet, 'hi');
     * hi('moe');
     * // => 'hi moe'
     */
        function partial(func) {
            return createBound(func, 16, nativeSlice.call(arguments, 1));
        }
        /**
     * This method is like `_.partial` except that `partial` arguments are
     * appended to those provided to the new function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [arg] Arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * var defaultsDeep = _.partialRight(_.merge, _.defaults);
     *
     * var options = {
     *   'variable': 'data',
     *   'imports': { 'jq': $ }
     * };
     *
     * defaultsDeep(options, _.templateSettings);
     *
     * options.variable
     * // => 'data'
     *
     * options.imports
     * // => { '_': _, 'jq': $ }
     */
        function partialRight(func) {
            return createBound(func, 32, null, nativeSlice.call(arguments, 1));
        }
        /**
     * Creates a function that, when executed, will only call the `func` function
     * at most once per every `wait` milliseconds. Provide an options object to
     * indicate that `func` should be invoked on the leading and/or trailing edge
     * of the `wait` timeout. Subsequent calls to the throttled function will
     * return the result of the last `func` call.
     *
     * Note: If `leading` and `trailing` options are `true` `func` will be called
     * on the trailing edge of the timeout only if the the throttled function is
     * invoked more than once during the `wait` timeout.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {Function} func The function to throttle.
     * @param {number} wait The number of milliseconds to throttle executions to.
     * @param {Object} [options] The options object.
     * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // avoid excessively updating the position while scrolling
     * var throttled = _.throttle(updatePosition, 100);
     * jQuery(window).on('scroll', throttled);
     *
     * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
     * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
     *   'trailing': false
     * }));
     */
        function throttle(func, wait, options) {
            var leading = !0, trailing = !0;
            if (!isFunction(func)) throw new TypeError();
            options === !1 ? leading = !1 : isObject(options) && (leading = "leading" in options ? options.leading : leading, 
            trailing = "trailing" in options ? options.trailing : trailing), options = getObject(), 
            options.leading = leading, options.maxWait = wait, options.trailing = trailing;
            var result = debounce(func, wait, options);
            return releaseObject(options), result;
        }
        /**
     * Creates a function that provides `value` to the wrapper function as its
     * first argument. Additional arguments provided to the function are appended
     * to those provided to the wrapper function. The wrapper is executed with
     * the `this` binding of the created function.
     *
     * @static
     * @memberOf _
     * @category Functions
     * @param {*} value The value to wrap.
     * @param {Function} wrapper The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var hello = function(name) { return 'hello ' + name; };
     * hello = _.wrap(hello, function(func) {
     *   return 'before, ' + func('moe') + ', after';
     * });
     * hello();
     * // => 'before, hello moe, after'
     */
        function wrap(value, wrapper) {
            if (!isFunction(wrapper)) throw new TypeError();
            return function() {
                var args = [ value ];
                return push.apply(args, arguments), wrapper.apply(this, args);
            };
        }
        /*--------------------------------------------------------------------------*/
        /**
     * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
     * corresponding HTML entities.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('Moe, Larry & Curly');
     * // => 'Moe, Larry &amp; Curly'
     */
        function escape(string) {
            return null == string ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
        }
        /**
     * This method returns the first argument provided to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var moe = { 'name': 'moe' };
     * moe === _.identity(moe);
     * // => true
     */
        function identity(value) {
            return value;
        }
        /**
     * Adds function properties of a source object to the `lodash` function and
     * chainable wrapper.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object of function properties to add to `lodash`.
     * @param {Object} object The object of function properties to add to `lodash`.
     * @example
     *
     * _.mixin({
     *   'capitalize': function(string) {
     *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
     *   }
     * });
     *
     * _.capitalize('moe');
     * // => 'Moe'
     *
     * _('moe').capitalize();
     * // => 'Moe'
     */
        function mixin(object, source) {
            var ctor = object, isFunc = !source || isFunction(ctor);
            source || (ctor = lodashWrapper, source = object, object = lodash), forEach(functions(source), function(methodName) {
                var func = object[methodName] = source[methodName];
                isFunc && (ctor.prototype[methodName] = function() {
                    var value = this.__wrapped__, args = [ value ];
                    push.apply(args, arguments);
                    var result = func.apply(object, args);
                    return value && "object" == typeof value && value === result ? this : new ctor(result);
                });
            });
        }
        /**
     * Reverts the '_' variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
        function noConflict() {
            return context._ = oldDash, this;
        }
        /**
     * Produces a random number between `min` and `max` (inclusive). If only one
     * argument is provided a number between `0` and the given number will be
     * returned. If `floating` is truey or either `min` or `max` are floats a
     * floating-point number will be returned instead of an integer.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} [min=0] The minimum possible value.
     * @param {number} [max=1] The maximum possible value.
     * @param {boolean} [floating=false] Specify returning a floating-point number.
     * @returns {number} Returns a random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
        function random(min, max, floating) {
            var noMin = null == min, noMax = null == max;
            null == floating && ("boolean" == typeof min && noMax ? (floating = min, min = 1) : noMax || "boolean" != typeof max || (floating = max, 
            noMax = !0)), noMin && noMax && (max = 1), min = +min || 0, noMax ? (max = min, 
            min = 0) : max = +max || 0;
            var rand = nativeRandom();
            return floating || min % 1 || max % 1 ? min + nativeMin(rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max) : min + floor(rand * (max - min + 1));
        }
        /**
     * Resolves the value of `property` on `object`. If `property` is a function
     * it will be invoked with the `this` binding of `object` and its result returned,
     * else the property value is returned. If `object` is falsey then `undefined`
     * is returned.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {Object} object The object to inspect.
     * @param {string} property The property to get the value of.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = {
     *   'cheese': 'crumpets',
     *   'stuff': function() {
     *     return 'nonsense';
     *   }
     * };
     *
     * _.result(object, 'cheese');
     * // => 'crumpets'
     *
     * _.result(object, 'stuff');
     * // => 'nonsense'
     */
        function result(object, property) {
            if (object) {
                var value = object[property];
                return isFunction(value) ? object[property]() : value;
            }
        }
        /**
     * A micro-templating method that handles arbitrary delimiters, preserves
     * whitespace, and correctly escapes quotes within interpolated code.
     *
     * Note: In the development build, `_.template` utilizes sourceURLs for easier
     * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
     *
     * For more information on precompiling templates see:
     * http://lodash.com/#custom-builds
     *
     * For more information on Chrome extension sandboxes see:
     * http://developer.chrome.com/stable/extensions/sandboxingEval.html
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} text The template text.
     * @param {Object} data The data object used to populate the text.
     * @param {Object} [options] The options object.
     * @param {RegExp} [options.escape] The "escape" delimiter.
     * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
     * @param {Object} [options.imports] An object to import into the template as local variables.
     * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
     * @param {string} [sourceURL] The sourceURL of the template's compiled source.
     * @param {string} [variable] The data object variable name.
     * @returns {Function|string} Returns a compiled function when no `data` object
     *  is given, else it returns the interpolated text.
     * @example
     *
     * // using the "interpolate" delimiter to create a compiled template
     * var compiled = _.template('hello <%= name %>');
     * compiled({ 'name': 'moe' });
     * // => 'hello moe'
     *
     * // using the "escape" delimiter to escape HTML in data property values
     * _.template('<b><%- value %></b>', { 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // using the "evaluate" delimiter to generate HTML
     * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['moe', 'larry'] });
     * // => '<li>moe</li><li>larry</li>'
     *
     * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
     * _.template('hello ${ name }', { 'name': 'curly' });
     * // => 'hello curly'
     *
     * // using the internal `print` function in "evaluate" delimiters
     * _.template('<% print("hello " + name); %>!', { 'name': 'larry' });
     * // => 'hello larry!'
     *
     * // using a custom template delimiters
     * _.templateSettings = {
     *   'interpolate': /{{([\s\S]+?)}}/g
     * };
     *
     * _.template('hello {{ name }}!', { 'name': 'mustache' });
     * // => 'hello mustache!'
     *
     * // using the `imports` option to import jQuery
     * var list = '<% $.each(people, function(name) { %><li><%- name %></li><% }); %>';
     * _.template(list, { 'people': ['moe', 'larry'] }, { 'imports': { '$': jQuery } });
     * // => '<li>moe</li><li>larry</li>'
     *
     * // using the `sourceURL` option to specify a custom sourceURL for the template
     * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
     *
     * // using the `variable` option to ensure a with-statement isn't used in the compiled template
     * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     *   var __t, __p = '', __e = _.escape;
     *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
     *   return __p;
     * }
     *
     * // using the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and a stack trace
     * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
        function template(text, data, options) {
            // based on John Resig's `tmpl` implementation
            // http://ejohn.org/blog/javascript-micro-templating/
            // and Laura Doktorova's doT.js
            // https://github.com/olado/doT
            var settings = lodash.templateSettings;
            text || (text = ""), // avoid missing dependencies when `iteratorTemplate` is not defined
            options = defaults({}, options, settings);
            var isEvaluating, imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports), index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '", reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                // the JS engine embedded in Adobe products requires returning the `match`
                // string in order to produce the correct `offset` value
                // escape characters that cannot be included in string literals
                // replace delimiters with snippets
                return interpolateValue || (interpolateValue = esTemplateValue), source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar), 
                escapeValue && (source += "' +\n__e(" + escapeValue + ") +\n'"), evaluateValue && (isEvaluating = !0, 
                source += "';\n" + evaluateValue + ";\n__p += '"), interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"), 
                index = offset + match.length, match;
            }), source += "';\n";
            // if `variable` is not specified, wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain
            var variable = options.variable, hasVariable = variable;
            hasVariable || (variable = "obj", source = "with (" + variable + ") {\n" + source + "\n}\n"), 
            // cleanup code by stripping empty strings
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), 
            // frame code as the function body
            source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            // Use a sourceURL for easier debugging.
            // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
            var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
            try {
                var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
            } catch (e) {
                throw e.source = source, e;
            }
            // provide the compiled function's source by its `toString` method, in
            // supported environments, or the `source` property as a convenience for
            // inlining compiled templates during the build process
            return data ? result(data) : (result.source = source, result);
        }
        /**
     * Executes the callback `n` times, returning an array of the results
     * of each callback execution. The callback is bound to `thisArg` and invoked
     * with one argument; (index).
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {number} n The number of times to execute the callback.
     * @param {Function} callback The function called per iteration.
     * @param {*} [thisArg] The `this` binding of `callback`.
     * @returns {Array} Returns an array of the results of each `callback` execution.
     * @example
     *
     * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
     * // => [3, 6, 4]
     *
     * _.times(3, function(n) { mage.castSpell(n); });
     * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
     *
     * _.times(3, function(n) { this.cast(n); }, mage);
     * // => also calls `mage.castSpell(n)` three times
     */
        function times(n, callback, thisArg) {
            n = (n = +n) > -1 ? n : 0;
            var index = -1, result = Array(n);
            for (callback = baseCreateCallback(callback, thisArg, 1); ++index < n; ) result[index] = callback(index);
            return result;
        }
        /**
     * The inverse of `_.escape` this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
     * corresponding characters.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} string The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('Moe, Larry &amp; Curly');
     * // => 'Moe, Larry & Curly'
     */
        function unescape(string) {
            return null == string ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
        }
        /**
     * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} [prefix] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
        function uniqueId(prefix) {
            var id = ++idCounter;
            return String(null == prefix ? "" : prefix) + id;
        }
        /*--------------------------------------------------------------------------*/
        /**
     * Creates a `lodash` object that wraps the given value.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var stooges = [
     *   { 'name': 'moe', 'age': 40 },
     *   { 'name': 'larry', 'age': 50 },
     *   { 'name': 'curly', 'age': 60 }
     * ];
     *
     * var youngest = _.chain(stooges)
     *     .sortBy(function(stooge) { return stooge.age; })
     *     .map(function(stooge) { return stooge.name + ' is ' + stooge.age; })
     *     .first();
     * // => 'moe is 40'
     */
        function chain(value) {
            return value = new lodashWrapper(value), value.__chain__ = !0, value;
        }
        /**
     * Invokes `interceptor` with the `value` as the first argument and then
     * returns `value`. The purpose of this method is to "tap into" a method
     * chain in order to perform operations on intermediate results within
     * the chain.
     *
     * @static
     * @memberOf _
     * @category Chaining
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3, 4])
     *  .filter(function(num) { return num % 2 == 0; })
     *  .tap(function(array) { console.log(array); })
     *  .map(function(num) { return num * num; })
     *  .value();
     * // => // [2, 4] (logged)
     * // => [4, 16]
     */
        function tap(value, interceptor) {
            return interceptor(value), value;
        }
        /**
     * Enables method chaining on the wrapper object.
     *
     * @name chain
     * @memberOf _
     * @category Chaining
     * @returns {*} Returns the wrapper object.
     * @example
     *
     * var sum = _([1, 2, 3])
     *     .chain()
     *     .reduce(function(sum, num) { return sum + num; })
     *     .value()
     * // => 6`
     */
        function wrapperChain() {
            return this.__chain__ = !0, this;
        }
        /**
     * Produces the `toString` result of the wrapped value.
     *
     * @name toString
     * @memberOf _
     * @category Chaining
     * @returns {string} Returns the string result.
     * @example
     *
     * _([1, 2, 3]).toString();
     * // => '1,2,3'
     */
        function wrapperToString() {
            return String(this.__wrapped__);
        }
        /**
     * Extracts the wrapped value.
     *
     * @name valueOf
     * @memberOf _
     * @alias value
     * @category Chaining
     * @returns {*} Returns the wrapped value.
     * @example
     *
     * _([1, 2, 3]).valueOf();
     * // => [1, 2, 3]
     */
        function wrapperValueOf() {
            return this.__wrapped__;
        }
        // Avoid issues with some ES3 environments that attempt to use values, named
        // after built-in constructors like `Object`, for the creation of literals.
        // ES5 clears this up by stating that literals must use built-in constructors.
        // See http://es5.github.io/#x11.1.5.
        context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
        /** Native constructor references */
        var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError, arrayRef = [], errorProto = Error.prototype, objectProto = Object.prototype, stringProto = String.prototype, oldDash = context._, reNative = RegExp("^" + String(objectProto.valueOf).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/valueOf|for [^\]]+/g, ".+?") + "$"), ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, propertyIsEnumerable = objectProto.propertyIsEnumerable, setImmediate = context.setImmediate, setTimeout = context.setTimeout, splice = arrayRef.splice, toString = objectProto.toString, unshift = arrayRef.unshift, defineProperty = function() {
            try {
                var o = {}, func = reNative.test(func = Object.defineProperty) && func, result = func(o, o, o) && func;
            } catch (e) {}
            return result;
        }(), nativeBind = reNative.test(nativeBind = toString.bind) && nativeBind, nativeCreate = reNative.test(nativeCreate = Object.create) && nativeCreate, nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeSlice = arrayRef.slice, isIeOpera = reNative.test(context.attachEvent), isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera), ctorByClass = {};
        ctorByClass[arrayClass] = Array, ctorByClass[boolClass] = Boolean, ctorByClass[dateClass] = Date, 
        ctorByClass[funcClass] = Function, ctorByClass[objectClass] = Object, ctorByClass[numberClass] = Number, 
        ctorByClass[regexpClass] = RegExp, ctorByClass[stringClass] = String;
        /** Used to avoid iterating non-enumerable properties in IE < 9 */
        var nonEnumProps = {};
        nonEnumProps[arrayClass] = nonEnumProps[dateClass] = nonEnumProps[numberClass] = {
            constructor: !0,
            toLocaleString: !0,
            toString: !0,
            valueOf: !0
        }, nonEnumProps[boolClass] = nonEnumProps[stringClass] = {
            constructor: !0,
            toString: !0,
            valueOf: !0
        }, nonEnumProps[errorClass] = nonEnumProps[funcClass] = nonEnumProps[regexpClass] = {
            constructor: !0,
            toString: !0
        }, nonEnumProps[objectClass] = {
            constructor: !0
        }, function() {
            for (var length = shadowedProps.length; length--; ) {
                var prop = shadowedProps[length];
                for (var className in nonEnumProps) hasOwnProperty.call(nonEnumProps, className) && !hasOwnProperty.call(nonEnumProps[className], prop) && (nonEnumProps[className][prop] = !1);
            }
        }(), // ensure `new lodashWrapper` is an instance of `lodash`
        lodashWrapper.prototype = lodash.prototype;
        /**
     * An object used to flag environments features.
     *
     * @static
     * @memberOf _
     * @type Object
     */
        var support = lodash.support = {};
        !function() {
            var ctor = function() {
                this.x = 1;
            }, object = {
                "0": 1,
                length: 1
            }, props = [];
            ctor.prototype = {
                valueOf: 1,
                y: 1
            };
            for (var prop in new ctor()) props.push(prop);
            for (prop in arguments) ;
            /**
       * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
       *
       * @memberOf _.support
       * @type boolean
       */
            support.argsClass = toString.call(arguments) == argsClass, /**
       * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
       *
       * @memberOf _.support
       * @type boolean
       */
            support.argsObject = arguments.constructor == Object && !(arguments instanceof Array), 
            /**
       * Detect if `name` or `message` properties of `Error.prototype` are
       * enumerable by default. (IE < 9, Safari < 5.1)
       *
       * @memberOf _.support
       * @type boolean
       */
            support.enumErrorProps = propertyIsEnumerable.call(errorProto, "message") || propertyIsEnumerable.call(errorProto, "name"), 
            /**
       * Detect if `prototype` properties are enumerable by default.
       *
       * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
       * (if the prototype or a property on the prototype has been set)
       * incorrectly sets a function's `prototype` property [[Enumerable]]
       * value to `true`.
       *
       * @memberOf _.support
       * @type boolean
       */
            support.enumPrototypes = propertyIsEnumerable.call(ctor, "prototype"), /**
       * Detect if `Function#bind` exists and is inferred to be fast (all but V8).
       *
       * @memberOf _.support
       * @type boolean
       */
            support.fastBind = nativeBind && !isV8, /**
       * Detect if functions can be decompiled by `Function#toString`
       * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
       *
       * @memberOf _.support
       * @type boolean
       */
            support.funcDecomp = !reNative.test(context.WinRTError) && reThis.test(runInContext), 
            /**
       * Detect if `Function#name` is supported (all but IE).
       *
       * @memberOf _.support
       * @type boolean
       */
            support.funcNames = "string" == typeof Function.name, /**
       * Detect if `arguments` object indexes are non-enumerable
       * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
       *
       * @memberOf _.support
       * @type boolean
       */
            support.nonEnumArgs = 0 != prop, /**
       * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
       *
       * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
       * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
       *
       * @memberOf _.support
       * @type boolean
       */
            support.nonEnumShadows = !/valueOf/.test(props), /**
       * Detect if own properties are iterated after inherited properties (all but IE < 9).
       *
       * @memberOf _.support
       * @type boolean
       */
            support.ownLast = "x" != props[0], /**
       * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
       *
       * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
       * and `splice()` functions that fail to remove the last element, `value[0]`,
       * of array-like objects even though the `length` property is set to `0`.
       * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
       * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
       *
       * @memberOf _.support
       * @type boolean
       */
            support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]), /**
       * Detect lack of support for accessing string characters by index.
       *
       * IE < 8 can't access characters by index and IE 8 can only access
       * characters by index on string literals.
       *
       * @memberOf _.support
       * @type boolean
       */
            support.unindexedChars = "x"[0] + Object("x")[0] != "xx";
            /**
       * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
       * and that the JS engine errors when attempting to coerce an object to
       * a string without a `toString` function.
       *
       * @memberOf _.support
       * @type boolean
       */
            try {
                support.nodeClass = !(toString.call(document) == objectClass && !({
                    toString: 0
                } + ""));
            } catch (e) {
                support.nodeClass = !0;
            }
        }(1), /**
     * By default, the template delimiters used by Lo-Dash are similar to those in
     * embedded Ruby (ERB). Change the following template settings to use alternative
     * delimiters.
     *
     * @static
     * @memberOf _
     * @type Object
     */
        lodash.templateSettings = {
            /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
            escape: /<%-([\s\S]+?)%>/g,
            /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
            evaluate: /<%([\s\S]+?)%>/g,
            /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type RegExp
       */
            interpolate: reInterpolate,
            /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type string
       */
            variable: "",
            /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type Object
       */
            imports: {
                /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type Function
         */
                _: lodash
            }
        };
        /*--------------------------------------------------------------------------*/
        /**
     * The template used to create iterator functions.
     *
     * @private
     * @param {Object} data The data object used to populate the text.
     * @returns {string} Returns the interpolated text.
     */
        var iteratorTemplate = function(obj) {
            var __p = "var index, iterable = " + obj.firstArg + ", result = " + obj.init + ";\nif (!iterable) return result;\n" + obj.top + ";";
            obj.array ? (__p += "\nvar length = iterable.length; index = -1;\nif (" + obj.array + ") {  ", 
            support.unindexedChars && (__p += "\n  if (isString(iterable)) {\n    iterable = iterable.split('')\n  }  "), 
            __p += "\n  while (++index < length) {\n    " + obj.loop + ";\n  }\n}\nelse {  ") : support.nonEnumArgs && (__p += "\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += '';\n      " + obj.loop + ";\n    }\n  } else {  "), 
            support.enumPrototypes && (__p += "\n  var skipProto = typeof iterable == 'function';\n  "), 
            support.enumErrorProps && (__p += "\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ");
            var conditions = [];
            if (support.enumPrototypes && conditions.push('!(skipProto && index == "prototype")'), 
            support.enumErrorProps && conditions.push('!(skipErrorProps && (index == "message" || index == "name"))'), 
            obj.useHas && obj.keys) __p += "\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n", 
            conditions.length && (__p += "    if (" + conditions.join(" && ") + ") {\n  "), 
            __p += obj.loop + ";    ", conditions.length && (__p += "\n    }"), __p += "\n  }  "; else if (__p += "\n  for (index in iterable) {\n", 
            obj.useHas && conditions.push("hasOwnProperty.call(iterable, index)"), conditions.length && (__p += "    if (" + conditions.join(" && ") + ") {\n  "), 
            __p += obj.loop + ";    ", conditions.length && (__p += "\n    }"), __p += "\n  }    ", 
            support.nonEnumShadows) {
                for (__p += "\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ", 
                k = 0; 7 > k; k++) __p += "\n    index = '" + obj.shadowedProps[k] + "';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))", 
                obj.useHas || (__p += " || (!nonEnum[index] && iterable[index] !== objectProto[index])"), 
                __p += ") {\n      " + obj.loop + ";\n    }      ";
                __p += "\n  }    ";
            }
            return (obj.array || support.nonEnumArgs) && (__p += "\n}"), __p += obj.bottom + ";\nreturn result";
        };
        // fallback for browsers without `Object.create`
        nativeCreate || (createObject = function(prototype) {
            if (isObject(prototype)) {
                noop.prototype = prototype;
                var result = new noop();
                noop.prototype = null;
            }
            return result || {};
        });
        /**
     * Sets `this` binding data on a given function.
     *
     * @private
     * @param {Function} func The function to set data on.
     * @param {*} value The value to set.
     */
        var setBindData = defineProperty ? function(func, value) {
            var descriptor = getObject();
            descriptor.value = value, defineProperty(func, "__bindData__", descriptor), releaseObject(descriptor);
        } : noop;
        // fallback for browsers that can't detect `arguments` objects by [[Class]]
        support.argsClass || (isArguments = function(value) {
            return value && "object" == typeof value && "number" == typeof value.length && hasOwnProperty.call(value, "callee") || !1;
        });
        /**
     * Checks if `value` is an array.
     *
     * @static
     * @memberOf _
     * @type Function
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
     * @example
     *
     * (function() { return _.isArray(arguments); })();
     * // => false
     *
     * _.isArray([1, 2, 3]);
     * // => true
     */
        var isArray = nativeIsArray || function(value) {
            return value && "object" == typeof value && "number" == typeof value.length && toString.call(value) == arrayClass || !1;
        }, shimKeys = createIterator({
            args: "object",
            init: "[]",
            top: "if (!(objectTypes[typeof object])) return result",
            loop: "result.push(index)"
        }), keys = nativeKeys ? function(object) {
            return isObject(object) ? support.enumPrototypes && "function" == typeof object || support.nonEnumArgs && object.length && isArguments(object) ? shimKeys(object) : nativeKeys(object) : [];
        } : shimKeys, eachIteratorOptions = {
            args: "collection, callback, thisArg",
            top: "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
            array: "typeof length == 'number'",
            keys: keys,
            loop: "if (callback(iterable[index], index, collection) === false) return result"
        }, defaultsIteratorOptions = {
            args: "object, source, guard",
            top: "var args = arguments,\n    argsIndex = 0,\n    argsLength = typeof guard == 'number' ? 2 : args.length;\nwhile (++argsIndex < argsLength) {\n  iterable = args[argsIndex];\n  if (iterable && objectTypes[typeof iterable]) {",
            keys: keys,
            loop: "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
            bottom: "  }\n}"
        }, forOwnIteratorOptions = {
            top: "if (!objectTypes[typeof iterable]) return result;\n" + eachIteratorOptions.top,
            array: !1
        }, htmlEscapes = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        }, htmlUnescapes = invert(htmlEscapes), reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g"), baseEach = createIterator(eachIteratorOptions), assign = createIterator(defaultsIteratorOptions, {
            top: defaultsIteratorOptions.top.replace(";", ";\nif (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n  callback = args[--argsLength];\n}"),
            loop: "result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]"
        }), defaults = createIterator(defaultsIteratorOptions), forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
            useHas: !1
        }), forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);
        // fallback for older versions of Chrome and Safari
        isFunction(/x/) && (isFunction = function(value) {
            return "function" == typeof value && toString.call(value) == funcClass;
        });
        /**
     * Checks if `value` is an object created by the `Object` constructor.
     *
     * @static
     * @memberOf _
     * @category Objects
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Stooge(name, age) {
     *   this.name = name;
     *   this.age = age;
     * }
     *
     * _.isPlainObject(new Stooge('moe', 40));
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'name': 'moe', 'age': 40 });
     * // => true
     */
        var isPlainObject = getPrototypeOf ? function(value) {
            if (!value || toString.call(value) != objectClass || !support.argsClass && isArguments(value)) return !1;
            var valueOf = value.valueOf, objProto = "function" == typeof valueOf && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
            return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
        } : shimIsPlainObject, countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
        }), groupBy = createAggregator(function(result, value, key) {
            (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
        }), indexBy = createAggregator(function(result, value, key) {
            result[key] = value;
        }), pluck = map, where = filter;
        // use `setImmediate` if available in Node.js
        isV8 && moduleExports && "function" == typeof setImmediate && (defer = function(func) {
            if (!isFunction(func)) throw new TypeError();
            return setImmediate.apply(context, arguments);
        });
        /**
     * Converts the given value into an integer of the specified radix.
     * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
     * `value` is a hexadecimal, in which case a `radix` of `16` is used.
     *
     * Note: This method avoids differences in native ES3 and ES5 `parseInt`
     * implementations. See http://es5.github.io/#E.
     *
     * @static
     * @memberOf _
     * @category Utilities
     * @param {string} value The value to parse.
     * @param {number} [radix] The radix used to interpret the value to parse.
     * @returns {number} Returns the new integer value.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     */
        var parseInt = 8 == nativeParseInt(whitespace + "08") ? nativeParseInt : function(value, radix) {
            // Firefox and Opera still follow the ES3 specified implementation of `parseInt`
            return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
        };
        /*--------------------------------------------------------------------------*/
        // add functions that return wrapped values when chaining
        // add aliases
        // add functions to `lodash.prototype`
        /*--------------------------------------------------------------------------*/
        // add functions that return unwrapped values when chaining
        // add aliases
        /*--------------------------------------------------------------------------*/
        // add functions capable of returning wrapped and unwrapped values when chaining
        // add aliases
        /*--------------------------------------------------------------------------*/
        /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type string
     */
        // add "Chaining" functions to the wrapper
        // add `Array` functions that return unwrapped values
        // add `Array` functions that return the wrapped value
        // add `Array` functions that return new wrapped values
        // avoid array-like object bugs with `Array#shift` and `Array#splice`
        // in Firefox < 10 and IE < 9
        return lodash.after = after, lodash.assign = assign, lodash.at = at, lodash.bind = bind, 
        lodash.bindAll = bindAll, lodash.bindKey = bindKey, lodash.chain = chain, lodash.compact = compact, 
        lodash.compose = compose, lodash.countBy = countBy, lodash.createCallback = createCallback, 
        lodash.curry = curry, lodash.debounce = debounce, lodash.defaults = defaults, lodash.defer = defer, 
        lodash.delay = delay, lodash.difference = difference, lodash.filter = filter, lodash.flatten = flatten, 
        lodash.forEach = forEach, lodash.forEachRight = forEachRight, lodash.forIn = forIn, 
        lodash.forInRight = forInRight, lodash.forOwn = forOwn, lodash.forOwnRight = forOwnRight, 
        lodash.functions = functions, lodash.groupBy = groupBy, lodash.indexBy = indexBy, 
        lodash.initial = initial, lodash.intersection = intersection, lodash.invert = invert, 
        lodash.invoke = invoke, lodash.keys = keys, lodash.map = map, lodash.max = max, 
        lodash.memoize = memoize, lodash.merge = merge, lodash.min = min, lodash.omit = omit, 
        lodash.once = once, lodash.pairs = pairs, lodash.partial = partial, lodash.partialRight = partialRight, 
        lodash.pick = pick, lodash.pluck = pluck, lodash.pull = pull, lodash.range = range, 
        lodash.reject = reject, lodash.remove = remove, lodash.rest = rest, lodash.shuffle = shuffle, 
        lodash.sortBy = sortBy, lodash.tap = tap, lodash.throttle = throttle, lodash.times = times, 
        lodash.toArray = toArray, lodash.transform = transform, lodash.union = union, lodash.uniq = uniq, 
        lodash.values = values, lodash.where = where, lodash.without = without, lodash.wrap = wrap, 
        lodash.zip = zip, lodash.zipObject = zipObject, lodash.collect = map, lodash.drop = rest, 
        lodash.each = forEach, lodash.eachRight = forEachRight, lodash.extend = assign, 
        lodash.methods = functions, lodash.object = zipObject, lodash.select = filter, lodash.tail = rest, 
        lodash.unique = uniq, lodash.unzip = zip, mixin(lodash), lodash.clone = clone, lodash.cloneDeep = cloneDeep, 
        lodash.contains = contains, lodash.escape = escape, lodash.every = every, lodash.find = find, 
        lodash.findIndex = findIndex, lodash.findKey = findKey, lodash.findLast = findLast, 
        lodash.findLastIndex = findLastIndex, lodash.findLastKey = findLastKey, lodash.has = has, 
        lodash.identity = identity, lodash.indexOf = indexOf, lodash.isArguments = isArguments, 
        lodash.isArray = isArray, lodash.isBoolean = isBoolean, lodash.isDate = isDate, 
        lodash.isElement = isElement, lodash.isEmpty = isEmpty, lodash.isEqual = isEqual, 
        lodash.isFinite = isFinite, lodash.isFunction = isFunction, lodash.isNaN = isNaN, 
        lodash.isNull = isNull, lodash.isNumber = isNumber, lodash.isObject = isObject, 
        lodash.isPlainObject = isPlainObject, lodash.isRegExp = isRegExp, lodash.isString = isString, 
        lodash.isUndefined = isUndefined, lodash.lastIndexOf = lastIndexOf, lodash.mixin = mixin, 
        lodash.noConflict = noConflict, lodash.parseInt = parseInt, lodash.random = random, 
        lodash.reduce = reduce, lodash.reduceRight = reduceRight, lodash.result = result, 
        lodash.runInContext = runInContext, lodash.size = size, lodash.some = some, lodash.sortedIndex = sortedIndex, 
        lodash.template = template, lodash.unescape = unescape, lodash.uniqueId = uniqueId, 
        lodash.all = every, lodash.any = some, lodash.detect = find, lodash.findWhere = find, 
        lodash.foldl = reduce, lodash.foldr = reduceRight, lodash.include = contains, lodash.inject = reduce, 
        forOwn(lodash, function(func, methodName) {
            lodash.prototype[methodName] || (lodash.prototype[methodName] = function() {
                var args = [ this.__wrapped__ ], chainAll = this.__chain__;
                push.apply(args, arguments);
                var result = func.apply(lodash, args);
                return chainAll ? new lodashWrapper(result, chainAll) : result;
            });
        }), lodash.first = first, lodash.last = last, lodash.sample = sample, lodash.take = first, 
        lodash.head = first, forOwn(lodash, function(func, methodName) {
            var callbackable = "sample" !== methodName;
            lodash.prototype[methodName] || (lodash.prototype[methodName] = function(n, guard) {
                var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                return chainAll || null != n && (!guard || callbackable && "function" == typeof n) ? new lodashWrapper(result, chainAll) : result;
            });
        }), lodash.VERSION = "2.1.0", lodash.prototype.chain = wrapperChain, lodash.prototype.toString = wrapperToString, 
        lodash.prototype.value = wrapperValueOf, lodash.prototype.valueOf = wrapperValueOf, 
        baseEach([ "join", "pop", "shift" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                return chainAll ? new lodashWrapper(result, chainAll) : result;
            };
        }), baseEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                return func.apply(this.__wrapped__, arguments), this;
            };
        }), baseEach([ "concat", "slice", "splice" ], function(methodName) {
            var func = arrayRef[methodName];
            lodash.prototype[methodName] = function() {
                return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
            };
        }), support.spliceObjects || baseEach([ "pop", "shift", "splice" ], function(methodName) {
            var func = arrayRef[methodName], isSplice = "splice" == methodName;
            lodash.prototype[methodName] = function() {
                var chainAll = this.__chain__, value = this.__wrapped__, result = func.apply(value, arguments);
                return 0 === value.length && delete value[0], chainAll || isSplice ? new lodashWrapper(result, chainAll) : result;
            };
        }), lodash;
    }
    /** Used as a safe reference for `undefined` in pre ES5 environments */
    var undefined, arrayPool = [], objectPool = [], idCounter = 0, indicatorObject = {}, keyPrefix = +new Date() + "", largeArraySize = 75, maxPoolSize = 40, whitespace = " 	\f\n\r\u2028\u2029", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reFuncName = /^function[ \n\r\t]+\w/, reInterpolate = /<%=([\s\S]+?)%>/g, reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)"), reNoMatch = /($^)/, reThis = /\bthis\b/, reUnescapedString = /['\n\r\t\u2028\u2029\\]/g, contextProps = [ "Array", "Boolean", "Date", "Error", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setImmediate", "setTimeout" ], shadowedProps = [ "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf" ], templateCounter = 0, argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", errorClass = "[object Error]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]", cloneableClasses = {};
    cloneableClasses[funcClass] = !1, cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = !0;
    /** Used to determine if values are of the language type Object */
    var objectTypes = {
        "boolean": !1,
        "function": !0,
        object: !0,
        number: !1,
        string: !1,
        undefined: !1
    }, stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, root = objectTypes[typeof window] && window || this, freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports, freeModule = objectTypes[typeof module] && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports && freeExports, freeGlobal = objectTypes[typeof global] && global;
    !freeGlobal || freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal || (root = freeGlobal);
    /*--------------------------------------------------------------------------*/
    // expose Lo-Dash
    var _ = runInContext();
    // some AMD build optimizers, like r.js, check for condition patterns like the following:
    "function" == typeof define && "object" == typeof define.amd && define.amd ? (// Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash was injected by a third-party script and not intended to be
    // loaded as a module. The global assignment can be reverted in the Lo-Dash
    // module by its `noConflict()` method.
    root._ = _, // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
        return _;
    })) : freeExports && freeModule ? // in Node.js or RingoJS
    moduleExports ? (freeModule.exports = _)._ = _ : freeExports._ = _ : // in a browser or Rhino
    root._ = _;
}.call(this), /*!
 * JavaScript Debug - v0.4 - 6/22/2010
 * http://benalman.com/projects/javascript-debug-console-log/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 * 
 * With lots of help from Paul Irish!
 * http://paulirish.com/
 */
// Script: JavaScript Debug: A simple wrapper for console.log
//
// *Version: 0.4, Last Updated: 6/22/2010*
// 
// Tested with Internet Explorer 6-8, Firefox 3-3.6, Safari 3-4, Chrome 3-5, Opera 9.6-10.5
// 
// Home       - http://benalman.com/projects/javascript-debug-console-log/
// GitHub     - http://github.com/cowboy/javascript-debug/
// Source     - http://github.com/cowboy/javascript-debug/raw/master/ba-debug.js
// (Minified) - http://github.com/cowboy/javascript-debug/raw/master/ba-debug.min.js (1.1kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Support and Testing
// 
// Information about what browsers this code has been tested in.
// 
// Browsers Tested - Internet Explorer 6-8, Firefox 3-3.6, Safari 3-4, Chrome
// 3-5, Opera 9.6-10.5
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Examples - http://benalman.com/code/projects/javascript-debug/examples/debug/
// 
// About: Revision History
// 
// 0.4 - (6/22/2010) Added missing passthrough methods: exception,
//       groupCollapsed, table
// 0.3 - (6/8/2009) Initial release
// 
// Topic: Pass-through console methods
// 
// assert, clear, count, dir, dirxml, exception, group, groupCollapsed,
// groupEnd, profile, profileEnd, table, time, timeEnd, trace
// 
// These console methods are passed through (but only if both the console and
// the method exists), so use them without fear of reprisal. Note that these
// methods will not be passed through if the logging level is set to 0 via
// <debug.setLevel>.
window.debug = function() {
    // Execute the callback function if set.
    function exec_callback(args) {
        !callback_func || !callback_force && con && con.log || callback_func.apply(window, args);
    }
    // Determine if the level is visible given the current log_level.
    function is_level(level) {
        return log_level > 0 ? log_level > level : log_methods.length + log_level <= level;
    }
    for (var callback_func, callback_force, window = this, // Some convenient shortcuts.
    aps = Array.prototype.slice, con = window.console, // Public object to be returned.
    that = {}, // Default logging level, show everything.
    log_level = 9, // Logging methods, in "priority order". Not all console implementations
    // will utilize these, but they will be used in the callback passed to
    // setCallback.
    log_methods = [ "error", "warn", "info", "debug", "log" ], // Pass these methods through to the console if they exist, otherwise just
    // fail gracefully. These methods are provided for convenience.
    pass_methods = "assert clear count dir dirxml exception group groupCollapsed groupEnd profile profileEnd table time timeEnd trace".split(" "), idx = pass_methods.length, // Logs are stored here so that they can be recalled as necessary.
    logs = []; --idx >= 0; ) !function(method) {
        // Generate pass-through methods. These methods will be called, if they
        // exist, as long as the logging level is non-zero.
        that[method] = function() {
            0 !== log_level && con && con[method] && con[method].apply(con, arguments);
        };
    }(pass_methods[idx]);
    for (idx = log_methods.length; --idx >= 0; ) !function(idx, level) {
        // Method: debug.log
        // 
        // Call the console.log method if available. Adds an entry into the logs
        // array for a callback specified via <debug.setCallback>.
        // 
        // Usage:
        // 
        //  debug.log( object [, object, ...] );                               - -
        // 
        // Arguments:
        // 
        //  object - (Object) Any valid JavaScript object.
        // Method: debug.debug
        // 
        // Call the console.debug method if available, otherwise call console.log.
        // Adds an entry into the logs array for a callback specified via
        // <debug.setCallback>.
        // 
        // Usage:
        // 
        //  debug.debug( object [, object, ...] );                             - -
        // 
        // Arguments:
        // 
        //  object - (Object) Any valid JavaScript object.
        // Method: debug.info
        // 
        // Call the console.info method if available, otherwise call console.log.
        // Adds an entry into the logs array for a callback specified via
        // <debug.setCallback>.
        // 
        // Usage:
        // 
        //  debug.info( object [, object, ...] );                              - -
        // 
        // Arguments:
        // 
        //  object - (Object) Any valid JavaScript object.
        // Method: debug.warn
        // 
        // Call the console.warn method if available, otherwise call console.log.
        // Adds an entry into the logs array for a callback specified via
        // <debug.setCallback>.
        // 
        // Usage:
        // 
        //  debug.warn( object [, object, ...] );                              - -
        // 
        // Arguments:
        // 
        //  object - (Object) Any valid JavaScript object.
        // Method: debug.error
        // 
        // Call the console.error method if available, otherwise call console.log.
        // Adds an entry into the logs array for a callback specified via
        // <debug.setCallback>.
        // 
        // Usage:
        // 
        //  debug.error( object [, object, ...] );                             - -
        // 
        // Arguments:
        // 
        //  object - (Object) Any valid JavaScript object.
        that[level] = function() {
            var args = aps.call(arguments), log_arr = [ level ].concat(args);
            logs.push(log_arr), exec_callback(log_arr), con && is_level(idx) && (con.firebug ? con[level].apply(window, args) : con[level] ? con[level](args) : con.log(args));
        };
    }(idx, log_methods[idx]);
    // Method: debug.setLevel
    // 
    // Set a minimum or maximum logging level for the console. Doesn't affect
    // the <debug.setCallback> callback function, but if set to 0 to disable
    // logging, <Pass-through console methods> will be disabled as well.
    // 
    // Usage:
    // 
    //  debug.setLevel( [ level ] )                                            - -
    // 
    // Arguments:
    // 
    //  level - (Number) If 0, disables logging. If negative, shows N lowest
    //    priority levels of log messages. If positive, shows N highest priority
    //    levels of log messages.
    //
    // Priority levels:
    // 
    //   log (1) < debug (2) < info (3) < warn (4) < error (5)
    // Method: debug.setCallback
    // 
    // Set a callback to be used if logging isn't possible due to console.log
    // not existing. If unlogged logs exist when callback is set, they will all
    // be logged immediately unless a limit is specified.
    // 
    // Usage:
    // 
    //  debug.setCallback( callback [, force ] [, limit ] )
    // 
    // Arguments:
    // 
    //  callback - (Function) The aforementioned callback function. The first
    //    argument is the logging level, and all subsequent arguments are those
    //    passed to the initial debug logging method.
    //  force - (Boolean) If false, log to console.log if available, otherwise
    //    callback. If true, log to both console.log and callback.
    //  limit - (Number) If specified, number of lines to limit initial scrollback
    //    to.
    return that.setLevel = function(level) {
        log_level = "number" == typeof level ? level : 9;
    }, that.setCallback = function() {
        var args = aps.call(arguments), max = logs.length, i = max;
        for (callback_func = args.shift() || null, callback_force = "boolean" == typeof args[0] ? args.shift() : !1, 
        i -= "number" == typeof args[0] ? args.shift() : max; max > i; ) exec_callback(logs[i++]);
    }, that;
}(), /** @license
 *
 * SoundManager 2: JavaScript Sound for the Web
 * ----------------------------------------------
 * http://schillmania.com/projects/soundmanager2/
 *
 * Copyright (c) 2007, Scott Schiller. All rights reserved.
 * Code provided under the BSD License:
 * http://schillmania.com/projects/soundmanager2/license.txt
 *
 * V2.97a.20140901
 */
/*global window, SM2_DEFER, sm2Debugger, console, document, navigator, setTimeout, setInterval, clearInterval, Audio, opera, module, define */
/*jslint regexp: true, sloppy: true, white: true, nomen: true, plusplus: true, todo: true */
function(window, _undefined) {
    "use strict";
    function SoundManager(smURL, smID) {
        function preferFlashCheck(kind) {
            return sm2.preferFlash && hasFlash && !sm2.ignoreFlash && sm2.flash[kind] !== _undefined && sm2.flash[kind];
        }
        function html5_event(oFn) {
            return function(e) {
                var result, s = this._s;
                return result = s && s._a ? oFn.call(this, e) : null;
            };
        }
        this.setupOptions = {
            url: smURL || null,
            flashVersion: 8,
            debugMode: !0,
            debugFlash: !1,
            useConsole: !0,
            consoleOnly: !0,
            waitForWindowLoad: !1,
            bgColor: "#ffffff",
            useHighPerformance: !1,
            flashPollingInterval: null,
            html5PollingInterval: null,
            flashLoadTimeout: 1e3,
            wmode: null,
            allowScriptAccess: "always",
            useFlashBlock: !1,
            useHTML5Audio: !0,
            html5Test: /^(probably|maybe)$/i,
            preferFlash: !1,
            noSWFCache: !1,
            idPrefix: "sound"
        }, this.defaultOptions = {
            autoLoad: !1,
            autoPlay: !1,
            from: null,
            loops: 1,
            onid3: null,
            onload: null,
            whileloading: null,
            onplay: null,
            onpause: null,
            onresume: null,
            whileplaying: null,
            onposition: null,
            onstop: null,
            onfailure: null,
            onfinish: null,
            multiShot: !0,
            multiShotEvents: !1,
            position: null,
            pan: 0,
            stream: !0,
            to: null,
            type: null,
            usePolicyFile: !1,
            volume: 100
        }, this.flash9Options = {
            isMovieStar: null,
            usePeakData: !1,
            useWaveformData: !1,
            useEQData: !1,
            onbufferchange: null,
            ondataerror: null
        }, this.movieStarOptions = {
            bufferTime: 3,
            serverURL: null,
            onconnect: null,
            duration: null
        }, this.audioFormats = {
            mp3: {
                type: [ 'audio/mpeg; codecs="mp3"', "audio/mpeg", "audio/mp3", "audio/MPA", "audio/mpa-robust" ],
                required: !0
            },
            mp4: {
                related: [ "aac", "m4a", "m4b" ],
                type: [ 'audio/mp4; codecs="mp4a.40.2"', "audio/aac", "audio/x-m4a", "audio/MP4A-LATM", "audio/mpeg4-generic" ],
                required: !1
            },
            ogg: {
                type: [ "audio/ogg; codecs=vorbis" ],
                required: !1
            },
            opus: {
                type: [ "audio/ogg; codecs=opus", "audio/opus" ],
                required: !1
            },
            wav: {
                type: [ 'audio/wav; codecs="1"', "audio/wav", "audio/wave", "audio/x-wav" ],
                required: !1
            }
        }, this.movieID = "sm2-container", this.id = smID || "sm2movie", this.debugID = "soundmanager-debug", 
        this.debugURLParam = /([#?&])debug=1/i, this.versionNumber = "V2.97a.20140901", 
        this.version = null, this.movieURL = null, this.altURL = null, this.swfLoaded = !1, 
        this.enabled = !1, this.oMC = null, this.sounds = {}, this.soundIDs = [], this.muted = !1, 
        this.didFlashBlock = !1, this.filePattern = null, this.filePatterns = {
            flash8: /\.mp3(\?.*)?$/i,
            flash9: /\.mp3(\?.*)?$/i
        }, this.features = {
            buffering: !1,
            peakData: !1,
            waveformData: !1,
            eqData: !1,
            movieStar: !1
        }, this.sandbox = {}, this.html5 = {
            usingFlash: null
        }, this.flash = {}, this.html5Only = !1, this.ignoreFlash = !1;
        var SMSound, id, doNothing, setProperties, init, fV, initComplete, mixin, assign, extraOptions, addOnEvent, processOnEvents, initUserOnload, delayWaitForEI, waitForEI, rebootIntoHTML5, setVersionInfo, handleFocus, strings, initMovie, preInit, domContentLoaded, winOnLoad, didDCLoaded, getDocument, createMovie, catchError, setPolling, initDebug, disableObject, failSafely, normalizeMovieURL, str, flashBlockHandler, getSWFCSS, swfCSS, loopFix, policyFix, complain, idCheck, startTimer, stopTimer, timerExecute, parseURL, canIgnoreFlash, featureCheck, html5OK, html5CanPlay, html5Ext, html5Unload, domContentLoadedIE, testHTML5, event, lastGlobalHTML5URL, hasFlash, detectFlash, badSafariFix, html5_events, showSupport, flushMessages, wrapCallback, sm2 = this, globalHTML5Audio = null, flash = null, ua = navigator.userAgent, wl = window.location.href.toString(), doc = document, on_queue = [], didAppend = !1, appendSuccess = !1, didInit = !1, disabled = !1, windowLoaded = !1, defaultFlashVersion = 8, oRemoved = null, oRemovedHTML = null, waitingForEI = !1, initPending = !1, h5TimerCount = 0, h5IntervalTimer = null, messages = [], needsFlash = null, slice = Array.prototype.slice, useGlobalHTML5Audio = !1, idCounter = 0, is_iDevice = ua.match(/(ipad|iphone|ipod)/i), isAndroid = ua.match(/android/i), isIE = ua.match(/msie/i), isWebkit = ua.match(/webkit/i), isSafari = ua.match(/safari/i) && !ua.match(/chrome/i), isOpera = ua.match(/opera/i), mobileHTML5 = ua.match(/(mobile|pre\/|xoom)/i) || is_iDevice || isAndroid, isBadSafari = !wl.match(/usehtml5audio/i) && !wl.match(/sm2\-ignorebadua/i) && isSafari && !ua.match(/silk/i) && ua.match(/OS X 10_6_([3-7])/i), isFocused = (window.console !== _undefined && console.log !== _undefined, 
        doc.hasFocus !== _undefined ? doc.hasFocus() : null), tryInitOnFocus = isSafari && (doc.hasFocus === _undefined || !doc.hasFocus()), okToDisable = !tryInitOnFocus, flashMIME = /(mp3|mp4|mpa|m4a|m4b)/i, msecScale = 1e3, emptyURL = "about:blank", emptyWAV = "data:audio/wave;base64,/UklGRiYAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQIAAAD//w==", overHTTP = doc.location ? doc.location.protocol.match(/http/i) : null, http = overHTTP ? "" : "http://", netStreamMimeTypes = /^\s*audio\/(?:x-)?(?:mpeg4|aac|flv|mov|mp4||m4v|m4a|m4b|mp4v|3gp|3g2)\s*(?:$|;)/i, netStreamTypes = [ "mpeg4", "aac", "flv", "mov", "mp4", "m4v", "f4v", "m4a", "m4b", "mp4v", "3gp", "3g2" ], netStreamPattern = new RegExp("\\.(" + netStreamTypes.join("|") + ")(\\?.*)?$", "i");
        this.mimePattern = /^\s*audio\/(?:x-)?(?:mp(?:eg|3))\s*(?:$|;)/i, this.useAltURL = !overHTTP, 
        swfCSS = {
            swfBox: "sm2-object-box",
            swfDefault: "movieContainer",
            swfError: "swf_error",
            swfTimedout: "swf_timedout",
            swfLoaded: "swf_loaded",
            swfUnblocked: "swf_unblocked",
            sm2Debug: "sm2_debug",
            highPerf: "high_performance",
            flashDebug: "flash_debug"
        }, this.hasHTML5 = function() {
            try {
                return Audio !== _undefined && (isOpera && opera !== _undefined && opera.version() < 10 ? new Audio(null) : new Audio()).canPlayType !== _undefined;
            } catch (e) {
                return !1;
            }
        }(), this.setup = function(options) {
            var noURL = !sm2.url;
            return options !== _undefined && didInit && needsFlash && sm2.ok() && (options.flashVersion !== _undefined || options.url !== _undefined || options.html5Test !== _undefined), 
            assign(options), options && (noURL && didDCLoaded && options.url !== _undefined && sm2.beginDelayedInit(), 
            didDCLoaded || options.url === _undefined || "complete" !== doc.readyState || setTimeout(domContentLoaded, 1)), 
            sm2;
        }, this.ok = function() {
            return needsFlash ? didInit && !disabled : sm2.useHTML5Audio && sm2.hasHTML5;
        }, this.supported = this.ok, this.getMovie = function(smID) {
            return id(smID) || doc[smID] || window[smID];
        }, this.createSound = function(oOptions, _url) {
            function make() {
                return options = loopFix(options), sm2.sounds[options.id] = new SMSound(options), 
                sm2.soundIDs.push(options.id), sm2.sounds[options.id];
            }
            var cs, options, oSound = null;
            if (!didInit || !sm2.ok()) return !1;
            if (_url !== _undefined && (oOptions = {
                id: oOptions,
                url: _url
            }), options = mixin(oOptions), options.url = parseURL(options.url), void 0 === options.id && (options.id = sm2.setupOptions.idPrefix + idCounter++), 
            idCheck(options.id, !0)) return sm2.sounds[options.id];
            if (html5OK(options)) oSound = make(), oSound._setup_html5(options); else {
                if (sm2.html5Only) return make();
                if (sm2.html5.usingFlash && options.url && options.url.match(/data\:/i)) return make();
                fV > 8 && null === options.isMovieStar && (options.isMovieStar = !!(options.serverURL || (options.type ? options.type.match(netStreamMimeTypes) : !1) || options.url && options.url.match(netStreamPattern))), 
                options = policyFix(options, cs), oSound = make(), 8 === fV ? flash._createSound(options.id, options.loops || 1, options.usePolicyFile) : (flash._createSound(options.id, options.url, options.usePeakData, options.useWaveformData, options.useEQData, options.isMovieStar, options.isMovieStar ? options.bufferTime : !1, options.loops || 1, options.serverURL, options.duration || null, options.autoPlay, !0, options.autoLoad, options.usePolicyFile), 
                options.serverURL || (oSound.connected = !0, options.onconnect && options.onconnect.apply(oSound))), 
                options.serverURL || !options.autoLoad && !options.autoPlay || oSound.load(options);
            }
            return !options.serverURL && options.autoPlay && oSound.play(), oSound;
        }, this.destroySound = function(sID, _bFromSound) {
            if (!idCheck(sID)) return !1;
            var i, oS = sm2.sounds[sID];
            for (oS._iO = {}, oS.stop(), oS.unload(), i = 0; i < sm2.soundIDs.length; i++) if (sm2.soundIDs[i] === sID) {
                sm2.soundIDs.splice(i, 1);
                break;
            }
            return _bFromSound || oS.destruct(!0), oS = null, delete sm2.sounds[sID], !0;
        }, this.load = function(sID, oOptions) {
            return idCheck(sID) ? sm2.sounds[sID].load(oOptions) : !1;
        }, this.unload = function(sID) {
            return idCheck(sID) ? sm2.sounds[sID].unload() : !1;
        }, this.onPosition = function(sID, nPosition, oMethod, oScope) {
            return idCheck(sID) ? sm2.sounds[sID].onposition(nPosition, oMethod, oScope) : !1;
        }, this.onposition = this.onPosition, this.clearOnPosition = function(sID, nPosition, oMethod) {
            return idCheck(sID) ? sm2.sounds[sID].clearOnPosition(nPosition, oMethod) : !1;
        }, this.play = function(sID, oOptions) {
            var result = null, overloaded = oOptions && !(oOptions instanceof Object);
            if (!didInit || !sm2.ok()) return !1;
            if (idCheck(sID, overloaded)) overloaded && (oOptions = {
                url: oOptions
            }); else {
                if (!overloaded) return !1;
                overloaded && (oOptions = {
                    url: oOptions
                }), oOptions && oOptions.url && (oOptions.id = sID, result = sm2.createSound(oOptions).play());
            }
            return null === result && (result = sm2.sounds[sID].play(oOptions)), result;
        }, this.start = this.play, this.setPosition = function(sID, nMsecOffset) {
            return idCheck(sID) ? sm2.sounds[sID].setPosition(nMsecOffset) : !1;
        }, this.stop = function(sID) {
            return idCheck(sID) ? sm2.sounds[sID].stop() : !1;
        }, this.stopAll = function() {
            var oSound;
            for (oSound in sm2.sounds) sm2.sounds.hasOwnProperty(oSound) && sm2.sounds[oSound].stop();
        }, this.pause = function(sID) {
            return idCheck(sID) ? sm2.sounds[sID].pause() : !1;
        }, this.pauseAll = function() {
            var i;
            for (i = sm2.soundIDs.length - 1; i >= 0; i--) sm2.sounds[sm2.soundIDs[i]].pause();
        }, this.resume = function(sID) {
            return idCheck(sID) ? sm2.sounds[sID].resume() : !1;
        }, this.resumeAll = function() {
            var i;
            for (i = sm2.soundIDs.length - 1; i >= 0; i--) sm2.sounds[sm2.soundIDs[i]].resume();
        }, this.togglePause = function(sID) {
            return idCheck(sID) ? sm2.sounds[sID].togglePause() : !1;
        }, this.setPan = function(sID, nPan) {
            return idCheck(sID) ? sm2.sounds[sID].setPan(nPan) : !1;
        }, this.setVolume = function(sID, nVol) {
            return idCheck(sID) ? sm2.sounds[sID].setVolume(nVol) : !1;
        }, this.mute = function(sID) {
            var i = 0;
            if (sID instanceof String && (sID = null), sID) return idCheck(sID) ? sm2.sounds[sID].mute() : !1;
            for (i = sm2.soundIDs.length - 1; i >= 0; i--) sm2.sounds[sm2.soundIDs[i]].mute();
            return sm2.muted = !0, !0;
        }, this.muteAll = function() {
            sm2.mute();
        }, this.unmute = function(sID) {
            var i;
            if (sID instanceof String && (sID = null), sID) return idCheck(sID) ? sm2.sounds[sID].unmute() : !1;
            for (i = sm2.soundIDs.length - 1; i >= 0; i--) sm2.sounds[sm2.soundIDs[i]].unmute();
            return sm2.muted = !1, !0;
        }, this.unmuteAll = function() {
            sm2.unmute();
        }, this.toggleMute = function(sID) {
            return idCheck(sID) ? sm2.sounds[sID].toggleMute() : !1;
        }, this.getMemoryUse = function() {
            var ram = 0;
            return flash && 8 !== fV && (ram = parseInt(flash._getMemoryUse(), 10)), ram;
        }, this.disable = function(bNoDisable) {
            var i;
            if (bNoDisable === _undefined && (bNoDisable = !1), disabled) return !1;
            for (disabled = !0, i = sm2.soundIDs.length - 1; i >= 0; i--) disableObject(sm2.sounds[sm2.soundIDs[i]]);
            return initComplete(bNoDisable), event.remove(window, "load", initUserOnload), !0;
        }, this.canPlayMIME = function(sMIME) {
            var result;
            return sm2.hasHTML5 && (result = html5CanPlay({
                type: sMIME
            })), !result && needsFlash && (result = sMIME && sm2.ok() ? !!((fV > 8 ? sMIME.match(netStreamMimeTypes) : null) || sMIME.match(sm2.mimePattern)) : null), 
            result;
        }, this.canPlayURL = function(sURL) {
            var result;
            return sm2.hasHTML5 && (result = html5CanPlay({
                url: sURL
            })), !result && needsFlash && (result = sURL && sm2.ok() ? !!sURL.match(sm2.filePattern) : null), 
            result;
        }, this.canPlayLink = function(oLink) {
            return oLink.type !== _undefined && oLink.type && sm2.canPlayMIME(oLink.type) ? !0 : sm2.canPlayURL(oLink.href);
        }, this.getSoundById = function(sID) {
            if (!sID) return null;
            var result = sm2.sounds[sID];
            return result;
        }, this.onready = function(oMethod, oScope) {
            var sType = "onready", result = !1;
            if ("function" != typeof oMethod) throw str("needFunction", sType);
            return oScope || (oScope = window), addOnEvent(sType, oMethod, oScope), processOnEvents(), 
            result = !0, result;
        }, this.ontimeout = function(oMethod, oScope) {
            var sType = "ontimeout", result = !1;
            if ("function" != typeof oMethod) throw str("needFunction", sType);
            return oScope || (oScope = window), addOnEvent(sType, oMethod, oScope), processOnEvents({
                type: sType
            }), result = !0, result;
        }, this._writeDebug = function() {
            return !0;
        }, this._wD = this._writeDebug, this._debug = function() {}, this.reboot = function(resetEvents, excludeInit) {
            var i, j, k;
            for (i = sm2.soundIDs.length - 1; i >= 0; i--) sm2.sounds[sm2.soundIDs[i]].destruct();
            if (flash) try {
                isIE && (oRemovedHTML = flash.innerHTML), oRemoved = flash.parentNode.removeChild(flash);
            } catch (e) {}
            if (oRemovedHTML = oRemoved = needsFlash = flash = null, sm2.enabled = didDCLoaded = didInit = waitingForEI = initPending = didAppend = appendSuccess = disabled = useGlobalHTML5Audio = sm2.swfLoaded = !1, 
            sm2.soundIDs = [], sm2.sounds = {}, idCounter = 0, resetEvents) on_queue = []; else for (i in on_queue) if (on_queue.hasOwnProperty(i)) for (j = 0, 
            k = on_queue[i].length; k > j; j++) on_queue[i][j].fired = !1;
            return sm2.html5 = {
                usingFlash: null
            }, sm2.flash = {}, sm2.html5Only = !1, sm2.ignoreFlash = !1, window.setTimeout(function() {
                preInit(), excludeInit || sm2.beginDelayedInit();
            }, 20), sm2;
        }, this.reset = function() {
            return sm2.reboot(!0, !0);
        }, this.getMoviePercent = function() {
            return flash && "PercentLoaded" in flash ? flash.PercentLoaded() : null;
        }, this.beginDelayedInit = function() {
            windowLoaded = !0, domContentLoaded(), setTimeout(function() {
                return initPending ? !1 : (createMovie(), initMovie(), initPending = !0, !0);
            }, 20), delayWaitForEI();
        }, this.destruct = function() {
            sm2.disable(!0);
        }, SMSound = function(oOptions) {
            var resetProperties, add_html5_events, remove_html5_events, stop_html5_timer, start_html5_timer, attachOnPosition, detachOnPosition, applyFromTo, lastHTML5State, urlOmitted, s = this, onplay_called = !1, onPositionItems = [], onPositionFired = 0, lastURL = null;
            lastHTML5State = {
                duration: null,
                time: null
            }, this.id = oOptions.id, this.sID = this.id, this.url = oOptions.url, this.options = mixin(oOptions), 
            this.instanceOptions = this.options, this._iO = this.instanceOptions, this.pan = this.options.pan, 
            this.volume = this.options.volume, this.isHTML5 = !1, this._a = null, urlOmitted = this.url ? !1 : !0, 
            this.id3 = {}, this._debug = function() {}, this.load = function(oOptions) {
                var instanceOptions, oSound = null;
                if (oOptions !== _undefined ? s._iO = mixin(oOptions, s.options) : (oOptions = s.options, 
                s._iO = oOptions, lastURL && lastURL !== s.url && (s._iO.url = s.url, s.url = null)), 
                s._iO.url || (s._iO.url = s.url), s._iO.url = parseURL(s._iO.url), s.instanceOptions = s._iO, 
                instanceOptions = s._iO, !instanceOptions.url && !s.url) return s;
                if (instanceOptions.url === s.url && 0 !== s.readyState && 2 !== s.readyState) return 3 === s.readyState && instanceOptions.onload && wrapCallback(s, function() {
                    instanceOptions.onload.apply(s, [ !!s.duration ]);
                }), s;
                if (s.loaded = !1, s.readyState = 1, s.playState = 0, s.id3 = {}, html5OK(instanceOptions)) oSound = s._setup_html5(instanceOptions), 
                oSound._called_load || (s._html5_canplay = !1, s.url !== instanceOptions.url && (s._a.src = instanceOptions.url, 
                s.setPosition(0)), s._a.autobuffer = "auto", s._a.preload = "auto", s._a._called_load = !0); else {
                    if (sm2.html5Only) return s;
                    if (s._iO.url && s._iO.url.match(/data\:/i)) return s;
                    try {
                        s.isHTML5 = !1, s._iO = policyFix(loopFix(instanceOptions)), s._iO.autoPlay && (s._iO.position || s._iO.from) && (s._iO.autoPlay = !1), 
                        instanceOptions = s._iO, 8 === fV ? flash._load(s.id, instanceOptions.url, instanceOptions.stream, instanceOptions.autoPlay, instanceOptions.usePolicyFile) : flash._load(s.id, instanceOptions.url, !!instanceOptions.stream, !!instanceOptions.autoPlay, instanceOptions.loops || 1, !!instanceOptions.autoLoad, instanceOptions.usePolicyFile);
                    } catch (e) {
                        catchError({
                            type: "SMSOUND_LOAD_JS_EXCEPTION",
                            fatal: !0
                        });
                    }
                }
                return s.url = instanceOptions.url, s;
            }, this.unload = function() {
                return 0 !== s.readyState && (s.isHTML5 ? (stop_html5_timer(), s._a && (s._a.pause(), 
                lastURL = html5Unload(s._a))) : 8 === fV ? flash._unload(s.id, emptyURL) : flash._unload(s.id), 
                resetProperties()), s;
            }, this.destruct = function(_bFromSM) {
                s.isHTML5 ? (stop_html5_timer(), s._a && (s._a.pause(), html5Unload(s._a), useGlobalHTML5Audio || remove_html5_events(), 
                s._a._s = null, s._a = null)) : (s._iO.onfailure = null, flash._destroySound(s.id)), 
                _bFromSM || sm2.destroySound(s.id, !0);
            }, this.play = function(oOptions, _updatePlayState) {
                var allowMulti, a, onready, audioClone, onended, oncanplay, startOK = !0, exit = null;
                if (_updatePlayState = _updatePlayState === _undefined ? !0 : _updatePlayState, 
                oOptions || (oOptions = {}), s.url && (s._iO.url = s.url), s._iO = mixin(s._iO, s.options), 
                s._iO = mixin(oOptions, s._iO), s._iO.url = parseURL(s._iO.url), s.instanceOptions = s._iO, 
                !s.isHTML5 && s._iO.serverURL && !s.connected) return s.getAutoPlay() || s.setAutoPlay(!0), 
                s;
                if (html5OK(s._iO) && (s._setup_html5(s._iO), start_html5_timer()), 1 !== s.playState || s.paused || (allowMulti = s._iO.multiShot, 
                allowMulti || (s.isHTML5 && s.setPosition(s._iO.position), exit = s)), null !== exit) return exit;
                if (oOptions.url && oOptions.url !== s.url && (s.readyState || s.isHTML5 || 8 !== fV || !urlOmitted ? s.load(s._iO) : urlOmitted = !1), 
                s.loaded || (0 === s.readyState ? (s.isHTML5 || sm2.html5Only ? s.isHTML5 ? s.load(s._iO) : exit = s : (s._iO.autoPlay = !0, 
                s.load(s._iO)), s.instanceOptions = s._iO) : 2 === s.readyState && (exit = s)), 
                null !== exit) return exit;
                if (!s.isHTML5 && 9 === fV && s.position > 0 && s.position === s.duration && (oOptions.position = 0), 
                s.paused && s.position >= 0 && (!s._iO.serverURL || s.position > 0)) s.resume(); else {
                    if (s._iO = mixin(oOptions, s._iO), (!s.isHTML5 && null !== s._iO.position && s._iO.position > 0 || null !== s._iO.from && s._iO.from > 0 || null !== s._iO.to) && 0 === s.instanceCount && 0 === s.playState && !s._iO.serverURL) {
                        if (onready = function() {
                            s._iO = mixin(oOptions, s._iO), s.play(s._iO);
                        }, s.isHTML5 && !s._html5_canplay ? (s.load({
                            _oncanplay: onready
                        }), exit = !1) : s.isHTML5 || s.loaded || s.readyState && 2 === s.readyState || (s.load({
                            onload: onready
                        }), exit = !1), null !== exit) return exit;
                        s._iO = applyFromTo();
                    }
                    (!s.instanceCount || s._iO.multiShotEvents || s.isHTML5 && s._iO.multiShot && !useGlobalHTML5Audio || !s.isHTML5 && fV > 8 && !s.getAutoPlay()) && s.instanceCount++, 
                    s._iO.onposition && 0 === s.playState && attachOnPosition(s), s.playState = 1, s.paused = !1, 
                    s.position = s._iO.position === _undefined || isNaN(s._iO.position) ? 0 : s._iO.position, 
                    s.isHTML5 || (s._iO = policyFix(loopFix(s._iO))), s._iO.onplay && _updatePlayState && (s._iO.onplay.apply(s), 
                    onplay_called = !0), s.setVolume(s._iO.volume, !0), s.setPan(s._iO.pan, !0), s.isHTML5 ? s.instanceCount < 2 ? (start_html5_timer(), 
                    a = s._setup_html5(), s.setPosition(s._iO.position), a.play()) : (audioClone = new Audio(s._iO.url), 
                    onended = function() {
                        event.remove(audioClone, "ended", onended), s._onfinish(s), html5Unload(audioClone), 
                        audioClone = null;
                    }, oncanplay = function() {
                        event.remove(audioClone, "canplay", oncanplay);
                        try {
                            audioClone.currentTime = s._iO.position / msecScale;
                        } catch (err) {}
                        audioClone.play();
                    }, event.add(audioClone, "ended", onended), void 0 !== s._iO.volume && (audioClone.volume = Math.max(0, Math.min(1, s._iO.volume / 100))), 
                    s.muted && (audioClone.muted = !0), s._iO.position ? event.add(audioClone, "canplay", oncanplay) : audioClone.play()) : (startOK = flash._start(s.id, s._iO.loops || 1, 9 === fV ? s.position : s.position / msecScale, s._iO.multiShot || !1), 
                    9 !== fV || startOK || s._iO.onplayerror && s._iO.onplayerror.apply(s));
                }
                return s;
            }, this.start = this.play, this.stop = function(bAll) {
                var originalPosition, instanceOptions = s._iO;
                return 1 === s.playState && (s._onbufferchange(0), s._resetOnPosition(0), s.paused = !1, 
                s.isHTML5 || (s.playState = 0), detachOnPosition(), instanceOptions.to && s.clearOnPosition(instanceOptions.to), 
                s.isHTML5 ? s._a && (originalPosition = s.position, s.setPosition(0), s.position = originalPosition, 
                s._a.pause(), s.playState = 0, s._onTimer(), stop_html5_timer()) : (flash._stop(s.id, bAll), 
                instanceOptions.serverURL && s.unload()), s.instanceCount = 0, s._iO = {}, instanceOptions.onstop && instanceOptions.onstop.apply(s)), 
                s;
            }, this.setAutoPlay = function(autoPlay) {
                s._iO.autoPlay = autoPlay, s.isHTML5 || (flash._setAutoPlay(s.id, autoPlay), autoPlay && (s.instanceCount || 1 !== s.readyState || s.instanceCount++));
            }, this.getAutoPlay = function() {
                return s._iO.autoPlay;
            }, this.setPosition = function(nMsecOffset) {
                nMsecOffset === _undefined && (nMsecOffset = 0);
                var position, position1K, offset = s.isHTML5 ? Math.max(nMsecOffset, 0) : Math.min(s.duration || s._iO.duration, Math.max(nMsecOffset, 0));
                if (s.position = offset, position1K = s.position / msecScale, s._resetOnPosition(s.position), 
                s._iO.position = offset, s.isHTML5) {
                    if (s._a) {
                        if (s._html5_canplay) {
                            if (s._a.currentTime !== position1K) try {
                                s._a.currentTime = position1K, (0 === s.playState || s.paused) && s._a.pause();
                            } catch (e) {}
                        } else if (position1K) return s;
                        s.paused && s._onTimer(!0);
                    }
                } else position = 9 === fV ? s.position : position1K, s.readyState && 2 !== s.readyState && flash._setPosition(s.id, position, s.paused || !s.playState, s._iO.multiShot);
                return s;
            }, this.pause = function(_bCallFlash) {
                return s.paused || 0 === s.playState && 1 !== s.readyState ? s : (s.paused = !0, 
                s.isHTML5 ? (s._setup_html5().pause(), stop_html5_timer()) : (_bCallFlash || _bCallFlash === _undefined) && flash._pause(s.id, s._iO.multiShot), 
                s._iO.onpause && s._iO.onpause.apply(s), s);
            }, this.resume = function() {
                var instanceOptions = s._iO;
                return s.paused ? (s.paused = !1, s.playState = 1, s.isHTML5 ? (s._setup_html5().play(), 
                start_html5_timer()) : (instanceOptions.isMovieStar && !instanceOptions.serverURL && s.setPosition(s.position), 
                flash._pause(s.id, instanceOptions.multiShot)), !onplay_called && instanceOptions.onplay ? (instanceOptions.onplay.apply(s), 
                onplay_called = !0) : instanceOptions.onresume && instanceOptions.onresume.apply(s), 
                s) : s;
            }, this.togglePause = function() {
                return 0 === s.playState ? (s.play({
                    position: 9 !== fV || s.isHTML5 ? s.position / msecScale : s.position
                }), s) : (s.paused ? s.resume() : s.pause(), s);
            }, this.setPan = function(nPan, bInstanceOnly) {
                return nPan === _undefined && (nPan = 0), bInstanceOnly === _undefined && (bInstanceOnly = !1), 
                s.isHTML5 || flash._setPan(s.id, nPan), s._iO.pan = nPan, bInstanceOnly || (s.pan = nPan, 
                s.options.pan = nPan), s;
            }, this.setVolume = function(nVol, _bInstanceOnly) {
                return nVol === _undefined && (nVol = 100), _bInstanceOnly === _undefined && (_bInstanceOnly = !1), 
                s.isHTML5 ? s._a && (sm2.muted && !s.muted && (s.muted = !0, s._a.muted = !0), s._a.volume = Math.max(0, Math.min(1, nVol / 100))) : flash._setVolume(s.id, sm2.muted && !s.muted || s.muted ? 0 : nVol), 
                s._iO.volume = nVol, _bInstanceOnly || (s.volume = nVol, s.options.volume = nVol), 
                s;
            }, this.mute = function() {
                return s.muted = !0, s.isHTML5 ? s._a && (s._a.muted = !0) : flash._setVolume(s.id, 0), 
                s;
            }, this.unmute = function() {
                s.muted = !1;
                var hasIO = s._iO.volume !== _undefined;
                return s.isHTML5 ? s._a && (s._a.muted = !1) : flash._setVolume(s.id, hasIO ? s._iO.volume : s.options.volume), 
                s;
            }, this.toggleMute = function() {
                return s.muted ? s.unmute() : s.mute();
            }, this.onPosition = function(nPosition, oMethod, oScope) {
                return onPositionItems.push({
                    position: parseInt(nPosition, 10),
                    method: oMethod,
                    scope: oScope !== _undefined ? oScope : s,
                    fired: !1
                }), s;
            }, this.onposition = this.onPosition, this.clearOnPosition = function(nPosition, oMethod) {
                var i;
                if (nPosition = parseInt(nPosition, 10), isNaN(nPosition)) return !1;
                for (i = 0; i < onPositionItems.length; i++) nPosition === onPositionItems[i].position && (oMethod && oMethod !== onPositionItems[i].method || (onPositionItems[i].fired && onPositionFired--, 
                onPositionItems.splice(i, 1)));
            }, this._processOnPosition = function() {
                var i, item, j = onPositionItems.length;
                if (!j || !s.playState || onPositionFired >= j) return !1;
                for (i = j - 1; i >= 0; i--) item = onPositionItems[i], !item.fired && s.position >= item.position && (item.fired = !0, 
                onPositionFired++, item.method.apply(item.scope, [ item.position ]), j = onPositionItems.length);
                return !0;
            }, this._resetOnPosition = function(nPosition) {
                var i, item, j = onPositionItems.length;
                if (!j) return !1;
                for (i = j - 1; i >= 0; i--) item = onPositionItems[i], item.fired && nPosition <= item.position && (item.fired = !1, 
                onPositionFired--);
                return !0;
            }, applyFromTo = function() {
                var start, end, instanceOptions = s._iO, f = instanceOptions.from, t = instanceOptions.to;
                return end = function() {
                    s.clearOnPosition(t, end), s.stop();
                }, start = function() {
                    null === t || isNaN(t) || s.onPosition(t, end);
                }, null === f || isNaN(f) || (instanceOptions.position = f, instanceOptions.multiShot = !1, 
                start()), instanceOptions;
            }, attachOnPosition = function() {
                var item, op = s._iO.onposition;
                if (op) for (item in op) op.hasOwnProperty(item) && s.onPosition(parseInt(item, 10), op[item]);
            }, detachOnPosition = function() {
                var item, op = s._iO.onposition;
                if (op) for (item in op) op.hasOwnProperty(item) && s.clearOnPosition(parseInt(item, 10));
            }, start_html5_timer = function() {
                s.isHTML5 && startTimer(s);
            }, stop_html5_timer = function() {
                s.isHTML5 && stopTimer(s);
            }, resetProperties = function(retainPosition) {
                retainPosition || (onPositionItems = [], onPositionFired = 0), onplay_called = !1, 
                s._hasTimer = null, s._a = null, s._html5_canplay = !1, s.bytesLoaded = null, s.bytesTotal = null, 
                s.duration = s._iO && s._iO.duration ? s._iO.duration : null, s.durationEstimate = null, 
                s.buffered = [], s.eqData = [], s.eqData.left = [], s.eqData.right = [], s.failures = 0, 
                s.isBuffering = !1, s.instanceOptions = {}, s.instanceCount = 0, s.loaded = !1, 
                s.metadata = {}, s.readyState = 0, s.muted = !1, s.paused = !1, s.peakData = {
                    left: 0,
                    right: 0
                }, s.waveformData = {
                    left: [],
                    right: []
                }, s.playState = 0, s.position = null, s.id3 = {};
            }, resetProperties(), this._onTimer = function(bForce) {
                var duration, time, isNew = !1, x = {};
                return s._hasTimer || bForce ? (s._a && (bForce || (s.playState > 0 || 1 === s.readyState) && !s.paused) && (duration = s._get_html5_duration(), 
                duration !== lastHTML5State.duration && (lastHTML5State.duration = duration, s.duration = duration, 
                isNew = !0), s.durationEstimate = s.duration, time = s._a.currentTime * msecScale || 0, 
                time !== lastHTML5State.time && (lastHTML5State.time = time, isNew = !0), (isNew || bForce) && s._whileplaying(time, x, x, x, x)), 
                isNew) : void 0;
            }, this._get_html5_duration = function() {
                var instanceOptions = s._iO, d = s._a && s._a.duration ? s._a.duration * msecScale : instanceOptions && instanceOptions.duration ? instanceOptions.duration : null, result = d && !isNaN(d) && 1/0 !== d ? d : null;
                return result;
            }, this._apply_loop = function(a, nLoops) {
                a.loop = nLoops > 1 ? "loop" : "";
            }, this._setup_html5 = function(oOptions) {
                var sameURL, instanceOptions = mixin(s._iO, oOptions), a = useGlobalHTML5Audio ? globalHTML5Audio : s._a, dURL = decodeURI(instanceOptions.url);
                if (useGlobalHTML5Audio ? dURL === decodeURI(lastGlobalHTML5URL) && (sameURL = !0) : dURL === decodeURI(lastURL) && (sameURL = !0), 
                a) {
                    if (a._s) if (useGlobalHTML5Audio) a._s && a._s.playState && !sameURL && a._s.stop(); else if (!useGlobalHTML5Audio && dURL === decodeURI(lastURL)) return s._apply_loop(a, instanceOptions.loops), 
                    a;
                    sameURL || (lastURL && resetProperties(!1), a.src = instanceOptions.url, s.url = instanceOptions.url, 
                    lastURL = instanceOptions.url, lastGlobalHTML5URL = instanceOptions.url, a._called_load = !1);
                } else instanceOptions.autoLoad || instanceOptions.autoPlay ? (s._a = new Audio(instanceOptions.url), 
                s._a.load()) : s._a = isOpera && opera.version() < 10 ? new Audio(null) : new Audio(), 
                a = s._a, a._called_load = !1, useGlobalHTML5Audio && (globalHTML5Audio = a);
                return s.isHTML5 = !0, s._a = a, a._s = s, add_html5_events(), s._apply_loop(a, instanceOptions.loops), 
                instanceOptions.autoLoad || instanceOptions.autoPlay ? s.load() : (a.autobuffer = !1, 
                a.preload = "auto"), a;
            }, add_html5_events = function() {
                function add(oEvt, oFn, bCapture) {
                    return s._a ? s._a.addEventListener(oEvt, oFn, bCapture || !1) : null;
                }
                if (s._a._added_events) return !1;
                var f;
                s._a._added_events = !0;
                for (f in html5_events) html5_events.hasOwnProperty(f) && add(f, html5_events[f]);
                return !0;
            }, remove_html5_events = function() {
                function remove(oEvt, oFn, bCapture) {
                    return s._a ? s._a.removeEventListener(oEvt, oFn, bCapture || !1) : null;
                }
                var f;
                s._a._added_events = !1;
                for (f in html5_events) html5_events.hasOwnProperty(f) && remove(f, html5_events[f]);
            }, this._onload = function(nSuccess) {
                var loadOK = !!nSuccess || !s.isHTML5 && 8 === fV && s.duration;
                return s.loaded = loadOK, s.readyState = loadOK ? 3 : 2, s._onbufferchange(0), s._iO.onload && wrapCallback(s, function() {
                    s._iO.onload.apply(s, [ loadOK ]);
                }), !0;
            }, this._onbufferchange = function(nIsBuffering) {
                return 0 === s.playState ? !1 : nIsBuffering && s.isBuffering || !nIsBuffering && !s.isBuffering ? !1 : (s.isBuffering = 1 === nIsBuffering, 
                s._iO.onbufferchange && s._iO.onbufferchange.apply(s, [ nIsBuffering ]), !0);
            }, this._onsuspend = function() {
                return s._iO.onsuspend && s._iO.onsuspend.apply(s), !0;
            }, this._onfailure = function(msg, level, code) {
                s.failures++, s._iO.onfailure && 1 === s.failures && s._iO.onfailure(msg, level, code);
            }, this._onwarning = function(msg, level, code) {
                s._iO.onwarning && s._iO.onwarning(msg, level, code);
            }, this._onfinish = function() {
                var io_onfinish = s._iO.onfinish;
                s._onbufferchange(0), s._resetOnPosition(0), s.instanceCount && (s.instanceCount--, 
                s.instanceCount || (detachOnPosition(), s.playState = 0, s.paused = !1, s.instanceCount = 0, 
                s.instanceOptions = {}, s._iO = {}, stop_html5_timer(), s.isHTML5 && (s.position = 0)), 
                (!s.instanceCount || s._iO.multiShotEvents) && io_onfinish && wrapCallback(s, function() {
                    io_onfinish.apply(s);
                }));
            }, this._whileloading = function(nBytesLoaded, nBytesTotal, nDuration, nBufferLength) {
                var instanceOptions = s._iO;
                s.bytesLoaded = nBytesLoaded, s.bytesTotal = nBytesTotal, s.duration = Math.floor(nDuration), 
                s.bufferLength = nBufferLength, s.durationEstimate = s.isHTML5 || instanceOptions.isMovieStar ? s.duration : instanceOptions.duration ? s.duration > instanceOptions.duration ? s.duration : instanceOptions.duration : parseInt(s.bytesTotal / s.bytesLoaded * s.duration, 10), 
                s.isHTML5 || (s.buffered = [ {
                    start: 0,
                    end: s.duration
                } ]), (3 !== s.readyState || s.isHTML5) && instanceOptions.whileloading && instanceOptions.whileloading.apply(s);
            }, this._whileplaying = function(nPosition, oPeakData, oWaveformDataLeft, oWaveformDataRight, oEQData) {
                var eqLeft, instanceOptions = s._iO;
                return isNaN(nPosition) || null === nPosition ? !1 : (s.position = Math.max(0, nPosition), 
                s._processOnPosition(), !s.isHTML5 && fV > 8 && (instanceOptions.usePeakData && oPeakData !== _undefined && oPeakData && (s.peakData = {
                    left: oPeakData.leftPeak,
                    right: oPeakData.rightPeak
                }), instanceOptions.useWaveformData && oWaveformDataLeft !== _undefined && oWaveformDataLeft && (s.waveformData = {
                    left: oWaveformDataLeft.split(","),
                    right: oWaveformDataRight.split(",")
                }), instanceOptions.useEQData && oEQData !== _undefined && oEQData && oEQData.leftEQ && (eqLeft = oEQData.leftEQ.split(","), 
                s.eqData = eqLeft, s.eqData.left = eqLeft, oEQData.rightEQ !== _undefined && oEQData.rightEQ && (s.eqData.right = oEQData.rightEQ.split(",")))), 
                1 === s.playState && (s.isHTML5 || 8 !== fV || s.position || !s.isBuffering || s._onbufferchange(0), 
                instanceOptions.whileplaying && instanceOptions.whileplaying.apply(s)), !0);
            }, this._oncaptiondata = function(oData) {
                s.captiondata = oData, s._iO.oncaptiondata && s._iO.oncaptiondata.apply(s, [ oData ]);
            }, this._onmetadata = function(oMDProps, oMDData) {
                var i, j, oData = {};
                for (i = 0, j = oMDProps.length; j > i; i++) oData[oMDProps[i]] = oMDData[i];
                s.metadata = oData, console.log("updated metadata", s.metadata), s._iO.onmetadata && s._iO.onmetadata.call(s, s.metadata);
            }, this._onid3 = function(oID3Props, oID3Data) {
                var i, j, oData = [];
                for (i = 0, j = oID3Props.length; j > i; i++) oData[oID3Props[i]] = oID3Data[i];
                s.id3 = mixin(s.id3, oData), s._iO.onid3 && s._iO.onid3.apply(s);
            }, this._onconnect = function(bSuccess) {
                bSuccess = 1 === bSuccess, s.connected = bSuccess, bSuccess && (s.failures = 0, 
                idCheck(s.id) && (s.getAutoPlay() ? s.play(_undefined, s.getAutoPlay()) : s._iO.autoLoad && s.load()), 
                s._iO.onconnect && s._iO.onconnect.apply(s, [ bSuccess ]));
            }, this._ondataerror = function() {
                s.playState > 0 && s._iO.ondataerror && s._iO.ondataerror.apply(s);
            };
        }, getDocument = function() {
            return doc.body || doc.getElementsByTagName("div")[0];
        }, id = function(sID) {
            return doc.getElementById(sID);
        }, mixin = function(oMain, oAdd) {
            var o2, o, o1 = oMain || {};
            o2 = oAdd === _undefined ? sm2.defaultOptions : oAdd;
            for (o in o2) o2.hasOwnProperty(o) && o1[o] === _undefined && (o1[o] = "object" != typeof o2[o] || null === o2[o] ? o2[o] : mixin(o1[o], o2[o]));
            return o1;
        }, wrapCallback = function(oSound, callback) {
            oSound.isHTML5 || 8 !== fV ? callback() : window.setTimeout(callback, 0);
        }, extraOptions = {
            onready: 1,
            ontimeout: 1,
            defaultOptions: 1,
            flash9Options: 1,
            movieStarOptions: 1
        }, assign = function(o, oParent) {
            var i, result = !0, hasParent = oParent !== _undefined, setupOptions = sm2.setupOptions, bonusOptions = extraOptions;
            for (i in o) if (o.hasOwnProperty(i)) if ("object" != typeof o[i] || null === o[i] || o[i] instanceof Array || o[i] instanceof RegExp) hasParent && bonusOptions[oParent] !== _undefined ? sm2[oParent][i] = o[i] : setupOptions[i] !== _undefined ? (sm2.setupOptions[i] = o[i], 
            sm2[i] = o[i]) : bonusOptions[i] === _undefined ? result = !1 : sm2[i] instanceof Function ? sm2[i].apply(sm2, o[i] instanceof Array ? o[i] : [ o[i] ]) : sm2[i] = o[i]; else {
                if (bonusOptions[i] !== _undefined) return assign(o[i], i);
                result = !1;
            }
            return result;
        }, event = function() {
            function getArgs(oArgs) {
                var args = slice.call(oArgs), len = args.length;
                return old ? (args[1] = "on" + args[1], len > 3 && args.pop()) : 3 === len && args.push(!1), 
                args;
            }
            function apply(args, sType) {
                var element = args.shift(), method = [ evt[sType] ];
                old ? element[method](args[0], args[1]) : element[method].apply(element, args);
            }
            function add() {
                apply(getArgs(arguments), "add");
            }
            function remove() {
                apply(getArgs(arguments), "remove");
            }
            var old = window.attachEvent, evt = {
                add: old ? "attachEvent" : "addEventListener",
                remove: old ? "detachEvent" : "removeEventListener"
            };
            return {
                add: add,
                remove: remove
            };
        }(), html5_events = {
            abort: html5_event(function() {}),
            canplay: html5_event(function() {
                var position1K, s = this._s;
                if (s._html5_canplay) return !0;
                if (s._html5_canplay = !0, s._onbufferchange(0), position1K = s._iO.position === _undefined || isNaN(s._iO.position) ? null : s._iO.position / msecScale, 
                this.currentTime !== position1K) try {
                    this.currentTime = position1K;
                } catch (ee) {}
                s._iO._oncanplay && s._iO._oncanplay();
            }),
            canplaythrough: html5_event(function() {
                var s = this._s;
                s.loaded || (s._onbufferchange(0), s._whileloading(s.bytesLoaded, s.bytesTotal, s._get_html5_duration()), 
                s._onload(!0));
            }),
            durationchange: html5_event(function() {
                var duration, s = this._s;
                duration = s._get_html5_duration(), isNaN(duration) || duration === s.duration || (s.durationEstimate = s.duration = duration);
            }),
            ended: html5_event(function() {
                var s = this._s;
                s._onfinish();
            }),
            error: html5_event(function() {
                this._s._onload(!1);
            }),
            loadeddata: html5_event(function() {
                var s = this._s;
                s._loaded || isSafari || (s.duration = s._get_html5_duration());
            }),
            loadedmetadata: html5_event(function() {}),
            loadstart: html5_event(function() {
                this._s._onbufferchange(1);
            }),
            play: html5_event(function() {
                this._s._onbufferchange(0);
            }),
            playing: html5_event(function() {
                this._s._onbufferchange(0);
            }),
            progress: html5_event(function(e) {
                var i, j, s = this._s, buffered = 0, ranges = ("progress" === e.type, e.target.buffered), loaded = e.loaded || 0, total = e.total || 1;
                if (s.buffered = [], ranges && ranges.length) {
                    for (i = 0, j = ranges.length; j > i; i++) s.buffered.push({
                        start: ranges.start(i) * msecScale,
                        end: ranges.end(i) * msecScale
                    });
                    buffered = (ranges.end(0) - ranges.start(0)) * msecScale, loaded = Math.min(1, buffered / (e.target.duration * msecScale));
                }
                isNaN(loaded) || (s._whileloading(loaded, total, s._get_html5_duration()), loaded && total && loaded === total && html5_events.canplaythrough.call(this, e));
            }),
            ratechange: html5_event(function() {}),
            suspend: html5_event(function(e) {
                var s = this._s;
                html5_events.progress.call(this, e), s._onsuspend();
            }),
            stalled: html5_event(function() {}),
            timeupdate: html5_event(function() {
                this._s._onTimer();
            }),
            waiting: html5_event(function() {
                var s = this._s;
                s._onbufferchange(1);
            })
        }, html5OK = function(iO) {
            var result;
            return result = iO && (iO.type || iO.url || iO.serverURL) ? iO.serverURL || iO.type && preferFlashCheck(iO.type) ? !1 : iO.type ? html5CanPlay({
                type: iO.type
            }) : html5CanPlay({
                url: iO.url
            }) || sm2.html5Only || iO.url.match(/data\:/i) : !1;
        }, html5Unload = function(oAudio) {
            var url;
            return oAudio && (url = isSafari ? emptyURL : sm2.html5.canPlayType("audio/wav") ? emptyWAV : emptyURL, 
            oAudio.src = url, void 0 !== oAudio._called_unload && (oAudio._called_load = !1)), 
            useGlobalHTML5Audio && (lastGlobalHTML5URL = null), url;
        }, html5CanPlay = function(o) {
            if (!sm2.useHTML5Audio || !sm2.hasHTML5) return !1;
            var result, offset, fileExt, item, url = o.url || null, mime = o.type || null, aF = sm2.audioFormats;
            if (mime && sm2.html5[mime] !== _undefined) return sm2.html5[mime] && !preferFlashCheck(mime);
            if (!html5Ext) {
                html5Ext = [];
                for (item in aF) aF.hasOwnProperty(item) && (html5Ext.push(item), aF[item].related && (html5Ext = html5Ext.concat(aF[item].related)));
                html5Ext = new RegExp("\\.(" + html5Ext.join("|") + ")(\\?.*)?$", "i");
            }
            return fileExt = url ? url.toLowerCase().match(html5Ext) : null, fileExt && fileExt.length ? fileExt = fileExt[1] : mime ? (offset = mime.indexOf(";"), 
            fileExt = (-1 !== offset ? mime.substr(0, offset) : mime).substr(6)) : result = !1, 
            fileExt && sm2.html5[fileExt] !== _undefined ? result = sm2.html5[fileExt] && !preferFlashCheck(fileExt) : (mime = "audio/" + fileExt, 
            result = sm2.html5.canPlayType({
                type: mime
            }), sm2.html5[fileExt] = result, result = result && sm2.html5[mime] && !preferFlashCheck(mime)), 
            result;
        }, testHTML5 = function() {
            function cp(m) {
                var canPlay, j, result = !1, isOK = !1;
                if (!a || "function" != typeof a.canPlayType) return result;
                if (m instanceof Array) {
                    for (i = 0, j = m.length; j > i; i++) (sm2.html5[m[i]] || a.canPlayType(m[i]).match(sm2.html5Test)) && (isOK = !0, 
                    sm2.html5[m[i]] = !0, sm2.flash[m[i]] = !!m[i].match(flashMIME));
                    result = isOK;
                } else canPlay = a && "function" == typeof a.canPlayType ? a.canPlayType(m) : !1, 
                result = !(!canPlay || !canPlay.match(sm2.html5Test));
                return result;
            }
            if (!sm2.useHTML5Audio || !sm2.hasHTML5) return sm2.html5.usingFlash = !0, needsFlash = !0, 
            !1;
            var item, lookup, aF, i, a = Audio !== _undefined ? isOpera && opera.version() < 10 ? new Audio(null) : new Audio() : null, support = {};
            aF = sm2.audioFormats;
            for (item in aF) if (aF.hasOwnProperty(item) && (lookup = "audio/" + item, support[item] = cp(aF[item].type), 
            support[lookup] = support[item], item.match(flashMIME) ? (sm2.flash[item] = !0, 
            sm2.flash[lookup] = !0) : (sm2.flash[item] = !1, sm2.flash[lookup] = !1), aF[item] && aF[item].related)) for (i = aF[item].related.length - 1; i >= 0; i--) support["audio/" + aF[item].related[i]] = support[item], 
            sm2.html5[aF[item].related[i]] = support[item], sm2.flash[aF[item].related[i]] = support[item];
            return support.canPlayType = a ? cp : null, sm2.html5 = mixin(sm2.html5, support), 
            sm2.html5.usingFlash = featureCheck(), needsFlash = sm2.html5.usingFlash, !0;
        }, strings = {}, str = function() {}, loopFix = function(sOpt) {
            return 8 === fV && sOpt.loops > 1 && sOpt.stream && (sOpt.stream = !1), sOpt;
        }, policyFix = function(sOpt) {
            return sOpt && !sOpt.usePolicyFile && (sOpt.onid3 || sOpt.usePeakData || sOpt.useWaveformData || sOpt.useEQData) && (sOpt.usePolicyFile = !0), 
            sOpt;
        }, complain = function() {}, doNothing = function() {
            return !1;
        }, disableObject = function(o) {
            var oProp;
            for (oProp in o) o.hasOwnProperty(oProp) && "function" == typeof o[oProp] && (o[oProp] = doNothing);
            oProp = null;
        }, failSafely = function(bNoDisable) {
            bNoDisable === _undefined && (bNoDisable = !1), (disabled || bNoDisable) && sm2.disable(bNoDisable);
        }, normalizeMovieURL = function(smURL) {
            var url, urlParams = null;
            if (smURL) if (smURL.match(/\.swf(\?.*)?$/i)) {
                if (urlParams = smURL.substr(smURL.toLowerCase().lastIndexOf(".swf?") + 4)) return smURL;
            } else smURL.lastIndexOf("/") !== smURL.length - 1 && (smURL += "/");
            return url = (smURL && -1 !== smURL.lastIndexOf("/") ? smURL.substr(0, smURL.lastIndexOf("/") + 1) : "./") + sm2.movieURL, 
            sm2.noSWFCache && (url += "?ts=" + new Date().getTime()), url;
        }, setVersionInfo = function() {
            fV = parseInt(sm2.flashVersion, 10), 8 !== fV && 9 !== fV && (sm2.flashVersion = fV = defaultFlashVersion);
            var isDebug = sm2.debugMode || sm2.debugFlash ? "_debug.swf" : ".swf";
            sm2.useHTML5Audio && !sm2.html5Only && sm2.audioFormats.mp4.required && 9 > fV && (sm2.flashVersion = fV = 9), 
            sm2.version = sm2.versionNumber + (sm2.html5Only ? " (HTML5-only mode)" : 9 === fV ? " (AS3/Flash 9)" : " (AS2/Flash 8)"), 
            fV > 8 ? (sm2.defaultOptions = mixin(sm2.defaultOptions, sm2.flash9Options), sm2.features.buffering = !0, 
            sm2.defaultOptions = mixin(sm2.defaultOptions, sm2.movieStarOptions), sm2.filePatterns.flash9 = new RegExp("\\.(mp3|" + netStreamTypes.join("|") + ")(\\?.*)?$", "i"), 
            sm2.features.movieStar = !0) : sm2.features.movieStar = !1, sm2.filePattern = sm2.filePatterns[8 !== fV ? "flash9" : "flash8"], 
            sm2.movieURL = (8 === fV ? "soundmanager2.swf" : "soundmanager2_flash9.swf").replace(".swf", isDebug), 
            sm2.features.peakData = sm2.features.waveformData = sm2.features.eqData = fV > 8;
        }, setPolling = function(bPolling, bHighPerformance) {
            return flash ? void flash._setPolling(bPolling, bHighPerformance) : !1;
        }, initDebug = function() {}, idCheck = this.getSoundById, getSWFCSS = function() {
            var css = [];
            return sm2.debugMode && css.push(swfCSS.sm2Debug), sm2.debugFlash && css.push(swfCSS.flashDebug), 
            sm2.useHighPerformance && css.push(swfCSS.highPerf), css.join(" ");
        }, flashBlockHandler = function() {
            var p = (str("fbHandler"), sm2.getMoviePercent()), css = swfCSS, error = {
                type: "FLASHBLOCK"
            };
            return sm2.html5Only ? !1 : void (sm2.ok() ? sm2.oMC && (sm2.oMC.className = [ getSWFCSS(), css.swfDefault, css.swfLoaded + (sm2.didFlashBlock ? " " + css.swfUnblocked : "") ].join(" ")) : (needsFlash && (sm2.oMC.className = getSWFCSS() + " " + css.swfDefault + " " + (null === p ? css.swfTimedout : css.swfError)), 
            sm2.didFlashBlock = !0, processOnEvents({
                type: "ontimeout",
                ignoreInit: !0,
                error: error
            }), catchError(error)));
        }, addOnEvent = function(sType, oMethod, oScope) {
            on_queue[sType] === _undefined && (on_queue[sType] = []), on_queue[sType].push({
                method: oMethod,
                scope: oScope || null,
                fired: !1
            });
        }, processOnEvents = function(oOptions) {
            if (oOptions || (oOptions = {
                type: sm2.ok() ? "onready" : "ontimeout"
            }), !didInit && oOptions && !oOptions.ignoreInit) return !1;
            if ("ontimeout" === oOptions.type && (sm2.ok() || disabled && !oOptions.ignoreInit)) return !1;
            var i, j, status = {
                success: oOptions && oOptions.ignoreInit ? sm2.ok() : !disabled
            }, srcQueue = oOptions && oOptions.type ? on_queue[oOptions.type] || [] : [], queue = [], args = [ status ], canRetry = needsFlash && !sm2.ok();
            for (oOptions.error && (args[0].error = oOptions.error), i = 0, j = srcQueue.length; j > i; i++) srcQueue[i].fired !== !0 && queue.push(srcQueue[i]);
            if (queue.length) for (i = 0, j = queue.length; j > i; i++) queue[i].scope ? queue[i].method.apply(queue[i].scope, args) : queue[i].method.apply(this, args), 
            canRetry || (queue[i].fired = !0);
            return !0;
        }, initUserOnload = function() {
            window.setTimeout(function() {
                sm2.useFlashBlock && flashBlockHandler(), processOnEvents(), "function" == typeof sm2.onload && sm2.onload.apply(window), 
                sm2.waitForWindowLoad && event.add(window, "load", initUserOnload);
            }, 1);
        }, detectFlash = function() {
            if (hasFlash !== _undefined) return hasFlash;
            var obj, type, types, hasPlugin = !1, n = navigator, nP = n.plugins, AX = window.ActiveXObject;
            if (nP && nP.length) type = "application/x-shockwave-flash", types = n.mimeTypes, 
            types && types[type] && types[type].enabledPlugin && types[type].enabledPlugin.description && (hasPlugin = !0); else if (AX !== _undefined && !ua.match(/MSAppHost/i)) {
                try {
                    obj = new AX("ShockwaveFlash.ShockwaveFlash");
                } catch (e) {
                    obj = null;
                }
                hasPlugin = !!obj, obj = null;
            }
            return hasFlash = hasPlugin, hasPlugin;
        }, featureCheck = function() {
            var flashNeeded, item, formats = sm2.audioFormats, isSpecial = is_iDevice && !!ua.match(/os (1|2|3_0|3_1)\s/i);
            if (isSpecial ? (sm2.hasHTML5 = !1, sm2.html5Only = !0, sm2.oMC && (sm2.oMC.style.display = "none")) : sm2.useHTML5Audio && (sm2.html5 && sm2.html5.canPlayType || (sm2.hasHTML5 = !1)), 
            sm2.useHTML5Audio && sm2.hasHTML5) {
                canIgnoreFlash = !0;
                for (item in formats) formats.hasOwnProperty(item) && formats[item].required && (sm2.html5.canPlayType(formats[item].type) ? sm2.preferFlash && (sm2.flash[item] || sm2.flash[formats[item].type]) && (flashNeeded = !0) : (canIgnoreFlash = !1, 
                flashNeeded = !0));
            }
            return sm2.ignoreFlash && (flashNeeded = !1, canIgnoreFlash = !0), sm2.html5Only = sm2.hasHTML5 && sm2.useHTML5Audio && !flashNeeded, 
            !sm2.html5Only;
        }, parseURL = function(url) {
            var i, j, result, urlResult = 0;
            if (url instanceof Array) {
                for (i = 0, j = url.length; j > i; i++) if (url[i] instanceof Object) {
                    if (sm2.canPlayMIME(url[i].type)) {
                        urlResult = i;
                        break;
                    }
                } else if (sm2.canPlayURL(url[i])) {
                    urlResult = i;
                    break;
                }
                url[urlResult].url && (url[urlResult] = url[urlResult].url), result = url[urlResult];
            } else result = url;
            return result;
        }, startTimer = function(oSound) {
            oSound._hasTimer || (oSound._hasTimer = !0, !mobileHTML5 && sm2.html5PollingInterval && (null === h5IntervalTimer && 0 === h5TimerCount && (h5IntervalTimer = setInterval(timerExecute, sm2.html5PollingInterval)), 
            h5TimerCount++));
        }, stopTimer = function(oSound) {
            oSound._hasTimer && (oSound._hasTimer = !1, !mobileHTML5 && sm2.html5PollingInterval && h5TimerCount--);
        }, timerExecute = function() {
            var i;
            if (null !== h5IntervalTimer && !h5TimerCount) return clearInterval(h5IntervalTimer), 
            h5IntervalTimer = null, !1;
            for (i = sm2.soundIDs.length - 1; i >= 0; i--) sm2.sounds[sm2.soundIDs[i]].isHTML5 && sm2.sounds[sm2.soundIDs[i]]._hasTimer && sm2.sounds[sm2.soundIDs[i]]._onTimer();
        }, catchError = function(options) {
            options = options !== _undefined ? options : {}, "function" == typeof sm2.onerror && sm2.onerror.apply(window, [ {
                type: options.type !== _undefined ? options.type : null
            } ]), options.fatal !== _undefined && options.fatal && sm2.disable();
        }, badSafariFix = function() {
            if (!isBadSafari || !detectFlash()) return !1;
            var i, item, aF = sm2.audioFormats;
            for (item in aF) if (aF.hasOwnProperty(item) && ("mp3" === item || "mp4" === item) && (sm2.html5[item] = !1, 
            aF[item] && aF[item].related)) for (i = aF[item].related.length - 1; i >= 0; i--) sm2.html5[aF[item].related[i]] = !1;
        }, this._setSandboxType = function() {}, this._externalInterfaceOK = function() {
            if (sm2.swfLoaded) return !1;
            sm2.swfLoaded = !0, tryInitOnFocus = !1, isBadSafari && badSafariFix(), setTimeout(init, isIE ? 100 : 1);
        }, createMovie = function(smID, smURL) {
            function initMsg() {}
            function param(name, value) {
                return '<param name="' + name + '" value="' + value + '" />';
            }
            if (didAppend && appendSuccess) return !1;
            if (sm2.html5Only) return setVersionInfo(), initMsg(), sm2.oMC = id(sm2.movieID), 
            init(), didAppend = !0, appendSuccess = !0, !1;
            var oEmbed, oMovie, tmp, movieHTML, oEl, s, x, sClass, remoteURL = smURL || sm2.url, localURL = sm2.altURL || remoteURL, swfTitle = "JS/Flash audio component (SoundManager 2)", oTarget = getDocument(), extraClass = getSWFCSS(), isRTL = null, html = doc.getElementsByTagName("html")[0];
            if (isRTL = html && html.dir && html.dir.match(/rtl/i), smID = smID === _undefined ? sm2.id : smID, 
            setVersionInfo(), sm2.url = normalizeMovieURL(overHTTP ? remoteURL : localURL), 
            smURL = sm2.url, sm2.wmode = !sm2.wmode && sm2.useHighPerformance ? "transparent" : sm2.wmode, 
            null !== sm2.wmode && (ua.match(/msie 8/i) || !isIE && !sm2.useHighPerformance) && navigator.platform.match(/win32|win64/i) && (messages.push(strings.spcWmode), 
            sm2.wmode = null), oEmbed = {
                name: smID,
                id: smID,
                src: smURL,
                quality: "high",
                allowScriptAccess: sm2.allowScriptAccess,
                bgcolor: sm2.bgColor,
                pluginspage: http + "www.macromedia.com/go/getflashplayer",
                title: swfTitle,
                type: "application/x-shockwave-flash",
                wmode: sm2.wmode,
                hasPriority: "true"
            }, sm2.debugFlash && (oEmbed.FlashVars = "debug=1"), sm2.wmode || delete oEmbed.wmode, 
            isIE) oMovie = doc.createElement("div"), movieHTML = [ '<object id="' + smID + '" data="' + smURL + '" type="' + oEmbed.type + '" title="' + oEmbed.title + '" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="' + http + 'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0">', param("movie", smURL), param("AllowScriptAccess", sm2.allowScriptAccess), param("quality", oEmbed.quality), sm2.wmode ? param("wmode", sm2.wmode) : "", param("bgcolor", sm2.bgColor), param("hasPriority", "true"), sm2.debugFlash ? param("FlashVars", oEmbed.FlashVars) : "", "</object>" ].join(""); else {
                oMovie = doc.createElement("embed");
                for (tmp in oEmbed) oEmbed.hasOwnProperty(tmp) && oMovie.setAttribute(tmp, oEmbed[tmp]);
            }
            if (initDebug(), extraClass = getSWFCSS(), oTarget = getDocument()) if (sm2.oMC = id(sm2.movieID) || doc.createElement("div"), 
            sm2.oMC.id) sClass = sm2.oMC.className, sm2.oMC.className = (sClass ? sClass + " " : swfCSS.swfDefault) + (extraClass ? " " + extraClass : ""), 
            sm2.oMC.appendChild(oMovie), isIE && (oEl = sm2.oMC.appendChild(doc.createElement("div")), 
            oEl.className = swfCSS.swfBox, oEl.innerHTML = movieHTML), appendSuccess = !0; else {
                if (sm2.oMC.id = sm2.movieID, sm2.oMC.className = swfCSS.swfDefault + " " + extraClass, 
                s = null, oEl = null, sm2.useFlashBlock || (sm2.useHighPerformance ? s = {
                    position: "fixed",
                    width: "8px",
                    height: "8px",
                    bottom: "0px",
                    left: "0px",
                    overflow: "hidden"
                } : (s = {
                    position: "absolute",
                    width: "6px",
                    height: "6px",
                    top: "-9999px",
                    left: "-9999px"
                }, isRTL && (s.left = Math.abs(parseInt(s.left, 10)) + "px"))), isWebkit && (sm2.oMC.style.zIndex = 1e4), 
                !sm2.debugFlash) for (x in s) s.hasOwnProperty(x) && (sm2.oMC.style[x] = s[x]);
                try {
                    isIE || sm2.oMC.appendChild(oMovie), oTarget.appendChild(sm2.oMC), isIE && (oEl = sm2.oMC.appendChild(doc.createElement("div")), 
                    oEl.className = swfCSS.swfBox, oEl.innerHTML = movieHTML), appendSuccess = !0;
                } catch (e) {
                    throw new Error(str("domError") + " \n" + e.toString());
                }
            }
            return didAppend = !0, initMsg(), !0;
        }, initMovie = function() {
            return sm2.html5Only ? (createMovie(), !1) : flash ? !1 : sm2.url ? (flash = sm2.getMovie(sm2.id), 
            flash || (oRemoved ? (isIE ? sm2.oMC.innerHTML = oRemovedHTML : sm2.oMC.appendChild(oRemoved), 
            oRemoved = null, didAppend = !0) : createMovie(sm2.id, sm2.url), flash = sm2.getMovie(sm2.id)), 
            "function" == typeof sm2.oninitmovie && setTimeout(sm2.oninitmovie, 1), !0) : !1;
        }, delayWaitForEI = function() {
            setTimeout(waitForEI, 1e3);
        }, rebootIntoHTML5 = function() {
            window.setTimeout(function() {
                sm2.setup({
                    preferFlash: !1
                }).reboot(), sm2.didFlashBlock = !0, sm2.beginDelayedInit();
            }, 1);
        }, waitForEI = function() {
            var p, loadIncomplete = !1;
            return sm2.url ? waitingForEI ? !1 : (waitingForEI = !0, event.remove(window, "load", delayWaitForEI), 
            hasFlash && tryInitOnFocus && !isFocused ? !1 : (didInit || (p = sm2.getMoviePercent(), 
            p > 0 && 100 > p && (loadIncomplete = !0)), void setTimeout(function() {
                return p = sm2.getMoviePercent(), loadIncomplete ? (waitingForEI = !1, window.setTimeout(delayWaitForEI, 1), 
                !1) : void (!didInit && okToDisable && (null === p ? sm2.useFlashBlock || 0 === sm2.flashLoadTimeout ? sm2.useFlashBlock && flashBlockHandler() : !sm2.useFlashBlock && canIgnoreFlash ? rebootIntoHTML5() : processOnEvents({
                    type: "ontimeout",
                    ignoreInit: !0,
                    error: {
                        type: "INIT_FLASHBLOCK"
                    }
                }) : 0 === sm2.flashLoadTimeout || (!sm2.useFlashBlock && canIgnoreFlash ? rebootIntoHTML5() : failSafely(!0))));
            }, sm2.flashLoadTimeout))) : !1;
        }, handleFocus = function() {
            function cleanup() {
                event.remove(window, "focus", handleFocus);
            }
            return isFocused || !tryInitOnFocus ? (cleanup(), !0) : (okToDisable = !0, isFocused = !0, 
            waitingForEI = !1, delayWaitForEI(), cleanup(), !0);
        }, flushMessages = function() {}, showSupport = function() {}, initComplete = function(bNoDisable) {
            if (didInit) return !1;
            if (sm2.html5Only) return didInit = !0, initUserOnload(), !0;
            var error, wasTimeout = sm2.useFlashBlock && sm2.flashLoadTimeout && !sm2.getMoviePercent(), result = !0;
            return wasTimeout || (didInit = !0), error = {
                type: !hasFlash && needsFlash ? "NO_FLASH" : "INIT_TIMEOUT"
            }, (disabled || bNoDisable) && (sm2.useFlashBlock && sm2.oMC && (sm2.oMC.className = getSWFCSS() + " " + (null === sm2.getMoviePercent() ? swfCSS.swfTimedout : swfCSS.swfError)), 
            processOnEvents({
                type: "ontimeout",
                error: error,
                ignoreInit: !0
            }), catchError(error), result = !1), disabled || (sm2.waitForWindowLoad && !windowLoaded ? event.add(window, "load", initUserOnload) : initUserOnload()), 
            result;
        }, setProperties = function() {
            var i, o = sm2.setupOptions;
            for (i in o) o.hasOwnProperty(i) && (sm2[i] === _undefined ? sm2[i] = o[i] : sm2[i] !== o[i] && (sm2.setupOptions[i] = sm2[i]));
        }, init = function() {
            function cleanup() {
                event.remove(window, "load", sm2.beginDelayedInit);
            }
            if (didInit) return !1;
            if (sm2.html5Only) return didInit || (cleanup(), sm2.enabled = !0, initComplete()), 
            !0;
            initMovie();
            try {
                flash._externalInterfaceTest(!1), setPolling(!0, sm2.flashPollingInterval || (sm2.useHighPerformance ? 10 : 50)), 
                sm2.debugMode || flash._disableDebug(), sm2.enabled = !0, sm2.html5Only || event.add(window, "unload", doNothing);
            } catch (e) {
                return catchError({
                    type: "JS_TO_FLASH_EXCEPTION",
                    fatal: !0
                }), failSafely(!0), initComplete(), !1;
            }
            return initComplete(), cleanup(), !0;
        }, domContentLoaded = function() {
            return didDCLoaded ? !1 : (didDCLoaded = !0, setProperties(), initDebug(), !hasFlash && sm2.hasHTML5 && sm2.setup({
                useHTML5Audio: !0,
                preferFlash: !1
            }), testHTML5(), !hasFlash && needsFlash && (messages.push(strings.needFlash), sm2.setup({
                flashLoadTimeout: 1
            })), doc.removeEventListener && doc.removeEventListener("DOMContentLoaded", domContentLoaded, !1), 
            initMovie(), !0);
        }, domContentLoadedIE = function() {
            return "complete" === doc.readyState && (domContentLoaded(), doc.detachEvent("onreadystatechange", domContentLoadedIE)), 
            !0;
        }, winOnLoad = function() {
            windowLoaded = !0, domContentLoaded(), event.remove(window, "load", winOnLoad);
        }, preInit = function() {
            mobileHTML5 && (sm2.setupOptions.useHTML5Audio = !0, sm2.setupOptions.preferFlash = !1, 
            (is_iDevice || isAndroid && !ua.match(/android\s2\.3/i)) && (is_iDevice && (sm2.ignoreFlash = !0), 
            useGlobalHTML5Audio = !0));
        }, preInit(), detectFlash(), event.add(window, "focus", handleFocus), event.add(window, "load", delayWaitForEI), 
        event.add(window, "load", winOnLoad), doc.addEventListener ? doc.addEventListener("DOMContentLoaded", domContentLoaded, !1) : doc.attachEvent ? doc.attachEvent("onreadystatechange", domContentLoadedIE) : catchError({
            type: "NO_DOM2_EVENTS",
            fatal: !0
        });
    }
    if (!window || !window.document) throw new Error("SoundManager requires a browser with window and document objects.");
    var soundManager = null;
    // SM2_DEFER details: http://www.schillmania.com/projects/soundmanager2/doc/getstarted/#lazy-loading
    void 0 !== window.SM2_DEFER && SM2_DEFER || (soundManager = new SoundManager()), 
    "object" == typeof module && module && "object" == typeof module.exports ? (window.soundManager = soundManager, 
    module.exports.SoundManager = SoundManager, module.exports.soundManager = soundManager) : "function" == typeof define && define.amd ? define("SoundManager", [], function() {
        return {
            SoundManager: SoundManager,
            soundManager: soundManager
        };
    }) : (window.SoundManager = SoundManager, window.soundManager = soundManager);
}(window);

/*	SWFObject v2.2 <http://code.google.com/p/swfobject/> 
	is released under the MIT License <http://www.opensource.org/licenses/mit-license.php> 
*/
var swfobject = function() {
    function f() {
        if (!J) {
            try {
                var Z = j.getElementsByTagName("body")[0].appendChild(C("span"));
                Z.parentNode.removeChild(Z);
            } catch (aa) {
                return;
            }
            J = !0;
            for (var X = U.length, Y = 0; X > Y; Y++) U[Y]();
        }
    }
    function K(X) {
        J ? X() : U[U.length] = X;
    }
    function s(Y) {
        if (typeof O.addEventListener != D) O.addEventListener("load", Y, !1); else if (typeof j.addEventListener != D) j.addEventListener("load", Y, !1); else if (typeof O.attachEvent != D) i(O, "onload", Y); else if ("function" == typeof O.onload) {
            var X = O.onload;
            O.onload = function() {
                X(), Y();
            };
        } else O.onload = Y;
    }
    function h() {
        T ? V() : H();
    }
    function V() {
        var X = j.getElementsByTagName("body")[0], aa = C(r);
        aa.setAttribute("type", q);
        var Z = X.appendChild(aa);
        if (Z) {
            var Y = 0;
            !function() {
                if (typeof Z.GetVariable != D) {
                    var ab = Z.GetVariable("$version");
                    ab && (ab = ab.split(" ")[1].split(","), M.pv = [ parseInt(ab[0], 10), parseInt(ab[1], 10), parseInt(ab[2], 10) ]);
                } else if (10 > Y) return Y++, void setTimeout(arguments.callee, 10);
                X.removeChild(aa), Z = null, H();
            }();
        } else H();
    }
    function H() {
        var ag = o.length;
        if (ag > 0) for (var af = 0; ag > af; af++) {
            var Y = o[af].id, ab = o[af].callbackFn, aa = {
                success: !1,
                id: Y
            };
            if (M.pv[0] > 0) {
                var ae = c(Y);
                if (ae) if (!F(o[af].swfVersion) || M.wk && M.wk < 312) if (o[af].expressInstall && A()) {
                    var ai = {};
                    ai.data = o[af].expressInstall, ai.width = ae.getAttribute("width") || "0", ai.height = ae.getAttribute("height") || "0", 
                    ae.getAttribute("class") && (ai.styleclass = ae.getAttribute("class")), ae.getAttribute("align") && (ai.align = ae.getAttribute("align"));
                    for (var ah = {}, X = ae.getElementsByTagName("param"), ac = X.length, ad = 0; ac > ad; ad++) "movie" != X[ad].getAttribute("name").toLowerCase() && (ah[X[ad].getAttribute("name")] = X[ad].getAttribute("value"));
                    P(ai, ah, Y, ab);
                } else p(ae), ab && ab(aa); else w(Y, !0), ab && (aa.success = !0, aa.ref = z(Y), 
                ab(aa));
            } else if (w(Y, !0), ab) {
                var Z = z(Y);
                Z && typeof Z.SetVariable != D && (aa.success = !0, aa.ref = Z), ab(aa);
            }
        }
    }
    function z(aa) {
        var X = null, Y = c(aa);
        if (Y && "OBJECT" == Y.nodeName) if (typeof Y.SetVariable != D) X = Y; else {
            var Z = Y.getElementsByTagName(r)[0];
            Z && (X = Z);
        }
        return X;
    }
    function A() {
        return !a && F("6.0.65") && (M.win || M.mac) && !(M.wk && M.wk < 312);
    }
    function P(aa, ab, X, Z) {
        a = !0, E = Z || null, B = {
            success: !1,
            id: X
        };
        var ae = c(X);
        if (ae) {
            "OBJECT" == ae.nodeName ? (l = g(ae), Q = null) : (l = ae, Q = X), aa.id = R, (typeof aa.width == D || !/%$/.test(aa.width) && parseInt(aa.width, 10) < 310) && (aa.width = "310"), 
            (typeof aa.height == D || !/%$/.test(aa.height) && parseInt(aa.height, 10) < 137) && (aa.height = "137"), 
            j.title = j.title.slice(0, 47) + " - Flash Player Installation";
            var ad = M.ie && M.win ? "ActiveX" : "PlugIn", ac = "MMredirectURL=" + O.location.toString().replace(/&/g, "%26") + "&MMplayerType=" + ad + "&MMdoctitle=" + j.title;
            if (typeof ab.flashvars != D ? ab.flashvars += "&" + ac : ab.flashvars = ac, M.ie && M.win && 4 != ae.readyState) {
                var Y = C("div");
                X += "SWFObjectNew", Y.setAttribute("id", X), ae.parentNode.insertBefore(Y, ae), 
                ae.style.display = "none", function() {
                    4 == ae.readyState ? ae.parentNode.removeChild(ae) : setTimeout(arguments.callee, 10);
                }();
            }
            u(aa, ab, X);
        }
    }
    function p(Y) {
        if (M.ie && M.win && 4 != Y.readyState) {
            var X = C("div");
            Y.parentNode.insertBefore(X, Y), X.parentNode.replaceChild(g(Y), X), Y.style.display = "none", 
            function() {
                4 == Y.readyState ? Y.parentNode.removeChild(Y) : setTimeout(arguments.callee, 10);
            }();
        } else Y.parentNode.replaceChild(g(Y), Y);
    }
    function g(ab) {
        var aa = C("div");
        if (M.win && M.ie) aa.innerHTML = ab.innerHTML; else {
            var Y = ab.getElementsByTagName(r)[0];
            if (Y) {
                var ad = Y.childNodes;
                if (ad) for (var X = ad.length, Z = 0; X > Z; Z++) 1 == ad[Z].nodeType && "PARAM" == ad[Z].nodeName || 8 == ad[Z].nodeType || aa.appendChild(ad[Z].cloneNode(!0));
            }
        }
        return aa;
    }
    function u(ai, ag, Y) {
        var X, aa = c(Y);
        if (M.wk && M.wk < 312) return X;
        if (aa) if (typeof ai.id == D && (ai.id = Y), M.ie && M.win) {
            var ah = "";
            for (var ae in ai) ai[ae] != Object.prototype[ae] && ("data" == ae.toLowerCase() ? ag.movie = ai[ae] : "styleclass" == ae.toLowerCase() ? ah += ' class="' + ai[ae] + '"' : "classid" != ae.toLowerCase() && (ah += " " + ae + '="' + ai[ae] + '"'));
            var af = "";
            for (var ad in ag) ag[ad] != Object.prototype[ad] && (af += '<param name="' + ad + '" value="' + ag[ad] + '" />');
            aa.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"' + ah + ">" + af + "</object>", 
            N[N.length] = ai.id, X = c(ai.id);
        } else {
            var Z = C(r);
            Z.setAttribute("type", q);
            for (var ac in ai) ai[ac] != Object.prototype[ac] && ("styleclass" == ac.toLowerCase() ? Z.setAttribute("class", ai[ac]) : "classid" != ac.toLowerCase() && Z.setAttribute(ac, ai[ac]));
            for (var ab in ag) ag[ab] != Object.prototype[ab] && "movie" != ab.toLowerCase() && e(Z, ab, ag[ab]);
            aa.parentNode.replaceChild(Z, aa), X = Z;
        }
        return X;
    }
    function e(Z, X, Y) {
        var aa = C("param");
        aa.setAttribute("name", X), aa.setAttribute("value", Y), Z.appendChild(aa);
    }
    function y(Y) {
        var X = c(Y);
        X && "OBJECT" == X.nodeName && (M.ie && M.win ? (X.style.display = "none", function() {
            4 == X.readyState ? b(Y) : setTimeout(arguments.callee, 10);
        }()) : X.parentNode.removeChild(X));
    }
    function b(Z) {
        var Y = c(Z);
        if (Y) {
            for (var X in Y) "function" == typeof Y[X] && (Y[X] = null);
            Y.parentNode.removeChild(Y);
        }
    }
    function c(Z) {
        var X = null;
        try {
            X = j.getElementById(Z);
        } catch (Y) {}
        return X;
    }
    function C(X) {
        return j.createElement(X);
    }
    function i(Z, X, Y) {
        Z.attachEvent(X, Y), I[I.length] = [ Z, X, Y ];
    }
    function F(Z) {
        var Y = M.pv, X = Z.split(".");
        return X[0] = parseInt(X[0], 10), X[1] = parseInt(X[1], 10) || 0, X[2] = parseInt(X[2], 10) || 0, 
        Y[0] > X[0] || Y[0] == X[0] && Y[1] > X[1] || Y[0] == X[0] && Y[1] == X[1] && Y[2] >= X[2] ? !0 : !1;
    }
    function v(ac, Y, ad, ab) {
        if (!M.ie || !M.mac) {
            var aa = j.getElementsByTagName("head")[0];
            if (aa) {
                var X = ad && "string" == typeof ad ? ad : "screen";
                if (ab && (n = null, G = null), !n || G != X) {
                    var Z = C("style");
                    Z.setAttribute("type", "text/css"), Z.setAttribute("media", X), n = aa.appendChild(Z), 
                    M.ie && M.win && typeof j.styleSheets != D && j.styleSheets.length > 0 && (n = j.styleSheets[j.styleSheets.length - 1]), 
                    G = X;
                }
                M.ie && M.win ? n && typeof n.addRule == r && n.addRule(ac, Y) : n && typeof j.createTextNode != D && n.appendChild(j.createTextNode(ac + " {" + Y + "}"));
            }
        }
    }
    function w(Z, X) {
        if (m) {
            var Y = X ? "visible" : "hidden";
            J && c(Z) ? c(Z).style.visibility = Y : v("#" + Z, "visibility:" + Y);
        }
    }
    function L(Y) {
        var Z = /[\\\"<>\.;]/, X = null != Z.exec(Y);
        return X && typeof encodeURIComponent != D ? encodeURIComponent(Y) : Y;
    }
    {
        var l, Q, E, B, n, G, D = "undefined", r = "object", S = "Shockwave Flash", W = "ShockwaveFlash.ShockwaveFlash", q = "application/x-shockwave-flash", R = "SWFObjectExprInst", x = "onreadystatechange", O = window, j = document, t = navigator, T = !1, U = [ h ], o = [], N = [], I = [], J = !1, a = !1, m = !0, M = function() {
            var aa = typeof j.getElementById != D && typeof j.getElementsByTagName != D && typeof j.createElement != D, ah = t.userAgent.toLowerCase(), Y = t.platform.toLowerCase(), ae = /win/.test(Y ? Y : ah), ac = /mac/.test(Y ? Y : ah), af = /webkit/.test(ah) ? parseFloat(ah.replace(/^.*webkit\/(\d+(\.\d+)?).*$/, "$1")) : !1, X = !1, ag = [ 0, 0, 0 ], ab = null;
            if (typeof t.plugins != D && typeof t.plugins[S] == r) ab = t.plugins[S].description, 
            !ab || typeof t.mimeTypes != D && t.mimeTypes[q] && !t.mimeTypes[q].enabledPlugin || (T = !0, 
            X = !1, ab = ab.replace(/^.*\s+(\S+\s+\S+$)/, "$1"), ag[0] = parseInt(ab.replace(/^(.*)\..*$/, "$1"), 10), 
            ag[1] = parseInt(ab.replace(/^.*\.(.*)\s.*$/, "$1"), 10), ag[2] = /[a-zA-Z]/.test(ab) ? parseInt(ab.replace(/^.*[a-zA-Z]+(.*)$/, "$1"), 10) : 0); else if (typeof O.ActiveXObject != D) try {
                var ad = new ActiveXObject(W);
                ad && (ab = ad.GetVariable("$version"), ab && (X = !0, ab = ab.split(" ")[1].split(","), 
                ag = [ parseInt(ab[0], 10), parseInt(ab[1], 10), parseInt(ab[2], 10) ]));
            } catch (Z) {}
            return {
                w3: aa,
                pv: ag,
                wk: af,
                ie: X,
                win: ae,
                mac: ac
            };
        }();
        !function() {
            M.w3 && ((typeof j.readyState != D && "complete" == j.readyState || typeof j.readyState == D && (j.getElementsByTagName("body")[0] || j.body)) && f(), 
            J || (typeof j.addEventListener != D && j.addEventListener("DOMContentLoaded", f, !1), 
            M.ie && M.win && (j.attachEvent(x, function() {
                "complete" == j.readyState && (j.detachEvent(x, arguments.callee), f());
            }), O == top && !function() {
                if (!J) {
                    try {
                        j.documentElement.doScroll("left");
                    } catch (X) {
                        return void setTimeout(arguments.callee, 0);
                    }
                    f();
                }
            }()), M.wk && !function() {
                return J ? void 0 : /loaded|complete/.test(j.readyState) ? void f() : void setTimeout(arguments.callee, 0);
            }(), s(f)));
        }(), function() {
            M.ie && M.win && window.attachEvent("onunload", function() {
                for (var ac = I.length, ab = 0; ac > ab; ab++) I[ab][0].detachEvent(I[ab][1], I[ab][2]);
                for (var Z = N.length, aa = 0; Z > aa; aa++) y(N[aa]);
                for (var Y in M) M[Y] = null;
                M = null;
                for (var X in swfobject) swfobject[X] = null;
                swfobject = null;
            });
        }();
    }
    return {
        registerObject: function(ab, X, aa, Z) {
            if (M.w3 && ab && X) {
                var Y = {};
                Y.id = ab, Y.swfVersion = X, Y.expressInstall = aa, Y.callbackFn = Z, o[o.length] = Y, 
                w(ab, !1);
            } else Z && Z({
                success: !1,
                id: ab
            });
        },
        getObjectById: function(X) {
            return M.w3 ? z(X) : void 0;
        },
        embedSWF: function(ab, ah, ae, ag, Y, aa, Z, ad, af, ac) {
            var X = {
                success: !1,
                id: ah
            };
            M.w3 && !(M.wk && M.wk < 312) && ab && ah && ae && ag && Y ? (w(ah, !1), K(function() {
                ae += "", ag += "";
                var aj = {};
                if (af && typeof af === r) for (var al in af) aj[al] = af[al];
                aj.data = ab, aj.width = ae, aj.height = ag;
                var am = {};
                if (ad && typeof ad === r) for (var ak in ad) am[ak] = ad[ak];
                if (Z && typeof Z === r) for (var ai in Z) typeof am.flashvars != D ? am.flashvars += "&" + ai + "=" + Z[ai] : am.flashvars = ai + "=" + Z[ai];
                if (F(Y)) {
                    var an = u(aj, am, ah);
                    aj.id == ah && w(ah, !0), X.success = !0, X.ref = an;
                } else {
                    if (aa && A()) return aj.data = aa, void P(aj, am, ah, ac);
                    w(ah, !0);
                }
                ac && ac(X);
            })) : ac && ac(X);
        },
        switchOffAutoHideShow: function() {
            m = !1;
        },
        ua: M,
        getFlashPlayerVersion: function() {
            return {
                major: M.pv[0],
                minor: M.pv[1],
                release: M.pv[2]
            };
        },
        hasFlashPlayerVersion: F,
        createSWF: function(Z, Y, X) {
            return M.w3 ? u(Z, Y, X) : void 0;
        },
        showExpressInstall: function(Z, aa, X, Y) {
            M.w3 && A() && P(Z, aa, X, Y);
        },
        removeSWF: function(X) {
            M.w3 && y(X);
        },
        createCSS: function(aa, Z, Y, X) {
            M.w3 && v(aa, Z, Y, X);
        },
        addDomLoadEvent: K,
        addLoadEvent: s,
        getQueryParamValue: function(aa) {
            var Z = j.location.search || j.location.hash;
            if (Z) {
                if (/\?/.test(Z) && (Z = Z.split("?")[1]), null == aa) return L(Z);
                for (var Y = Z.split("&"), X = 0; X < Y.length; X++) if (Y[X].substring(0, Y[X].indexOf("=")) == aa) return L(Y[X].substring(Y[X].indexOf("=") + 1));
            }
            return "";
        },
        expressInstallCallback: function() {
            if (a) {
                var X = c(R);
                X && l && (X.parentNode.replaceChild(l, X), Q && (w(Q, !0), M.ie && M.win && (l.style.display = "block")), 
                E && E(B)), a = !1;
            }
        }
    };
}();

!function() {
    var md5, define = function(f) {
        md5 = f();
    };
    define.amd = !0, /*! jquery-ajax-localstorage-cache is a plugin build for jQuery (>1.5.1) - v0.1.0 - 2012-11-06
     * https://github.com/nectify/jquery-ajax-jstorage-cache
     * Copyright (c) 2012 Paul Irish; Licensed Apache 2 */
    /*
     * JavaScript MD5 1.0
     * https://github.com/blueimp/JavaScript-MD5
     *
     * Copyright 2011, Sebastian Tschan
     * https://blueimp.net
     *
     * Licensed under the MIT license:
     * http://www.opensource.org/licenses/MIT
     *
     * Based on
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * Distributed under the BSD License
     * See http://pajhome.org.uk/crypt/md5 for more info.
     */
    /*jslint bitwise: true */
    /* global unescape, define */
    function($) {
        "use strict";
        /*
         * Add integers, wrapping at 2^32. This uses 16-bit operations internally
         * to work around bugs in some JS interpreters.
         */
        function safe_add(x, y) {
            var lsw = (65535 & x) + (65535 & y), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return msw << 16 | 65535 & lsw;
        }
        /*
         * Bitwise rotate a 32-bit number to the left.
         */
        function bit_rol(num, cnt) {
            return num << cnt | num >>> 32 - cnt;
        }
        /*
         * These functions implement the four basic operations the algorithm uses.
         */
        function md5_cmn(q, a, b, x, s, t) {
            return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
        }
        function md5_ff(a, b, c, d, x, s, t) {
            return md5_cmn(b & c | ~b & d, a, b, x, s, t);
        }
        function md5_gg(a, b, c, d, x, s, t) {
            return md5_cmn(b & d | c & ~d, a, b, x, s, t);
        }
        function md5_hh(a, b, c, d, x, s, t) {
            return md5_cmn(b ^ c ^ d, a, b, x, s, t);
        }
        function md5_ii(a, b, c, d, x, s, t) {
            return md5_cmn(c ^ (b | ~d), a, b, x, s, t);
        }
        /*
         * Calculate the MD5 of an array of little-endian words, and a bit length.
         */
        function binl_md5(x, len) {
            /* append padding */
            x[len >> 5] |= 128 << len % 32, x[(len + 64 >>> 9 << 4) + 14] = len;
            var i, olda, oldb, oldc, oldd, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
            for (i = 0; i < x.length; i += 16) olda = a, oldb = b, oldc = c, oldd = d, a = md5_ff(a, b, c, d, x[i], 7, -680876936), 
            d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586), c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819), 
            b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330), a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897), 
            d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426), c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341), 
            b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983), a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416), 
            d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417), c = md5_ff(c, d, a, b, x[i + 10], 17, -42063), 
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162), a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682), 
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101), c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290), 
            b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329), a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510), 
            d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632), c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713), 
            b = md5_gg(b, c, d, a, x[i], 20, -373897302), a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691), 
            d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083), c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335), 
            b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848), a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438), 
            d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690), c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961), 
            b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501), a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467), 
            d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784), c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473), 
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734), a = md5_hh(a, b, c, d, x[i + 5], 4, -378558), 
            d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463), c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562), 
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556), a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060), 
            d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353), c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632), 
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640), a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174), 
            d = md5_hh(d, a, b, c, x[i], 11, -358537222), c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979), 
            b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189), a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487), 
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835), c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520), 
            b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651), a = md5_ii(a, b, c, d, x[i], 6, -198630844), 
            d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415), c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905), 
            b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055), a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571), 
            d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606), c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523), 
            b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799), a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359), 
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744), c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380), 
            b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649), a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070), 
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379), c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259), 
            b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551), a = safe_add(a, olda), b = safe_add(b, oldb), 
            c = safe_add(c, oldc), d = safe_add(d, oldd);
            return [ a, b, c, d ];
        }
        /*
         * Convert an array of little-endian words to a string
         */
        function binl2rstr(input) {
            var i, output = "";
            for (i = 0; i < 32 * input.length; i += 8) output += String.fromCharCode(input[i >> 5] >>> i % 32 & 255);
            return output;
        }
        /*
         * Convert a raw string to an array of little-endian words
         * Characters >255 have their high-byte silently ignored.
         */
        function rstr2binl(input) {
            var i, output = [];
            for (output[(input.length >> 2) - 1] = void 0, i = 0; i < output.length; i += 1) output[i] = 0;
            for (i = 0; i < 8 * input.length; i += 8) output[i >> 5] |= (255 & input.charCodeAt(i / 8)) << i % 32;
            return output;
        }
        /*
         * Calculate the MD5 of a raw string
         */
        function rstr_md5(s) {
            return binl2rstr(binl_md5(rstr2binl(s), 8 * s.length));
        }
        /*
         * Calculate the HMAC-MD5, of a key and some data (raw strings)
         */
        function rstr_hmac_md5(key, data) {
            var i, hash, bkey = rstr2binl(key), ipad = [], opad = [];
            for (ipad[15] = opad[15] = void 0, bkey.length > 16 && (bkey = binl_md5(bkey, 8 * key.length)), 
            i = 0; 16 > i; i += 1) ipad[i] = 909522486 ^ bkey[i], opad[i] = 1549556828 ^ bkey[i];
            return hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + 8 * data.length), binl2rstr(binl_md5(opad.concat(hash), 640));
        }
        /*
         * Convert a raw string to a hex string
         */
        function rstr2hex(input) {
            var x, i, hex_tab = "0123456789abcdef", output = "";
            for (i = 0; i < input.length; i += 1) x = input.charCodeAt(i), output += hex_tab.charAt(x >>> 4 & 15) + hex_tab.charAt(15 & x);
            return output;
        }
        /*
         * Encode a string as utf-8
         */
        function str2rstr_utf8(input) {
            return unescape(encodeURIComponent(input));
        }
        /*
         * Take string arguments and return either raw or hex encoded strings
         */
        function raw_md5(s) {
            return rstr_md5(str2rstr_utf8(s));
        }
        function hex_md5(s) {
            return rstr2hex(raw_md5(s));
        }
        function raw_hmac_md5(k, d) {
            return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
        }
        function hex_hmac_md5(k, d) {
            return rstr2hex(raw_hmac_md5(k, d));
        }
        function md5(string, key, raw) {
            return key ? raw ? raw_hmac_md5(key, string) : hex_hmac_md5(key, string) : raw ? raw_md5(string) : hex_md5(string);
        }
        "function" == typeof define && define.amd ? define(function() {
            return md5;
        }) : $.md5 = md5;
    }(this), // github.com/paulirish/jquery-ajax-localstorage-cache
    // dependent on Modernizr's localStorage test
    //
    function(window, $, Modernizr, undefined) {
        function save(key, val, isLegacy, err) {
            err = err || noop;
            try {
                isLegacy ? (localStorage.setItem(key, JSON.stringify(val.p)), localStorage.setItem(key + "cachettl", JSON.stringify(val.t))) : localStorage.setItem(PREFIX + key, JSON.stringify(val));
            } catch (e) {
                // Remove any incomplete data that may have been saved before the exception was caught
                isLegacy ? (localStorage.removeItem(key), localStorage.removeItem(key + "cachettl")) : localStorage.removeItem(PREFIX + key), 
                err(e, val);
            }
        }
        //save payload
        function savePayload(fingerprint, payload, hourstl, isLegacy, onError) {
            var expires = +new Date() + 36e5 * hourstl;
            save(fingerprint, {
                t: expires,
                p: payload
            }, isLegacy, onError);
        }
        //Someone may have upgraded the plugin.. Respect the user and clean up
        function convertLegacy(cacheKey) {
            var out, ttl = localStorage.getItem(cacheKey + "cachettl"), value = localStorage.getItem(cacheKey);
            return ttl && value && (value = JSON.parse(value), localStorage.removeItem(cacheKey + "cachettl"), 
            localStorage.removeItem(cacheKey), out = {
                t: ttl,
                p: value
            }, save(md5(cacheKey), out)), out;
        }
        function getItem(key, isLegacy) {
            var item, ttl;
            return isLegacy ? (item = localStorage.getItem(key), ttl = localStorage.getItem(key + "cachettl")) : item = localStorage.getItem(PREFIX + key), 
            item && (item = JSON.parse(item)), !isLegacy && item && (ttl = item.t, item = item.p), 
            item && ttl < +new Date() && (isLegacy ? (localStorage.removeItem(key), localStorage.removeItem(key + "cachettl")) : localStorage.removeItem(PREFIX + key), 
            item = null), item;
        }
        var PREFIX = "_jalc_", noop = function() {};
        $.ajaxPrefilter(function(options, originalOptions, jqXHR) {
            // Cache it ?
            if (!Modernizr.localstorage || !options.localCache) return undefined;
            var hourstl = options.cacheTTL || 5, originalCacheKey = options.url.replace(/jQuery.*/, "") + options.type + options.data, isLegacy = null != options.cacheKey, cacheKey = options.cacheKey || md5(originalCacheKey);
            isLegacy || convertLegacy(originalCacheKey), // isCacheValid is a function to validate cache
            options.isCacheValid && !options.isCacheValid() && localStorage.removeItem(isLegacy ? cacheKey : PREFIX + cacheKey);
            var value = getItem(cacheKey, isLegacy);
            value ? (//In the cache? So get it, apply success callback & abort the XHR request
            // parse back to JSON string if we can.
            0 !== options.dataType.indexOf("json") && (value = JSON.stringify(value)), options.success(value), 
            // Abort is broken on JQ 1.5 :(
            jqXHR.abort()) : (//If it not in the cache, we change the success callback, just put data on localstorage and after that apply the initial callback
            options.success && (options.realsuccess = options.success), options.success = function(data) {
                var strdata = data;
                0 === this.dataType.indexOf("json") && (strdata = JSON.stringify(data)), // Save the data to localStorage catching exceptions (possibly QUOTA_EXCEEDED_ERR)
                savePayload(cacheKey, data, hourstl, isLegacy, function(e) {
                    "function" == typeof options.cacheError && options.cacheError(e, originalCacheKey, strdata);
                }), options.realsuccess && options.realsuccess(data);
            });
        });
    }(this, this.jQuery, this.Modernizr);
}(), /* v1.4 */
/*

 Copyright (c) 2009 Dimas Begunoff, http://www.farinspace.com

 https://github.com/farinspace/jquery.imgpreload

 Licensed under the MIT license
 http://en.wikipedia.org/wiki/MIT_License

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.

 */
"undefined" != typeof jQuery && !function($) {
    // extend jquery (because i love jQuery)
    $.imgpreload = function(imgs, settings) {
        settings = $.extend({}, $.fn.imgpreload.defaults, settings instanceof Function ? {
            all: settings
        } : settings), // use of typeof required
        // https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Operators/Special_Operators/Instanceof_Operator#Description
        "string" == typeof imgs && (imgs = new Array(imgs));
        var loaded = new Array();
        $.each(imgs, function(i, elem) {
            var img = new Image(), url = elem, img_obj = img;
            "string" != typeof elem && (url = $(elem).attr("src"), img_obj = elem), $(img).bind("load error", function(e) {
                loaded.push(img_obj), $.data(img_obj, "loaded", "error" == e.type ? !1 : !0), settings.each instanceof Function && settings.each.call(img_obj), 
                // http://jsperf.com/length-in-a-variable
                loaded.length >= imgs.length && settings.all instanceof Function && settings.all.call(loaded), 
                $(this).unbind("load error");
            }), img.src = url;
        });
    }, $.fn.imgpreload = function(settings) {
        return $.imgpreload(this, settings), this;
    }, $.fn.imgpreload.defaults = {
        each: null,
        all: null
    };
}(jQuery), /*! jQuery UI - v1.8.20 - 2012-04-30
 * https://github.com/jquery/jquery-ui
 * Includes: jquery.effects.core.js
 * Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
jQuery.effects || function(a, b) {
    function c(b) {
        var c;
        return b && b.constructor == Array && 3 == b.length ? b : (c = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(b)) ? [ parseInt(c[1], 10), parseInt(c[2], 10), parseInt(c[3], 10) ] : (c = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(b)) ? [ 2.55 * parseFloat(c[1]), 2.55 * parseFloat(c[2]), 2.55 * parseFloat(c[3]) ] : (c = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(b)) ? [ parseInt(c[1], 16), parseInt(c[2], 16), parseInt(c[3], 16) ] : (c = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(b)) ? [ parseInt(c[1] + c[1], 16), parseInt(c[2] + c[2], 16), parseInt(c[3] + c[3], 16) ] : (c = /rgba\(0, 0, 0, 0\)/.exec(b)) ? e.transparent : e[a.trim(b).toLowerCase()];
    }
    function d(b, d) {
        var e;
        do {
            if (e = a.curCSS(b, d), "" != e && "transparent" != e || a.nodeName(b, "body")) break;
            d = "backgroundColor";
        } while (b = b.parentNode);
        return c(e);
    }
    function h() {
        var c, d, a = document.defaultView ? document.defaultView.getComputedStyle(this, null) : this.currentStyle, b = {};
        if (a && a.length && a[0] && a[a[0]]) for (var e = a.length; e--; ) c = a[e], "string" == typeof a[c] && (d = c.replace(/\-(\w)/g, function(a, b) {
            return b.toUpperCase();
        }), b[d] = a[c]); else for (c in a) "string" == typeof a[c] && (b[c] = a[c]);
        return b;
    }
    function i(b) {
        var c, d;
        for (c in b) d = b[c], (null == d || a.isFunction(d) || c in g || /scrollbar/.test(c) || !/color/i.test(c) && isNaN(parseFloat(d))) && delete b[c];
        return b;
    }
    function j(a, b) {
        var d, c = {
            _: 0
        };
        for (d in b) a[d] != b[d] && (c[d] = b[d]);
        return c;
    }
    function k(b, c, d, e) {
        return "object" == typeof b && (e = c, d = null, c = b, b = c.effect), a.isFunction(c) && (e = c, 
        d = null, c = {}), ("number" == typeof c || a.fx.speeds[c]) && (e = d, d = c, c = {}), 
        a.isFunction(d) && (e = d, d = null), c = c || {}, d = d || c.duration, d = a.fx.off ? 0 : "number" == typeof d ? d : d in a.fx.speeds ? a.fx.speeds[d] : a.fx.speeds._default, 
        e = e || c.complete, [ b, c, d, e ];
    }
    function l(b) {
        return !b || "number" == typeof b || a.fx.speeds[b] ? !0 : "string" != typeof b || a.effects[b] ? !1 : !0;
    }
    a.effects = {}, a.each([ "backgroundColor", "borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor", "borderColor", "color", "outlineColor" ], function(b, e) {
        a.fx.step[e] = function(a) {
            a.colorInit || (a.start = d(a.elem, e), a.end = c(a.end), a.colorInit = !0), a.elem.style[e] = "rgb(" + Math.max(Math.min(parseInt(a.pos * (a.end[0] - a.start[0]) + a.start[0], 10), 255), 0) + "," + Math.max(Math.min(parseInt(a.pos * (a.end[1] - a.start[1]) + a.start[1], 10), 255), 0) + "," + Math.max(Math.min(parseInt(a.pos * (a.end[2] - a.start[2]) + a.start[2], 10), 255), 0) + ")";
        };
    });
    var e = {
        aqua: [ 0, 255, 255 ],
        azure: [ 240, 255, 255 ],
        beige: [ 245, 245, 220 ],
        black: [ 0, 0, 0 ],
        blue: [ 0, 0, 255 ],
        brown: [ 165, 42, 42 ],
        cyan: [ 0, 255, 255 ],
        darkblue: [ 0, 0, 139 ],
        darkcyan: [ 0, 139, 139 ],
        darkgrey: [ 169, 169, 169 ],
        darkgreen: [ 0, 100, 0 ],
        darkkhaki: [ 189, 183, 107 ],
        darkmagenta: [ 139, 0, 139 ],
        darkolivegreen: [ 85, 107, 47 ],
        darkorange: [ 255, 140, 0 ],
        darkorchid: [ 153, 50, 204 ],
        darkred: [ 139, 0, 0 ],
        darksalmon: [ 233, 150, 122 ],
        darkviolet: [ 148, 0, 211 ],
        fuchsia: [ 255, 0, 255 ],
        gold: [ 255, 215, 0 ],
        green: [ 0, 128, 0 ],
        indigo: [ 75, 0, 130 ],
        khaki: [ 240, 230, 140 ],
        lightblue: [ 173, 216, 230 ],
        lightcyan: [ 224, 255, 255 ],
        lightgreen: [ 144, 238, 144 ],
        lightgrey: [ 211, 211, 211 ],
        lightpink: [ 255, 182, 193 ],
        lightyellow: [ 255, 255, 224 ],
        lime: [ 0, 255, 0 ],
        magenta: [ 255, 0, 255 ],
        maroon: [ 128, 0, 0 ],
        navy: [ 0, 0, 128 ],
        olive: [ 128, 128, 0 ],
        orange: [ 255, 165, 0 ],
        pink: [ 255, 192, 203 ],
        purple: [ 128, 0, 128 ],
        violet: [ 128, 0, 128 ],
        red: [ 255, 0, 0 ],
        silver: [ 192, 192, 192 ],
        white: [ 255, 255, 255 ],
        yellow: [ 255, 255, 0 ],
        transparent: [ 255, 255, 255 ]
    }, f = [ "add", "remove", "toggle" ], g = {
        border: 1,
        borderBottom: 1,
        borderColor: 1,
        borderLeft: 1,
        borderRight: 1,
        borderTop: 1,
        borderWidth: 1,
        margin: 1,
        padding: 1
    };
    a.effects.animateClass = function(b, c, d, e) {
        return a.isFunction(d) && (e = d, d = null), this.queue(function() {
            var m, g = a(this), k = g.attr("style") || " ", l = i(h.call(this)), n = g.attr("class") || "";
            a.each(f, function(a, c) {
                b[c] && g[c + "Class"](b[c]);
            }), m = i(h.call(this)), g.attr("class", n), g.animate(j(l, m), {
                queue: !1,
                duration: c,
                easing: d,
                complete: function() {
                    a.each(f, function(a, c) {
                        b[c] && g[c + "Class"](b[c]);
                    }), "object" == typeof g.attr("style") ? (g.attr("style").cssText = "", g.attr("style").cssText = k) : g.attr("style", k), 
                    e && e.apply(this, arguments), a.dequeue(this);
                }
            });
        });
    }, a.fn.extend({
        _addClass: a.fn.addClass,
        addClass: function(b, c, d, e) {
            return c ? a.effects.animateClass.apply(this, [ {
                add: b
            }, c, d, e ]) : this._addClass(b);
        },
        _removeClass: a.fn.removeClass,
        removeClass: function(b, c, d, e) {
            return c ? a.effects.animateClass.apply(this, [ {
                remove: b
            }, c, d, e ]) : this._removeClass(b);
        },
        _toggleClass: a.fn.toggleClass,
        toggleClass: function(c, d, e, f, g) {
            return "boolean" == typeof d || d === b ? e ? a.effects.animateClass.apply(this, [ d ? {
                add: c
            } : {
                remove: c
            }, e, f, g ]) : this._toggleClass(c, d) : a.effects.animateClass.apply(this, [ {
                toggle: c
            }, d, e, f ]);
        },
        switchClass: function(b, c, d, e, f) {
            return a.effects.animateClass.apply(this, [ {
                add: c,
                remove: b
            }, d, e, f ]);
        }
    }), a.extend(a.effects, {
        version: "1.8.20",
        save: function(a, b) {
            for (var c = 0; c < b.length; c++) null !== b[c] && a.data("ec.storage." + b[c], a[0].style[b[c]]);
        },
        restore: function(a, b) {
            for (var c = 0; c < b.length; c++) null !== b[c] && a.css(b[c], a.data("ec.storage." + b[c]));
        },
        setMode: function(a, b) {
            return "toggle" == b && (b = a.is(":hidden") ? "show" : "hide"), b;
        },
        getBaseline: function(a, b) {
            var c, d;
            switch (a[0]) {
              case "top":
                c = 0;
                break;

              case "middle":
                c = .5;
                break;

              case "bottom":
                c = 1;
                break;

              default:
                c = a[0] / b.height;
            }
            switch (a[1]) {
              case "left":
                d = 0;
                break;

              case "center":
                d = .5;
                break;

              case "right":
                d = 1;
                break;

              default:
                d = a[1] / b.width;
            }
            return {
                x: d,
                y: c
            };
        },
        createWrapper: function(b) {
            if (b.parent().is(".ui-effects-wrapper")) return b.parent();
            var c = {
                width: b.outerWidth(!0),
                height: b.outerHeight(!0),
                "float": b.css("float")
            }, d = a("<div></div>").addClass("ui-effects-wrapper").css({
                fontSize: "100%",
                background: "transparent",
                border: "none",
                margin: 0,
                padding: 0
            }), e = document.activeElement;
            return b.wrap(d), (b[0] === e || a.contains(b[0], e)) && a(e).focus(), d = b.parent(), 
            "static" == b.css("position") ? (d.css({
                position: "relative"
            }), b.css({
                position: "relative"
            })) : (a.extend(c, {
                position: b.css("position"),
                zIndex: b.css("z-index")
            }), a.each([ "top", "left", "bottom", "right" ], function(a, d) {
                c[d] = b.css(d), isNaN(parseInt(c[d], 10)) && (c[d] = "auto");
            }), b.css({
                position: "relative",
                top: 0,
                left: 0,
                right: "auto",
                bottom: "auto"
            })), d.css(c).show();
        },
        removeWrapper: function(b) {
            var c, d = document.activeElement;
            return b.parent().is(".ui-effects-wrapper") ? (c = b.parent().replaceWith(b), (b[0] === d || a.contains(b[0], d)) && a(d).focus(), 
            c) : b;
        },
        setTransition: function(b, c, d, e) {
            return e = e || {}, a.each(c, function(a, c) {
                var f = b.cssUnit(c);
                f[0] > 0 && (e[c] = f[0] * d + f[1]);
            }), e;
        }
    }), a.fn.extend({
        effect: function(b) {
            var f = k.apply(this, arguments), g = {
                options: f[1],
                duration: f[2],
                callback: f[3]
            }, h = g.options.mode, i = a.effects[b];
            return a.fx.off || !i ? h ? this[h](g.duration, g.callback) : this.each(function() {
                g.callback && g.callback.call(this);
            }) : i.call(this, g);
        },
        _show: a.fn.show,
        show: function(a) {
            if (l(a)) return this._show.apply(this, arguments);
            var b = k.apply(this, arguments);
            return b[1].mode = "show", this.effect.apply(this, b);
        },
        _hide: a.fn.hide,
        hide: function(a) {
            if (l(a)) return this._hide.apply(this, arguments);
            var b = k.apply(this, arguments);
            return b[1].mode = "hide", this.effect.apply(this, b);
        },
        __toggle: a.fn.toggle,
        toggle: function(b) {
            if (l(b) || "boolean" == typeof b || a.isFunction(b)) return this.__toggle.apply(this, arguments);
            var c = k.apply(this, arguments);
            return c[1].mode = "toggle", this.effect.apply(this, c);
        },
        cssUnit: function(b) {
            var c = this.css(b), d = [];
            return a.each([ "em", "px", "%", "pt" ], function(a, b) {
                c.indexOf(b) > 0 && (d = [ parseFloat(c), b ]);
            }), d;
        }
    }), a.easing.jswing = a.easing.swing, a.extend(a.easing, {
        def: "easeOutQuad",
        swing: function(b, c, d, e, f) {
            return a.easing[a.easing.def](b, c, d, e, f);
        },
        easeInQuad: function(a, b, c, d, e) {
            return d * (b /= e) * b + c;
        },
        easeOutQuad: function(a, b, c, d, e) {
            return -d * (b /= e) * (b - 2) + c;
        },
        easeInOutQuad: function(a, b, c, d, e) {
            return (b /= e / 2) < 1 ? d / 2 * b * b + c : -d / 2 * (--b * (b - 2) - 1) + c;
        },
        easeInCubic: function(a, b, c, d, e) {
            return d * (b /= e) * b * b + c;
        },
        easeOutCubic: function(a, b, c, d, e) {
            return d * ((b = b / e - 1) * b * b + 1) + c;
        },
        easeInOutCubic: function(a, b, c, d, e) {
            return (b /= e / 2) < 1 ? d / 2 * b * b * b + c : d / 2 * ((b -= 2) * b * b + 2) + c;
        },
        easeInQuart: function(a, b, c, d, e) {
            return d * (b /= e) * b * b * b + c;
        },
        easeOutQuart: function(a, b, c, d, e) {
            return -d * ((b = b / e - 1) * b * b * b - 1) + c;
        },
        easeInOutQuart: function(a, b, c, d, e) {
            return (b /= e / 2) < 1 ? d / 2 * b * b * b * b + c : -d / 2 * ((b -= 2) * b * b * b - 2) + c;
        },
        easeInQuint: function(a, b, c, d, e) {
            return d * (b /= e) * b * b * b * b + c;
        },
        easeOutQuint: function(a, b, c, d, e) {
            return d * ((b = b / e - 1) * b * b * b * b + 1) + c;
        },
        easeInOutQuint: function(a, b, c, d, e) {
            return (b /= e / 2) < 1 ? d / 2 * b * b * b * b * b + c : d / 2 * ((b -= 2) * b * b * b * b + 2) + c;
        },
        easeInSine: function(a, b, c, d, e) {
            return -d * Math.cos(b / e * (Math.PI / 2)) + d + c;
        },
        easeOutSine: function(a, b, c, d, e) {
            return d * Math.sin(b / e * (Math.PI / 2)) + c;
        },
        easeInOutSine: function(a, b, c, d, e) {
            return -d / 2 * (Math.cos(Math.PI * b / e) - 1) + c;
        },
        easeInExpo: function(a, b, c, d, e) {
            return 0 == b ? c : d * Math.pow(2, 10 * (b / e - 1)) + c;
        },
        easeOutExpo: function(a, b, c, d, e) {
            return b == e ? c + d : d * (-Math.pow(2, -10 * b / e) + 1) + c;
        },
        easeInOutExpo: function(a, b, c, d, e) {
            return 0 == b ? c : b == e ? c + d : (b /= e / 2) < 1 ? d / 2 * Math.pow(2, 10 * (b - 1)) + c : d / 2 * (-Math.pow(2, -10 * --b) + 2) + c;
        },
        easeInCirc: function(a, b, c, d, e) {
            return -d * (Math.sqrt(1 - (b /= e) * b) - 1) + c;
        },
        easeOutCirc: function(a, b, c, d, e) {
            return d * Math.sqrt(1 - (b = b / e - 1) * b) + c;
        },
        easeInOutCirc: function(a, b, c, d, e) {
            return (b /= e / 2) < 1 ? -d / 2 * (Math.sqrt(1 - b * b) - 1) + c : d / 2 * (Math.sqrt(1 - (b -= 2) * b) + 1) + c;
        },
        easeInElastic: function(a, b, c, d, e) {
            var f = 1.70158, g = 0, h = d;
            if (0 == b) return c;
            if (1 == (b /= e)) return c + d;
            if (g || (g = .3 * e), h < Math.abs(d)) {
                h = d;
                var f = g / 4;
            } else var f = g / (2 * Math.PI) * Math.asin(d / h);
            return -(h * Math.pow(2, 10 * (b -= 1)) * Math.sin(2 * (b * e - f) * Math.PI / g)) + c;
        },
        easeOutElastic: function(a, b, c, d, e) {
            var f = 1.70158, g = 0, h = d;
            if (0 == b) return c;
            if (1 == (b /= e)) return c + d;
            if (g || (g = .3 * e), h < Math.abs(d)) {
                h = d;
                var f = g / 4;
            } else var f = g / (2 * Math.PI) * Math.asin(d / h);
            return h * Math.pow(2, -10 * b) * Math.sin(2 * (b * e - f) * Math.PI / g) + d + c;
        },
        easeInOutElastic: function(a, b, c, d, e) {
            var f = 1.70158, g = 0, h = d;
            if (0 == b) return c;
            if (2 == (b /= e / 2)) return c + d;
            if (g || (g = .3 * e * 1.5), h < Math.abs(d)) {
                h = d;
                var f = g / 4;
            } else var f = g / (2 * Math.PI) * Math.asin(d / h);
            return 1 > b ? -.5 * h * Math.pow(2, 10 * (b -= 1)) * Math.sin(2 * (b * e - f) * Math.PI / g) + c : h * Math.pow(2, -10 * (b -= 1)) * Math.sin(2 * (b * e - f) * Math.PI / g) * .5 + d + c;
        },
        easeInBack: function(a, c, d, e, f, g) {
            return g == b && (g = 1.70158), e * (c /= f) * c * ((g + 1) * c - g) + d;
        },
        easeOutBack: function(a, c, d, e, f, g) {
            return g == b && (g = 1.70158), e * ((c = c / f - 1) * c * ((g + 1) * c + g) + 1) + d;
        },
        easeInOutBack: function(a, c, d, e, f, g) {
            return g == b && (g = 1.70158), (c /= f / 2) < 1 ? e / 2 * c * c * (((g *= 1.525) + 1) * c - g) + d : e / 2 * ((c -= 2) * c * (((g *= 1.525) + 1) * c + g) + 2) + d;
        },
        easeInBounce: function(b, c, d, e, f) {
            return e - a.easing.easeOutBounce(b, f - c, 0, e, f) + d;
        },
        easeOutBounce: function(a, b, c, d, e) {
            return (b /= e) < 1 / 2.75 ? 7.5625 * d * b * b + c : 2 / 2.75 > b ? d * (7.5625 * (b -= 1.5 / 2.75) * b + .75) + c : 2.5 / 2.75 > b ? d * (7.5625 * (b -= 2.25 / 2.75) * b + .9375) + c : d * (7.5625 * (b -= 2.625 / 2.75) * b + .984375) + c;
        },
        easeInOutBounce: function(b, c, d, e, f) {
            return f / 2 > c ? .5 * a.easing.easeInBounce(b, 2 * c, 0, e, f) + d : .5 * a.easing.easeOutBounce(b, 2 * c - f, 0, e, f) + .5 * e + d;
        }
    });
}(jQuery), /*! jQuery UI - v1.10.0 - 2013-02-05
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js
* Copyright (c) 2013 jQuery Foundation and other contributors Licensed MIT */
function($, undefined) {
    // selectors
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase();
        // the element and all of its ancestors must be visible
        return "area" === nodeName ? (map = element.parentNode, mapName = map.name, element.href && mapName && "map" === map.nodeName.toLowerCase() ? (img = $("img[usemap=#" + mapName + "]")[0], 
        !!img && visible(img)) : !1) : (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
    }
    function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
            return "hidden" === $.css(this, "visibility");
        }).length;
    }
    var uuid = 0, runiqueId = /^ui-id-\d+$/;
    // prevent duplicate loading
    // this is only a problem because we proxy existing functions
    // and we don't want to double proxy them
    $.ui = $.ui || {}, $.ui.version || ($.extend($.ui, {
        version: "1.10.0",
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            NUMPAD_ADD: 107,
            NUMPAD_DECIMAL: 110,
            NUMPAD_DIVIDE: 111,
            NUMPAD_ENTER: 108,
            NUMPAD_MULTIPLY: 106,
            NUMPAD_SUBTRACT: 109,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    }), // plugins
    $.fn.extend({
        _focus: $.fn.focus,
        focus: function(delay, fn) {
            return "number" == typeof delay ? this.each(function() {
                var elem = this;
                setTimeout(function() {
                    $(elem).focus(), fn && fn.call(elem);
                }, delay);
            }) : this._focus.apply(this, arguments);
        },
        scrollParent: function() {
            var scrollParent;
            return scrollParent = $.ui.ie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position")) ? this.parents().filter(function() {
                return /(relative|absolute|fixed)/.test($.css(this, "position")) && /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
            }).eq(0) : this.parents().filter(function() {
                return /(auto|scroll)/.test($.css(this, "overflow") + $.css(this, "overflow-y") + $.css(this, "overflow-x"));
            }).eq(0), /fixed/.test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
        },
        zIndex: function(zIndex) {
            if (zIndex !== undefined) return this.css("zIndex", zIndex);
            if (this.length) for (var position, value, elem = $(this[0]); elem.length && elem[0] !== document; ) {
                if (// Ignore z-index if position is set to a value where z-index is ignored by the browser
                // This makes behavior of this function consistent across browsers
                // WebKit always returns auto if the element is positioned
                position = elem.css("position"), ("absolute" === position || "relative" === position || "fixed" === position) && (// IE returns 0 when zIndex is not specified
                // other browsers return a string
                // we ignore the case of nested elements with an explicit value of 0
                // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                value = parseInt(elem.css("zIndex"), 10), !isNaN(value) && 0 !== value)) return value;
                elem = elem.parent();
            }
            return 0;
        },
        uniqueId: function() {
            return this.each(function() {
                this.id || (this.id = "ui-id-" + ++uuid);
            });
        },
        removeUniqueId: function() {
            return this.each(function() {
                runiqueId.test(this.id) && $(this).removeAttr("id");
            });
        }
    }), $.extend($.expr[":"], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
            return function(elem) {
                return !!$.data(elem, dataName);
            };
        }) : // support: jQuery <1.8
        function(elem, i, match) {
            return !!$.data(elem, match[3]);
        },
        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"), isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    }), // support: jQuery <1.8
    $("<a>").outerWidth(1).jquery || $.each([ "Width", "Height" ], function(i, name) {
        function reduce(elem, size, border, margin) {
            return $.each(side, function() {
                size -= parseFloat($.css(elem, "padding" + this)) || 0, border && (size -= parseFloat($.css(elem, "border" + this + "Width")) || 0), 
                margin && (size -= parseFloat($.css(elem, "margin" + this)) || 0);
            }), size;
        }
        var side = "Width" === name ? [ "Left", "Right" ] : [ "Top", "Bottom" ], type = name.toLowerCase(), orig = {
            innerWidth: $.fn.innerWidth,
            innerHeight: $.fn.innerHeight,
            outerWidth: $.fn.outerWidth,
            outerHeight: $.fn.outerHeight
        };
        $.fn["inner" + name] = function(size) {
            return size === undefined ? orig["inner" + name].call(this) : this.each(function() {
                $(this).css(type, reduce(this, size) + "px");
            });
        }, $.fn["outer" + name] = function(size, margin) {
            return "number" != typeof size ? orig["outer" + name].call(this, size) : this.each(function() {
                $(this).css(type, reduce(this, size, !0, margin) + "px");
            });
        };
    }), // support: jQuery <1.8
    $.fn.addBack || ($.fn.addBack = function(selector) {
        return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
    }), // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
    $("<a>").data("a-b", "a").removeData("a-b").data("a-b") && ($.fn.removeData = function(removeData) {
        return function(key) {
            return arguments.length ? removeData.call(this, $.camelCase(key)) : removeData.call(this);
        };
    }($.fn.removeData)), // deprecated
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase()), $.support.selectstart = "onselectstart" in document.createElement("div"), 
    $.fn.extend({
        disableSelection: function() {
            return this.bind(($.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function(event) {
                event.preventDefault();
            });
        },
        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        }
    }), $.extend($.ui, {
        // $.ui.plugin is deprecated.  Use the proxy pattern instead.
        plugin: {
            add: function(module, option, set) {
                var i, proto = $.ui[module].prototype;
                for (i in set) proto.plugins[i] = proto.plugins[i] || [], proto.plugins[i].push([ option, set[i] ]);
            },
            call: function(instance, name, args) {
                var i, set = instance.plugins[name];
                if (set && instance.element[0].parentNode && 11 !== instance.element[0].parentNode.nodeType) for (i = 0; i < set.length; i++) instance.options[set[i][0]] && set[i][1].apply(instance.element, args);
            }
        },
        // only used by resizable
        hasScroll: function(el, a) {
            //If overflow is hidden, the element might have extra content, but the user wants to hide it
            if ("hidden" === $(el).css("overflow")) return !1;
            var scroll = a && "left" === a ? "scrollLeft" : "scrollTop", has = !1;
            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            return el[scroll] > 0 ? !0 : (el[scroll] = 1, has = el[scroll] > 0, el[scroll] = 0, 
            has);
        }
    }));
}(jQuery), function($, undefined) {
    var uuid = 0, slice = Array.prototype.slice, _cleanData = $.cleanData;
    $.cleanData = function(elems) {
        for (var elem, i = 0; null != (elem = elems[i]); i++) try {
            $(elem).triggerHandler("remove");
        } catch (e) {}
        _cleanData(elems);
    }, $.widget = function(name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype, // proxiedPrototype allows the provided prototype to remain unmodified
        // so that it can be used as a mixin for multiple widgets (#8876)
        proxiedPrototype = {}, namespace = name.split(".")[0];
        name = name.split(".")[1], fullName = namespace + "-" + name, prototype || (prototype = base, 
        base = $.Widget), // create selector for plugin
        $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName);
        }, $[namespace] = $[namespace] || {}, existingConstructor = $[namespace][name], 
        constructor = $[namespace][name] = function(options, element) {
            // allow instantiation without "new" keyword
            // allow instantiation without "new" keyword
            // allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            return this._createWidget ? void (arguments.length && this._createWidget(options, element)) : new constructor(options, element);
        }, // extend with the existing constructor to carry over any static properties
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            // copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),
            // track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        }), basePrototype = new base(), // we need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend({}, basePrototype.options), $.each(prototype, function(prop, value) {
            return $.isFunction(value) ? void (proxiedPrototype[prop] = function() {
                var _super = function() {
                    return base.prototype[prop].apply(this, arguments);
                }, _superApply = function(args) {
                    return base.prototype[prop].apply(this, args);
                };
                return function() {
                    var returnValue, __super = this._super, __superApply = this._superApply;
                    return this._super = _super, this._superApply = _superApply, returnValue = value.apply(this, arguments), 
                    this._super = __super, this._superApply = __superApply, returnValue;
                };
            }()) : void (proxiedPrototype[prop] = value);
        }), constructor.prototype = $.widget.extend(basePrototype, {
            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        }), // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        existingConstructor ? ($.each(existingConstructor._childConstructors, function(i, child) {
            var childPrototype = child.prototype;
            // redefine the child widget using the same prototype that was
            // originally used, but inherit from the new version of the base
            $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
        }), // remove the list of existing child constructors from the old constructor
        // so the old child constructors can be garbage collected
        delete existingConstructor._childConstructors) : base._childConstructors.push(constructor), 
        $.widget.bridge(name, constructor);
    }, $.widget.extend = function(target) {
        for (var key, value, input = slice.call(arguments, 1), inputIndex = 0, inputLength = input.length; inputLength > inputIndex; inputIndex++) for (key in input[inputIndex]) value = input[inputIndex][key], 
        input[inputIndex].hasOwnProperty(key) && value !== undefined && (// Clone objects
        target[key] = $.isPlainObject(value) ? $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : // Don't extend strings, arrays, etc. with objects
        $.widget.extend({}, value) : value);
        return target;
    }, $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = "string" == typeof options, args = slice.call(arguments, 1), returnValue = this;
            // allow multiple hashes to be passed on init
            return options = !isMethodCall && args.length ? $.widget.extend.apply(null, [ options ].concat(args)) : options, 
            this.each(isMethodCall ? function() {
                var methodValue, instance = $.data(this, fullName);
                return instance ? $.isFunction(instance[options]) && "_" !== options.charAt(0) ? (methodValue = instance[options].apply(instance, args), 
                methodValue !== instance && methodValue !== undefined ? (returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue, 
                !1) : void 0) : $.error("no such method '" + options + "' for " + name + " widget instance") : $.error("cannot call methods on " + name + " prior to initialization; attempted to call method '" + options + "'");
            } : function() {
                var instance = $.data(this, fullName);
                instance ? instance.option(options || {})._init() : $.data(this, fullName, new object(options, this));
            }), returnValue;
        };
    }, $.Widget = function() {}, $.Widget._childConstructors = [], $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: !1,
            // callbacks
            create: null
        },
        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0], this.element = $(element), 
            this.uuid = uuid++, this.eventNamespace = "." + this.widgetName + this.uuid, this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options), 
            this.bindings = $(), this.hoverable = $(), this.focusable = $(), element !== this && ($.data(element, this.widgetFullName, this), 
            this._on(!0, this.element, {
                remove: function(event) {
                    event.target === element && this.destroy();
                }
            }), this.document = $(element.style ? // element within the document
            element.ownerDocument : // element is window or document
            element.document || element), this.window = $(this.document[0].defaultView || this.document[0].parentWindow)), 
            this._create(), this._trigger("create", null, this._getCreateEventData()), this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,
        destroy: function() {
            this._destroy(), // we can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName)), 
            this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled ui-state-disabled"), 
            // clean up events and states
            this.bindings.unbind(this.eventNamespace), this.hoverable.removeClass("ui-state-hover"), 
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,
        widget: function() {
            return this.element;
        },
        option: function(key, value) {
            var parts, curOption, i, options = key;
            if (0 === arguments.length) // don't return a reference to the internal hash
            return $.widget.extend({}, this.options);
            if ("string" == typeof key) if (// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
            options = {}, parts = key.split("."), key = parts.shift(), parts.length) {
                for (curOption = options[key] = $.widget.extend({}, this.options[key]), i = 0; i < parts.length - 1; i++) curOption[parts[i]] = curOption[parts[i]] || {}, 
                curOption = curOption[parts[i]];
                if (key = parts.pop(), value === undefined) return curOption[key] === undefined ? null : curOption[key];
                curOption[key] = value;
            } else {
                if (value === undefined) return this.options[key] === undefined ? null : this.options[key];
                options[key] = value;
            }
            return this._setOptions(options), this;
        },
        _setOptions: function(options) {
            var key;
            for (key in options) this._setOption(key, options[key]);
            return this;
        },
        _setOption: function(key, value) {
            return this.options[key] = value, "disabled" === key && (this.widget().toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value).attr("aria-disabled", value), 
            this.hoverable.removeClass("ui-state-hover"), this.focusable.removeClass("ui-state-focus")), 
            this;
        },
        enable: function() {
            return this._setOption("disabled", !1);
        },
        disable: function() {
            return this._setOption("disabled", !0);
        },
        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement, instance = this;
            // no suppressDisabledCheck flag, shuffle arguments
            "boolean" != typeof suppressDisabledCheck && (handlers = element, element = suppressDisabledCheck, 
            suppressDisabledCheck = !1), // no element argument, shuffle and use this.element
            handlers ? (// accept selectors, DOM elements
            element = delegateElement = $(element), this.bindings = this.bindings.add(element)) : (handlers = element, 
            element = this.element, delegateElement = this.widget()), $.each(handlers, function(event, handler) {
                function handlerProxy() {
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    return suppressDisabledCheck || instance.options.disabled !== !0 && !$(this).hasClass("ui-state-disabled") ? ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments) : void 0;
                }
                // copy the guid so direct unbinding works
                "string" != typeof handler && (handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++);
                var match = event.match(/^(\w+)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
                selector ? delegateElement.delegate(selector, eventName, handlerProxy) : element.bind(eventName, handlerProxy);
            });
        },
        _off: function(element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace, 
            element.unbind(eventName).undelegate(eventName);
        },
        _delay: function(handler, delay) {
            function handlerProxy() {
                return ("string" == typeof handler ? instance[handler] : handler).apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },
        _hoverable: function(element) {
            this.hoverable = this.hoverable.add(element), this._on(element, {
                mouseenter: function(event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function(event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },
        _focusable: function(element) {
            this.focusable = this.focusable.add(element), this._on(element, {
                focusin: function(event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function(event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },
        _trigger: function(type, event, data) {
            var prop, orig, callback = this.options[type];
            if (data = data || {}, event = $.Event(event), event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase(), 
            // the original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0], // copy original event properties over to the new event
            orig = event.originalEvent) for (prop in orig) prop in event || (event[prop] = orig[prop]);
            return this.element.trigger(event, data), !($.isFunction(callback) && callback.apply(this.element[0], [ event ].concat(data)) === !1 || event.isDefaultPrevented());
        }
    }, $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            "string" == typeof options && (options = {
                effect: options
            });
            var hasOptions, effectName = options ? options === !0 || "number" == typeof options ? defaultEffect : options.effect || defaultEffect : method;
            options = options || {}, "number" == typeof options && (options = {
                duration: options
            }), hasOptions = !$.isEmptyObject(options), options.complete = callback, options.delay && element.delay(options.delay), 
            hasOptions && $.effects && $.effects.effect[effectName] ? element[method](options) : effectName !== method && element[effectName] ? element[effectName](options.duration, options.easing, callback) : element.queue(function(next) {
                $(this)[method](), callback && callback.call(element[0]), next();
            });
        };
    });
}(jQuery), function($) {
    var mouseHandled = !1;
    $(document).mouseup(function() {
        mouseHandled = !1;
    }), $.widget("ui.mouse", {
        version: "1.10.0",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;
            this.element.bind("mousedown." + this.widgetName, function(event) {
                return that._mouseDown(event);
            }).bind("click." + this.widgetName, function(event) {
                return !0 === $.data(event.target, that.widgetName + ".preventClickEvent") ? ($.removeData(event.target, that.widgetName + ".preventClickEvent"), 
                event.stopImmediatePropagation(), !1) : void 0;
            }), this.started = !1;
        },
        // TODO: make sure destroying one instance of mouse doesn't mess with
        // other instances of mouse
        _mouseDestroy: function() {
            this.element.unbind("." + this.widgetName), this._mouseMoveDelegate && $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
        },
        _mouseDown: function(event) {
            // don't let more than one widget handle mouseStart
            if (!mouseHandled) {
                // we may have missed mouseup (out of window)
                this._mouseStarted && this._mouseUp(event), this._mouseDownEvent = event;
                var that = this, btnIsLeft = 1 === event.which, // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel = "string" == typeof this.options.cancel && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : !1;
                // Click event may never have fired (Gecko & Opera)
                // these delegates are required to keep context
                return btnIsLeft && !elIsCancel && this._mouseCapture(event) ? (this.mouseDelayMet = !this.options.delay, 
                this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function() {
                    that.mouseDelayMet = !0;
                }, this.options.delay)), this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(event) !== !1, 
                !this._mouseStarted) ? (event.preventDefault(), !0) : (!0 === $.data(event.target, this.widgetName + ".preventClickEvent") && $.removeData(event.target, this.widgetName + ".preventClickEvent"), 
                this._mouseMoveDelegate = function(event) {
                    return that._mouseMove(event);
                }, this._mouseUpDelegate = function(event) {
                    return that._mouseUp(event);
                }, $(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate), 
                event.preventDefault(), mouseHandled = !0, !0)) : !0;
            }
        },
        _mouseMove: function(event) {
            // IE mouseup check - mouseup happened when mouse was out of window
            // IE mouseup check - mouseup happened when mouse was out of window
            return $.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button ? this._mouseUp(event) : this._mouseStarted ? (this._mouseDrag(event), 
            event.preventDefault()) : (this._mouseDistanceMet(event) && this._mouseDelayMet(event) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== !1, 
            this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event)), !this._mouseStarted);
        },
        _mouseUp: function(event) {
            return $(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate), 
            this._mouseStarted && (this._mouseStarted = !1, event.target === this._mouseDownEvent.target && $.data(event.target, this.widgetName + ".preventClickEvent", !0), 
            this._mouseStop(event)), !1;
        },
        _mouseDistanceMet: function(event) {
            return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
        },
        _mouseDelayMet: function() {
            return this.mouseDelayMet;
        },
        // These are placeholder methods, to be overriden by extending plugin
        _mouseStart: function() {},
        _mouseDrag: function() {},
        _mouseStop: function() {},
        _mouseCapture: function() {
            return !0;
        }
    });
}(jQuery), function($) {
    $.widget("ui.draggable", $.ui.mouse, {
        version: "1.10.0",
        widgetEventPrefix: "drag",
        options: {
            addClasses: !0,
            appendTo: "parent",
            axis: !1,
            connectToSortable: !1,
            containment: !1,
            cursor: "auto",
            cursorAt: !1,
            grid: !1,
            handle: !1,
            helper: "original",
            iframeFix: !1,
            opacity: !1,
            refreshPositions: !1,
            revert: !1,
            revertDuration: 500,
            scope: "default",
            scroll: !0,
            scrollSensitivity: 20,
            scrollSpeed: 20,
            snap: !1,
            snapMode: "both",
            snapTolerance: 20,
            stack: !1,
            zIndex: !1,
            // callbacks
            drag: null,
            start: null,
            stop: null
        },
        _create: function() {
            "original" !== this.options.helper || /^(?:r|a|f)/.test(this.element.css("position")) || (this.element[0].style.position = "relative"), 
            this.options.addClasses && this.element.addClass("ui-draggable"), this.options.disabled && this.element.addClass("ui-draggable-disabled"), 
            this._mouseInit();
        },
        _destroy: function() {
            this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"), 
            this._mouseDestroy();
        },
        _mouseCapture: function(event) {
            var o = this.options;
            // among others, prevent a drag on a resizable-handle
            // among others, prevent a drag on a resizable-handle
            //Quit if we're not on a valid handle
            return this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0 ? !1 : (this.handle = this._getHandle(event), 
            this.handle ? ($(o.iframeFix === !0 ? "iframe" : o.iframeFix).each(function() {
                $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>").css({
                    width: this.offsetWidth + "px",
                    height: this.offsetHeight + "px",
                    position: "absolute",
                    opacity: "0.001",
                    zIndex: 1e3
                }).css($(this).offset()).appendTo("body");
            }), !0) : !1);
        },
        _mouseStart: function(event) {
            var o = this.options;
            //Trigger event + callbacks
            //Create and append the visible helper
            //Cache the helper size
            //If ddmanager is used for droppables, set the global draggable
            /*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */
            //Cache the margins of the original element
            //Store the helper's css position
            //The element's absolute position on the page minus margins
            //Generate the original position
            //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
            //Set a containment if given in the options
            //Trigger event + callbacks
            //Recache the helper size
            //Prepare the droppable offsets
            //Execute the drag once - this causes the helper not to be visible before getting its correct position
            //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
            return this.helper = this._createHelper(event), this.helper.addClass("ui-draggable-dragging"), 
            this._cacheHelperProportions(), $.ui.ddmanager && ($.ui.ddmanager.current = this), 
            this._cacheMargins(), this.cssPosition = this.helper.css("position"), this.scrollParent = this.helper.scrollParent(), 
            this.offset = this.positionAbs = this.element.offset(), this.offset = {
                top: this.offset.top - this.margins.top,
                left: this.offset.left - this.margins.left
            }, $.extend(this.offset, {
                click: {
                    //Where the click happened, relative to the element
                    left: event.pageX - this.offset.left,
                    top: event.pageY - this.offset.top
                },
                parent: this._getParentOffset(),
                relative: this._getRelativeOffset()
            }), this.originalPosition = this.position = this._generatePosition(event), this.originalPageX = event.pageX, 
            this.originalPageY = event.pageY, o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt), 
            o.containment && this._setContainment(), this._trigger("start", event) === !1 ? (this._clear(), 
            !1) : (this._cacheHelperProportions(), $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(this, event), 
            this._mouseDrag(event, !0), $.ui.ddmanager && $.ui.ddmanager.dragStart(this, event), 
            !0);
        },
        _mouseDrag: function(event, noPropagation) {
            //Call plugins and callbacks and use the resulting position if something is returned
            if (//Compute the helpers position
            this.position = this._generatePosition(event), this.positionAbs = this._convertPositionTo("absolute"), 
            !noPropagation) {
                var ui = this._uiHash();
                if (this._trigger("drag", event, ui) === !1) return this._mouseUp({}), !1;
                this.position = ui.position;
            }
            return this.options.axis && "y" === this.options.axis || (this.helper[0].style.left = this.position.left + "px"), 
            this.options.axis && "x" === this.options.axis || (this.helper[0].style.top = this.position.top + "px"), 
            $.ui.ddmanager && $.ui.ddmanager.drag(this, event), !1;
        },
        _mouseStop: function(event) {
            //If we are using droppables, inform the manager about the drop
            var element, that = this, elementInDom = !1, dropped = !1;
            for ($.ui.ddmanager && !this.options.dropBehaviour && (dropped = $.ui.ddmanager.drop(this, event)), 
            //if a drop comes from outside (a sortable)
            this.dropped && (dropped = this.dropped, this.dropped = !1), //if the original element is no longer in the DOM don't bother to continue (see #8269)
            element = this.element[0]; element && (element = element.parentNode); ) element === document && (elementInDom = !0);
            return elementInDom || "original" !== this.options.helper ? ("invalid" === this.options.revert && !dropped || "valid" === this.options.revert && dropped || this.options.revert === !0 || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped) ? $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
                that._trigger("stop", event) !== !1 && that._clear();
            }) : this._trigger("stop", event) !== !1 && this._clear(), !1) : !1;
        },
        _mouseUp: function(event) {
            //Remove frame helpers
            //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
            return $("div.ui-draggable-iframeFix").each(function() {
                this.parentNode.removeChild(this);
            }), $.ui.ddmanager && $.ui.ddmanager.dragStop(this, event), $.ui.mouse.prototype._mouseUp.call(this, event);
        },
        cancel: function() {
            return this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear(), 
            this;
        },
        _getHandle: function(event) {
            var handle = this.options.handle && $(this.options.handle, this.element).length ? !1 : !0;
            return $(this.options.handle, this.element).find("*").addBack().each(function() {
                this === event.target && (handle = !0);
            }), handle;
        },
        _createHelper: function(event) {
            var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [ event ])) : "clone" === o.helper ? this.element.clone().removeAttr("id") : this.element;
            return helper.parents("body").length || helper.appendTo("parent" === o.appendTo ? this.element[0].parentNode : o.appendTo), 
            helper[0] === this.element[0] || /(fixed|absolute)/.test(helper.css("position")) || helper.css("position", "absolute"), 
            helper;
        },
        _adjustOffsetFromHelper: function(obj) {
            "string" == typeof obj && (obj = obj.split(" ")), $.isArray(obj) && (obj = {
                left: +obj[0],
                top: +obj[1] || 0
            }), "left" in obj && (this.offset.click.left = obj.left + this.margins.left), "right" in obj && (this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left), 
            "top" in obj && (this.offset.click.top = obj.top + this.margins.top), "bottom" in obj && (this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top);
        },
        _getParentOffset: function() {
            //Get the offsetParent and cache its position
            this.offsetParent = this.helper.offsetParent();
            var po = this.offsetParent.offset();
            // This is a special case where we need to modify a offset calculated on start, since the following happened:
            // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
            // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
            //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
            //This needs to be actually done for all browsers, since pageX/pageY includes this information
            //Ugly IE fix
            return "absolute" === this.cssPosition && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) && (po.left += this.scrollParent.scrollLeft(), 
            po.top += this.scrollParent.scrollTop()), (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && "html" === this.offsetParent[0].tagName.toLowerCase() && $.ui.ie) && (po = {
                top: 0,
                left: 0
            }), {
                top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
                left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
            };
        },
        _getRelativeOffset: function() {
            if ("relative" === this.cssPosition) {
                var p = this.element.position();
                return {
                    top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
                    left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                };
            }
            return {
                top: 0,
                left: 0
            };
        },
        _cacheMargins: function() {
            this.margins = {
                left: parseInt(this.element.css("marginLeft"), 10) || 0,
                top: parseInt(this.element.css("marginTop"), 10) || 0,
                right: parseInt(this.element.css("marginRight"), 10) || 0,
                bottom: parseInt(this.element.css("marginBottom"), 10) || 0
            };
        },
        _cacheHelperProportions: function() {
            this.helperProportions = {
                width: this.helper.outerWidth(),
                height: this.helper.outerHeight()
            };
        },
        _setContainment: function() {
            var over, c, ce, o = this.options;
            if ("parent" === o.containment && (o.containment = this.helper[0].parentNode), ("document" === o.containment || "window" === o.containment) && (this.containment = [ "document" === o.containment ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, "document" === o.containment ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, ("document" === o.containment ? 0 : $(window).scrollLeft()) + $("document" === o.containment ? document : window).width() - this.helperProportions.width - this.margins.left, ("document" === o.containment ? 0 : $(window).scrollTop()) + ($("document" === o.containment ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top ]), 
            /^(document|window|parent)$/.test(o.containment) || o.containment.constructor === Array) o.containment.constructor === Array && (this.containment = o.containment); else {
                if (c = $(o.containment), ce = c[0], !ce) return;
                over = "hidden" !== $(ce).css("overflow"), this.containment = [ (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0), (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0), (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom ], 
                this.relative_container = c;
            }
        },
        _convertPositionTo: function(d, pos) {
            pos || (pos = this.position);
            var mod = "absolute" === d ? 1 : -1, scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
            return {
                top: pos.top + // The absolute mouse position
                this.offset.relative.top * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top * mod - // The offsetParent's offset without borders (offset + border)
                ("fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
                left: pos.left + // The absolute mouse position
                this.offset.relative.left * mod + // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left * mod - // The offsetParent's offset without borders (offset + border)
                ("fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
            };
        },
        _generatePosition: function(event) {
            var containment, co, top, left, o = this.options, scroll = "absolute" !== this.cssPosition || this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0]) ? this.scrollParent : this.offsetParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName), pageX = event.pageX, pageY = event.pageY;
            /*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */
            //If we are not dragging yet, we won't check for options
            //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
            return this.originalPosition && (this.containment && (this.relative_container ? (co = this.relative_container.offset(), 
            containment = [ this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top ]) : containment = this.containment, 
            event.pageX - this.offset.click.left < containment[0] && (pageX = containment[0] + this.offset.click.left), 
            event.pageY - this.offset.click.top < containment[1] && (pageY = containment[1] + this.offset.click.top), 
            event.pageX - this.offset.click.left > containment[2] && (pageX = containment[2] + this.offset.click.left), 
            event.pageY - this.offset.click.top > containment[3] && (pageY = containment[3] + this.offset.click.top)), 
            o.grid && (top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY, 
            pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top, 
            left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX, 
            pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left)), 
            {
                top: pageY - // The absolute mouse position
                this.offset.click.top - // Click offset (relative to the element)
                this.offset.relative.top - // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.top + (// The offsetParent's offset without borders (offset + border)
                "fixed" === this.cssPosition ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
                left: pageX - // The absolute mouse position
                this.offset.click.left - // Click offset (relative to the element)
                this.offset.relative.left - // Only for relative positioned nodes: Relative offset from element to offset parent
                this.offset.parent.left + (// The offsetParent's offset without borders (offset + border)
                "fixed" === this.cssPosition ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
            };
        },
        _clear: function() {
            this.helper.removeClass("ui-draggable-dragging"), this.helper[0] === this.element[0] || this.cancelHelperRemoval || this.helper.remove(), 
            this.helper = null, this.cancelHelperRemoval = !1;
        },
        // From now on bulk stuff - mainly helpers
        _trigger: function(type, event, ui) {
            //The absolute position has to be recalculated after plugins
            return ui = ui || this._uiHash(), $.ui.plugin.call(this, type, [ event, ui ]), "drag" === type && (this.positionAbs = this._convertPositionTo("absolute")), 
            $.Widget.prototype._trigger.call(this, type, event, ui);
        },
        plugins: {},
        _uiHash: function() {
            return {
                helper: this.helper,
                position: this.position,
                originalPosition: this.originalPosition,
                offset: this.positionAbs
            };
        }
    }), $.ui.plugin.add("draggable", "connectToSortable", {
        start: function(event, ui) {
            var inst = $(this).data("ui-draggable"), o = inst.options, uiSortable = $.extend({}, ui, {
                item: inst.element
            });
            inst.sortables = [], $(o.connectToSortable).each(function() {
                var sortable = $.data(this, "ui-sortable");
                sortable && !sortable.options.disabled && (inst.sortables.push({
                    instance: sortable,
                    shouldRevert: sortable.options.revert
                }), sortable.refreshPositions(), // Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
                sortable._trigger("activate", event, uiSortable));
            });
        },
        stop: function(event, ui) {
            //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
            var inst = $(this).data("ui-draggable"), uiSortable = $.extend({}, ui, {
                item: inst.element
            });
            $.each(inst.sortables, function() {
                this.instance.isOver ? (this.instance.isOver = 0, inst.cancelHelperRemoval = !0, 
                //Don't remove the helper in the draggable instance
                this.instance.cancelHelperRemoval = !1, //Remove it in the sortable instance (so sortable plugins like revert still work)
                //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
                this.shouldRevert && (this.instance.options.revert = !0), //Trigger the stop of the sortable
                this.instance._mouseStop(event), this.instance.options.helper = this.instance.options._helper, 
                //If the helper has been the original item, restore properties in the sortable
                "original" === inst.options.helper && this.instance.currentItem.css({
                    top: "auto",
                    left: "auto"
                })) : (this.instance.cancelHelperRemoval = !1, //Remove the helper in the sortable instance
                this.instance._trigger("deactivate", event, uiSortable));
            });
        },
        drag: function(event, ui) {
            var inst = $(this).data("ui-draggable"), that = this;
            $.each(inst.sortables, function() {
                var innermostIntersecting = !1, thisSortable = this;
                //Copy over some variables to allow calling the sortable's native _intersectsWith
                this.instance.positionAbs = inst.positionAbs, this.instance.helperProportions = inst.helperProportions, 
                this.instance.offset.click = inst.offset.click, this.instance._intersectsWith(this.instance.containerCache) && (innermostIntersecting = !0, 
                $.each(inst.sortables, function() {
                    return this.instance.positionAbs = inst.positionAbs, this.instance.helperProportions = inst.helperProportions, 
                    this.instance.offset.click = inst.offset.click, this !== thisSortable && this.instance._intersectsWith(this.instance.containerCache) && $.ui.contains(thisSortable.instance.element[0], this.instance.element[0]) && (innermostIntersecting = !1), 
                    innermostIntersecting;
                })), innermostIntersecting ? (//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
                this.instance.isOver || (this.instance.isOver = 1, //Now we fake the start of dragging for the sortable instance,
                //by cloning the list group item, appending it to the sortable and using it as inst.currentItem
                //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
                this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", !0), 
                this.instance.options._helper = this.instance.options.helper, //Store helper option to later restore it
                this.instance.options.helper = function() {
                    return ui.helper[0];
                }, event.target = this.instance.currentItem[0], this.instance._mouseCapture(event, !0), 
                this.instance._mouseStart(event, !0, !0), //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
                this.instance.offset.click.top = inst.offset.click.top, this.instance.offset.click.left = inst.offset.click.left, 
                this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left, 
                this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top, 
                inst._trigger("toSortable", event), inst.dropped = this.instance.element, //draggable revert needs that
                //hack so receive/update callbacks work (mostly)
                inst.currentItem = inst.element, this.instance.fromOutside = inst), //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
                this.instance.currentItem && this.instance._mouseDrag(event)) : //If it doesn't intersect with the sortable, and it intersected before,
                //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
                this.instance.isOver && (this.instance.isOver = 0, this.instance.cancelHelperRemoval = !0, 
                //Prevent reverting on this forced stop
                this.instance.options.revert = !1, // The out event needs to be triggered independently
                this.instance._trigger("out", event, this.instance._uiHash(this.instance)), this.instance._mouseStop(event, !0), 
                this.instance.options.helper = this.instance.options._helper, //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
                this.instance.currentItem.remove(), this.instance.placeholder && this.instance.placeholder.remove(), 
                inst._trigger("fromSortable", event), inst.dropped = !1);
            });
        }
    }), $.ui.plugin.add("draggable", "cursor", {
        start: function() {
            var t = $("body"), o = $(this).data("ui-draggable").options;
            t.css("cursor") && (o._cursor = t.css("cursor")), t.css("cursor", o.cursor);
        },
        stop: function() {
            var o = $(this).data("ui-draggable").options;
            o._cursor && $("body").css("cursor", o._cursor);
        }
    }), $.ui.plugin.add("draggable", "opacity", {
        start: function(event, ui) {
            var t = $(ui.helper), o = $(this).data("ui-draggable").options;
            t.css("opacity") && (o._opacity = t.css("opacity")), t.css("opacity", o.opacity);
        },
        stop: function(event, ui) {
            var o = $(this).data("ui-draggable").options;
            o._opacity && $(ui.helper).css("opacity", o._opacity);
        }
    }), $.ui.plugin.add("draggable", "scroll", {
        start: function() {
            var i = $(this).data("ui-draggable");
            i.scrollParent[0] !== document && "HTML" !== i.scrollParent[0].tagName && (i.overflowOffset = i.scrollParent.offset());
        },
        drag: function(event) {
            var i = $(this).data("ui-draggable"), o = i.options, scrolled = !1;
            i.scrollParent[0] !== document && "HTML" !== i.scrollParent[0].tagName ? (o.axis && "x" === o.axis || (i.overflowOffset.top + i.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity ? i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed : event.pageY - i.overflowOffset.top < o.scrollSensitivity && (i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed)), 
            o.axis && "y" === o.axis || (i.overflowOffset.left + i.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity ? i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed : event.pageX - i.overflowOffset.left < o.scrollSensitivity && (i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed))) : (o.axis && "x" === o.axis || (event.pageY - $(document).scrollTop() < o.scrollSensitivity ? scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed) : $(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity && (scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed))), 
            o.axis && "y" === o.axis || (event.pageX - $(document).scrollLeft() < o.scrollSensitivity ? scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed) : $(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity && (scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed)))), 
            scrolled !== !1 && $.ui.ddmanager && !o.dropBehaviour && $.ui.ddmanager.prepareOffsets(i, event);
        }
    }), $.ui.plugin.add("draggable", "snap", {
        start: function() {
            var i = $(this).data("ui-draggable"), o = i.options;
            i.snapElements = [], $(o.snap.constructor !== String ? o.snap.items || ":data(ui-draggable)" : o.snap).each(function() {
                var $t = $(this), $o = $t.offset();
                this !== i.element[0] && i.snapElements.push({
                    item: this,
                    width: $t.outerWidth(),
                    height: $t.outerHeight(),
                    top: $o.top,
                    left: $o.left
                });
            });
        },
        drag: function(event, ui) {
            var ts, bs, ls, rs, l, r, t, b, i, first, inst = $(this).data("ui-draggable"), o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
            for (i = inst.snapElements.length - 1; i >= 0; i--) l = inst.snapElements[i].left, 
            r = l + inst.snapElements[i].width, t = inst.snapElements[i].top, b = t + inst.snapElements[i].height, 
            //Yes, I know, this is insane ;)
            x1 > l - d && r + d > x1 && y1 > t - d && b + d > y1 || x1 > l - d && r + d > x1 && y2 > t - d && b + d > y2 || x2 > l - d && r + d > x2 && y1 > t - d && b + d > y1 || x2 > l - d && r + d > x2 && y2 > t - d && b + d > y2 ? ("inner" !== o.snapMode && (ts = Math.abs(t - y2) <= d, 
            bs = Math.abs(b - y1) <= d, ls = Math.abs(l - x2) <= d, rs = Math.abs(r - x1) <= d, 
            ts && (ui.position.top = inst._convertPositionTo("relative", {
                top: t - inst.helperProportions.height,
                left: 0
            }).top - inst.margins.top), bs && (ui.position.top = inst._convertPositionTo("relative", {
                top: b,
                left: 0
            }).top - inst.margins.top), ls && (ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: l - inst.helperProportions.width
            }).left - inst.margins.left), rs && (ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: r
            }).left - inst.margins.left)), first = ts || bs || ls || rs, "outer" !== o.snapMode && (ts = Math.abs(t - y1) <= d, 
            bs = Math.abs(b - y2) <= d, ls = Math.abs(l - x1) <= d, rs = Math.abs(r - x2) <= d, 
            ts && (ui.position.top = inst._convertPositionTo("relative", {
                top: t,
                left: 0
            }).top - inst.margins.top), bs && (ui.position.top = inst._convertPositionTo("relative", {
                top: b - inst.helperProportions.height,
                left: 0
            }).top - inst.margins.top), ls && (ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: l
            }).left - inst.margins.left), rs && (ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: r - inst.helperProportions.width
            }).left - inst.margins.left)), !inst.snapElements[i].snapping && (ts || bs || ls || rs || first) && inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {
                snapItem: inst.snapElements[i].item
            })), inst.snapElements[i].snapping = ts || bs || ls || rs || first) : (inst.snapElements[i].snapping && inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {
                snapItem: inst.snapElements[i].item
            })), inst.snapElements[i].snapping = !1);
        }
    }), $.ui.plugin.add("draggable", "stack", {
        start: function() {
            var min, o = $(this).data("ui-draggable").options, group = $.makeArray($(o.stack)).sort(function(a, b) {
                return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
            });
            group.length && (min = parseInt(group[0].style.zIndex, 10) || 0, $(group).each(function(i) {
                this.style.zIndex = min + i;
            }), this[0].style.zIndex = min + group.length);
        }
    }), $.ui.plugin.add("draggable", "zIndex", {
        start: function(event, ui) {
            var t = $(ui.helper), o = $(this).data("ui-draggable").options;
            t.css("zIndex") && (o._zIndex = t.css("zIndex")), t.css("zIndex", o.zIndex);
        },
        stop: function(event, ui) {
            var o = $(this).data("ui-draggable").options;
            o._zIndex && $(ui.helper).css("zIndex", o._zIndex);
        }
    });
}(jQuery), function($) {
    function isOverAxis(x, reference, size) {
        return x > reference && reference + size > x;
    }
    $.widget("ui.droppable", {
        version: "1.10.0",
        widgetEventPrefix: "drop",
        options: {
            accept: "*",
            activeClass: !1,
            addClasses: !0,
            greedy: !1,
            hoverClass: !1,
            scope: "default",
            tolerance: "intersect",
            // callbacks
            activate: null,
            deactivate: null,
            drop: null,
            out: null,
            over: null
        },
        _create: function() {
            var o = this.options, accept = o.accept;
            this.isover = !1, this.isout = !0, this.accept = $.isFunction(accept) ? accept : function(d) {
                return d.is(accept);
            }, //Store the droppable's proportions
            this.proportions = {
                width: this.element[0].offsetWidth,
                height: this.element[0].offsetHeight
            }, // Add the reference and positions to the manager
            $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [], $.ui.ddmanager.droppables[o.scope].push(this), 
            o.addClasses && this.element.addClass("ui-droppable");
        },
        _destroy: function() {
            for (var i = 0, drop = $.ui.ddmanager.droppables[this.options.scope]; i < drop.length; i++) drop[i] === this && drop.splice(i, 1);
            this.element.removeClass("ui-droppable ui-droppable-disabled");
        },
        _setOption: function(key, value) {
            "accept" === key && (this.accept = $.isFunction(value) ? value : function(d) {
                return d.is(value);
            }), $.Widget.prototype._setOption.apply(this, arguments);
        },
        _activate: function(event) {
            var draggable = $.ui.ddmanager.current;
            this.options.activeClass && this.element.addClass(this.options.activeClass), draggable && this._trigger("activate", event, this.ui(draggable));
        },
        _deactivate: function(event) {
            var draggable = $.ui.ddmanager.current;
            this.options.activeClass && this.element.removeClass(this.options.activeClass), 
            draggable && this._trigger("deactivate", event, this.ui(draggable));
        },
        _over: function(event) {
            var draggable = $.ui.ddmanager.current;
            // Bail if draggable and droppable are same element
            draggable && (draggable.currentItem || draggable.element)[0] !== this.element[0] && this.accept.call(this.element[0], draggable.currentItem || draggable.element) && (this.options.hoverClass && this.element.addClass(this.options.hoverClass), 
            this._trigger("over", event, this.ui(draggable)));
        },
        _out: function(event) {
            var draggable = $.ui.ddmanager.current;
            // Bail if draggable and droppable are same element
            draggable && (draggable.currentItem || draggable.element)[0] !== this.element[0] && this.accept.call(this.element[0], draggable.currentItem || draggable.element) && (this.options.hoverClass && this.element.removeClass(this.options.hoverClass), 
            this._trigger("out", event, this.ui(draggable)));
        },
        _drop: function(event, custom) {
            var draggable = custom || $.ui.ddmanager.current, childrenIntersection = !1;
            // Bail if draggable and droppable are same element
            // Bail if draggable and droppable are same element
            return draggable && (draggable.currentItem || draggable.element)[0] !== this.element[0] ? (this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
                var inst = $.data(this, "ui-droppable");
                return inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, {
                    offset: inst.element.offset()
                }), inst.options.tolerance) ? (childrenIntersection = !0, !1) : void 0;
            }), childrenIntersection ? !1 : this.accept.call(this.element[0], draggable.currentItem || draggable.element) ? (this.options.activeClass && this.element.removeClass(this.options.activeClass), 
            this.options.hoverClass && this.element.removeClass(this.options.hoverClass), this._trigger("drop", event, this.ui(draggable)), 
            this.element) : !1) : !1;
        },
        ui: function(c) {
            return {
                draggable: c.currentItem || c.element,
                helper: c.helper,
                position: c.position,
                offset: c.positionAbs
            };
        }
    }), $.ui.intersect = function(draggable, droppable, toleranceMode) {
        if (!droppable.offset) return !1;
        var draggableLeft, draggableTop, x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width, y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height, l = droppable.offset.left, r = l + droppable.proportions.width, t = droppable.offset.top, b = t + droppable.proportions.height;
        switch (toleranceMode) {
          case "fit":
            return x1 >= l && r >= x2 && y1 >= t && b >= y2;

          case "intersect":
            // Right Half
            // Left Half
            // Bottom Half
            return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;

          // Top Half
            case "pointer":
            return draggableLeft = (draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left, 
            draggableTop = (draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top, 
            isOverAxis(draggableTop, t, droppable.proportions.height) && isOverAxis(draggableLeft, l, droppable.proportions.width);

          case "touch":
            // Top edge touching
            // Bottom edge touching
            // Left edge touching
            // Right edge touching
            return (y1 >= t && b >= y1 || y2 >= t && b >= y2 || t > y1 && y2 > b) && (x1 >= l && r >= x1 || x2 >= l && r >= x2 || l > x1 && x2 > r);

          default:
            return !1;
        }
    }, /*
	This manager tracks offsets of draggables and droppables
*/
    $.ui.ddmanager = {
        current: null,
        droppables: {
            "default": []
        },
        prepareOffsets: function(t, event) {
            var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [], type = event ? event.type : null, // workaround for #2317
            list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
            droppablesLoop: for (i = 0; i < m.length; i++) //No disabled and non-accepted
            if (!(m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element))) {
                // Filter out elements in the current dragged item
                for (j = 0; j < list.length; j++) if (list[j] === m[i].element[0]) {
                    m[i].proportions.height = 0;
                    continue droppablesLoop;
                }
                m[i].visible = "none" !== m[i].element.css("display"), m[i].visible && (//Activate the droppable if used directly from draggables
                "mousedown" === type && m[i]._activate.call(m[i], event), m[i].offset = m[i].element.offset(), 
                m[i].proportions = {
                    width: m[i].element[0].offsetWidth,
                    height: m[i].element[0].offsetHeight
                });
            }
        },
        drop: function(draggable, event) {
            var dropped = !1;
            return $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                this.options && (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance) && (dropped = this._drop.call(this, event) || dropped), 
                !this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element) && (this.isout = !0, 
                this.isover = !1, this._deactivate.call(this, event)));
            }), dropped;
        },
        dragStart: function(draggable, event) {
            //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
            draggable.element.parentsUntil("body").bind("scroll.droppable", function() {
                draggable.options.refreshPositions || $.ui.ddmanager.prepareOffsets(draggable, event);
            });
        },
        drag: function(draggable, event) {
            //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
            draggable.options.refreshPositions && $.ui.ddmanager.prepareOffsets(draggable, event), 
            //Run through all droppables and check their positions based on specific tolerance options
            $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
                if (!this.options.disabled && !this.greedyChild && this.visible) {
                    var parentInstance, scope, parent, intersects = $.ui.intersect(draggable, this, this.options.tolerance), c = !intersects && this.isover ? "isout" : intersects && !this.isover ? "isover" : null;
                    c && (this.options.greedy && (// find droppable parents with same scope
                    scope = this.options.scope, parent = this.element.parents(":data(ui-droppable)").filter(function() {
                        return $.data(this, "ui-droppable").options.scope === scope;
                    }), parent.length && (parentInstance = $.data(parent[0], "ui-droppable"), parentInstance.greedyChild = "isover" === c)), 
                    // we just moved into a greedy child
                    parentInstance && "isover" === c && (parentInstance.isover = !1, parentInstance.isout = !0, 
                    parentInstance._out.call(parentInstance, event)), this[c] = !0, this["isout" === c ? "isover" : "isout"] = !1, 
                    this["isover" === c ? "_over" : "_out"].call(this, event), // we just moved out of a greedy child
                    parentInstance && "isout" === c && (parentInstance.isout = !1, parentInstance.isover = !0, 
                    parentInstance._over.call(parentInstance, event)));
                }
            });
        },
        dragStop: function(draggable, event) {
            draggable.element.parentsUntil("body").unbind("scroll.droppable"), //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
            draggable.options.refreshPositions || $.ui.ddmanager.prepareOffsets(draggable, event);
        }
    };
}(jQuery), function($) {
    function num(v) {
        return parseInt(v, 10) || 0;
    }
    function isNumber(value) {
        return !isNaN(parseInt(value, 10));
    }
    $.widget("ui.resizable", $.ui.mouse, {
        version: "1.10.0",
        widgetEventPrefix: "resize",
        options: {
            alsoResize: !1,
            animate: !1,
            animateDuration: "slow",
            animateEasing: "swing",
            aspectRatio: !1,
            autoHide: !1,
            containment: !1,
            ghost: !1,
            grid: !1,
            handles: "e,s,se",
            helper: !1,
            maxHeight: null,
            maxWidth: null,
            minHeight: 10,
            minWidth: 10,
            // See #7960
            zIndex: 90,
            // callbacks
            resize: null,
            start: null,
            stop: null
        },
        _create: function() {
            var n, i, handle, axis, hname, that = this, o = this.options;
            if (this.element.addClass("ui-resizable"), $.extend(this, {
                _aspectRatio: !!o.aspectRatio,
                aspectRatio: o.aspectRatio,
                originalElement: this.element,
                _proportionallyResizeElements: [],
                _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
            }), //Wrap the element if it cannot hold child nodes
            this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i) && (//Create a wrapper element and set the wrapper to the new current internal element
            this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
                position: this.element.css("position"),
                width: this.element.outerWidth(),
                height: this.element.outerHeight(),
                top: this.element.css("top"),
                left: this.element.css("left")
            })), //Overwrite the original this.element
            this.element = this.element.parent().data("ui-resizable", this.element.data("ui-resizable")), 
            this.elementIsWrapper = !0, //Move margins to the wrapper
            this.element.css({
                marginLeft: this.originalElement.css("marginLeft"),
                marginTop: this.originalElement.css("marginTop"),
                marginRight: this.originalElement.css("marginRight"),
                marginBottom: this.originalElement.css("marginBottom")
            }), this.originalElement.css({
                marginLeft: 0,
                marginTop: 0,
                marginRight: 0,
                marginBottom: 0
            }), //Prevent Safari textarea resize
            this.originalResizeStyle = this.originalElement.css("resize"), this.originalElement.css("resize", "none"), 
            //Push the actual element to our proportionallyResize internal array
            this._proportionallyResizeElements.push(this.originalElement.css({
                position: "static",
                zoom: 1,
                display: "block"
            })), // avoid IE jump (hard set the margin)
            this.originalElement.css({
                margin: this.originalElement.css("margin")
            }), // fix handlers offset
            this._proportionallyResize()), this.handles = o.handles || ($(".ui-resizable-handle", this.element).length ? {
                n: ".ui-resizable-n",
                e: ".ui-resizable-e",
                s: ".ui-resizable-s",
                w: ".ui-resizable-w",
                se: ".ui-resizable-se",
                sw: ".ui-resizable-sw",
                ne: ".ui-resizable-ne",
                nw: ".ui-resizable-nw"
            } : "e,s,se"), this.handles.constructor === String) for ("all" === this.handles && (this.handles = "n,e,s,w,se,sw,ne,nw"), 
            n = this.handles.split(","), this.handles = {}, i = 0; i < n.length; i++) handle = $.trim(n[i]), 
            hname = "ui-resizable-" + handle, axis = $("<div class='ui-resizable-handle " + hname + "'></div>"), 
            // Apply zIndex to all handles - see #7960
            axis.css({
                zIndex: o.zIndex
            }), //TODO : What's going on here?
            "se" === handle && axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se"), //Insert into internal handles object and append to element
            this.handles[handle] = ".ui-resizable-" + handle, this.element.append(axis);
            this._renderAxis = function(target) {
                var i, axis, padPos, padWrapper;
                target = target || this.element;
                for (i in this.handles) this.handles[i].constructor === String && (this.handles[i] = $(this.handles[i], this.element).show()), 
                //Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
                this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i) && (axis = $(this.handles[i], this.element), 
                //Checking the correct pad and border
                padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth(), 
                //The padding type i have to apply...
                padPos = [ "padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left" ].join(""), 
                target.css(padPos, padWrapper), this._proportionallyResize()), $(this.handles[i]).length;
            }, //TODO: make renderAxis a prototype function
            this._renderAxis(this.element), this._handles = $(".ui-resizable-handle", this.element).disableSelection(), 
            //Matching axis name
            this._handles.mouseover(function() {
                that.resizing || (this.className && (axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)), 
                //Axis, default = se
                that.axis = axis && axis[1] ? axis[1] : "se");
            }), //If we want to auto hide the elements
            o.autoHide && (this._handles.hide(), $(this.element).addClass("ui-resizable-autohide").mouseenter(function() {
                o.disabled || ($(this).removeClass("ui-resizable-autohide"), that._handles.show());
            }).mouseleave(function() {
                o.disabled || that.resizing || ($(this).addClass("ui-resizable-autohide"), that._handles.hide());
            })), //Initialize the mouse interaction
            this._mouseInit();
        },
        _destroy: function() {
            this._mouseDestroy();
            var wrapper, _destroy = function(exp) {
                $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
            };
            //TODO: Unwrap at same DOM position
            return this.elementIsWrapper && (_destroy(this.element), wrapper = this.element, 
            this.originalElement.css({
                position: wrapper.css("position"),
                width: wrapper.outerWidth(),
                height: wrapper.outerHeight(),
                top: wrapper.css("top"),
                left: wrapper.css("left")
            }).insertAfter(wrapper), wrapper.remove()), this.originalElement.css("resize", this.originalResizeStyle), 
            _destroy(this.originalElement), this;
        },
        _mouseCapture: function(event) {
            var i, handle, capture = !1;
            for (i in this.handles) handle = $(this.handles[i])[0], (handle === event.target || $.contains(handle, event.target)) && (capture = !0);
            return !this.options.disabled && capture;
        },
        _mouseStart: function(event) {
            var curleft, curtop, cursor, o = this.options, iniPos = this.element.position(), el = this.element;
            // bugfix for http://dev.jquery.com/ticket/1749
            //Store needed variables
            //Aspect Ratio
            return this.resizing = !0, /absolute/.test(el.css("position")) ? el.css({
                position: "absolute",
                top: el.css("top"),
                left: el.css("left")
            }) : el.is(".ui-draggable") && el.css({
                position: "absolute",
                top: iniPos.top,
                left: iniPos.left
            }), this._renderProxy(), curleft = num(this.helper.css("left")), curtop = num(this.helper.css("top")), 
            o.containment && (curleft += $(o.containment).scrollLeft() || 0, curtop += $(o.containment).scrollTop() || 0), 
            this.offset = this.helper.offset(), this.position = {
                left: curleft,
                top: curtop
            }, this.size = this._helper ? {
                width: el.outerWidth(),
                height: el.outerHeight()
            } : {
                width: el.width(),
                height: el.height()
            }, this.originalSize = this._helper ? {
                width: el.outerWidth(),
                height: el.outerHeight()
            } : {
                width: el.width(),
                height: el.height()
            }, this.originalPosition = {
                left: curleft,
                top: curtop
            }, this.sizeDiff = {
                width: el.outerWidth() - el.width(),
                height: el.outerHeight() - el.height()
            }, this.originalMousePosition = {
                left: event.pageX,
                top: event.pageY
            }, this.aspectRatio = "number" == typeof o.aspectRatio ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1, 
            cursor = $(".ui-resizable-" + this.axis).css("cursor"), $("body").css("cursor", "auto" === cursor ? this.axis + "-resize" : cursor), 
            el.addClass("ui-resizable-resizing"), this._propagate("start", event), !0;
        },
        _mouseDrag: function(event) {
            //Increase performance, avoid regex
            var data, el = this.helper, props = {}, smp = this.originalMousePosition, a = this.axis, prevTop = this.position.top, prevLeft = this.position.left, prevWidth = this.size.width, prevHeight = this.size.height, dx = event.pageX - smp.left || 0, dy = event.pageY - smp.top || 0, trigger = this._change[a];
            // Calculate the attrs that will be change
            // Put this in the mouseDrag handler since the user can start pressing shift while resizing
            // plugins callbacks need to be called first
            // Call the user callback if the element was resized
            return trigger ? (data = trigger.apply(this, [ event, dx, dy ]), this._updateVirtualBoundaries(event.shiftKey), 
            (this._aspectRatio || event.shiftKey) && (data = this._updateRatio(data, event)), 
            data = this._respectSize(data, event), this._updateCache(data), this._propagate("resize", event), 
            this.position.top !== prevTop && (props.top = this.position.top + "px"), this.position.left !== prevLeft && (props.left = this.position.left + "px"), 
            this.size.width !== prevWidth && (props.width = this.size.width + "px"), this.size.height !== prevHeight && (props.height = this.size.height + "px"), 
            el.css(props), !this._helper && this._proportionallyResizeElements.length && this._proportionallyResize(), 
            $.isEmptyObject(props) || this._trigger("resize", event, this.ui()), !1) : !1;
        },
        _mouseStop: function(event) {
            this.resizing = !1;
            var pr, ista, soffseth, soffsetw, s, left, top, o = this.options, that = this;
            return this._helper && (pr = this._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), 
            soffseth = ista && $.ui.hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, 
            s = {
                width: that.helper.width() - soffsetw,
                height: that.helper.height() - soffseth
            }, left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null, 
            top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null, 
            o.animate || this.element.css($.extend(s, {
                top: top,
                left: left
            })), that.helper.height(that.size.height), that.helper.width(that.size.width), this._helper && !o.animate && this._proportionallyResize()), 
            $("body").css("cursor", "auto"), this.element.removeClass("ui-resizable-resizing"), 
            this._propagate("stop", event), this._helper && this.helper.remove(), !1;
        },
        _updateVirtualBoundaries: function(forceAspectRatio) {
            var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
            b = {
                minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
                maxWidth: isNumber(o.maxWidth) ? o.maxWidth : 1/0,
                minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
                maxHeight: isNumber(o.maxHeight) ? o.maxHeight : 1/0
            }, (this._aspectRatio || forceAspectRatio) && (// We want to create an enclosing box whose aspect ration is the requested one
            // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
            pMinWidth = b.minHeight * this.aspectRatio, pMinHeight = b.minWidth / this.aspectRatio, 
            pMaxWidth = b.maxHeight * this.aspectRatio, pMaxHeight = b.maxWidth / this.aspectRatio, 
            pMinWidth > b.minWidth && (b.minWidth = pMinWidth), pMinHeight > b.minHeight && (b.minHeight = pMinHeight), 
            pMaxWidth < b.maxWidth && (b.maxWidth = pMaxWidth), pMaxHeight < b.maxHeight && (b.maxHeight = pMaxHeight)), 
            this._vBoundaries = b;
        },
        _updateCache: function(data) {
            this.offset = this.helper.offset(), isNumber(data.left) && (this.position.left = data.left), 
            isNumber(data.top) && (this.position.top = data.top), isNumber(data.height) && (this.size.height = data.height), 
            isNumber(data.width) && (this.size.width = data.width);
        },
        _updateRatio: function(data) {
            var cpos = this.position, csize = this.size, a = this.axis;
            return isNumber(data.height) ? data.width = data.height * this.aspectRatio : isNumber(data.width) && (data.height = data.width / this.aspectRatio), 
            "sw" === a && (data.left = cpos.left + (csize.width - data.width), data.top = null), 
            "nw" === a && (data.top = cpos.top + (csize.height - data.height), data.left = cpos.left + (csize.width - data.width)), 
            data;
        },
        _respectSize: function(data) {
            var o = this._vBoundaries, a = this.axis, ismaxw = isNumber(data.width) && o.maxWidth && o.maxWidth < data.width, ismaxh = isNumber(data.height) && o.maxHeight && o.maxHeight < data.height, isminw = isNumber(data.width) && o.minWidth && o.minWidth > data.width, isminh = isNumber(data.height) && o.minHeight && o.minHeight > data.height, dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height, cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
            // fixing jump error on top/left - bug #2330
            return isminw && (data.width = o.minWidth), isminh && (data.height = o.minHeight), 
            ismaxw && (data.width = o.maxWidth), ismaxh && (data.height = o.maxHeight), isminw && cw && (data.left = dw - o.minWidth), 
            ismaxw && cw && (data.left = dw - o.maxWidth), isminh && ch && (data.top = dh - o.minHeight), 
            ismaxh && ch && (data.top = dh - o.maxHeight), data.width || data.height || data.left || !data.top ? data.width || data.height || data.top || !data.left || (data.left = null) : data.top = null, 
            data;
        },
        _proportionallyResize: function() {
            if (this._proportionallyResizeElements.length) {
                var i, j, borders, paddings, prel, element = this.helper || this.element;
                for (i = 0; i < this._proportionallyResizeElements.length; i++) {
                    if (prel = this._proportionallyResizeElements[i], !this.borderDif) for (this.borderDif = [], 
                    borders = [ prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth") ], 
                    paddings = [ prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft") ], 
                    j = 0; j < borders.length; j++) this.borderDif[j] = (parseInt(borders[j], 10) || 0) + (parseInt(paddings[j], 10) || 0);
                    prel.css({
                        height: element.height() - this.borderDif[0] - this.borderDif[2] || 0,
                        width: element.width() - this.borderDif[1] - this.borderDif[3] || 0
                    });
                }
            }
        },
        _renderProxy: function() {
            var el = this.element, o = this.options;
            this.elementOffset = el.offset(), this._helper ? (this.helper = this.helper || $("<div style='overflow:hidden;'></div>"), 
            this.helper.addClass(this._helper).css({
                width: this.element.outerWidth() - 1,
                height: this.element.outerHeight() - 1,
                position: "absolute",
                left: this.elementOffset.left + "px",
                top: this.elementOffset.top + "px",
                zIndex: ++o.zIndex
            }), this.helper.appendTo("body").disableSelection()) : this.helper = this.element;
        },
        _change: {
            e: function(event, dx) {
                return {
                    width: this.originalSize.width + dx
                };
            },
            w: function(event, dx) {
                var cs = this.originalSize, sp = this.originalPosition;
                return {
                    left: sp.left + dx,
                    width: cs.width - dx
                };
            },
            n: function(event, dx, dy) {
                var cs = this.originalSize, sp = this.originalPosition;
                return {
                    top: sp.top + dy,
                    height: cs.height - dy
                };
            },
            s: function(event, dx, dy) {
                return {
                    height: this.originalSize.height + dy
                };
            },
            se: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
            },
            sw: function(event, dx, dy) {
                return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
            },
            ne: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [ event, dx, dy ]));
            },
            nw: function(event, dx, dy) {
                return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [ event, dx, dy ]));
            }
        },
        _propagate: function(n, event) {
            $.ui.plugin.call(this, n, [ event, this.ui() ]), "resize" !== n && this._trigger(n, event, this.ui());
        },
        plugins: {},
        ui: function() {
            return {
                originalElement: this.originalElement,
                element: this.element,
                helper: this.helper,
                position: this.position,
                size: this.size,
                originalSize: this.originalSize,
                originalPosition: this.originalPosition
            };
        }
    }), /*
 * Resizable Extensions
 */
    $.ui.plugin.add("resizable", "animate", {
        stop: function(event) {
            var that = $(this).data("ui-resizable"), o = that.options, pr = that._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && $.ui.hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, style = {
                width: that.size.width - soffsetw,
                height: that.size.height - soffseth
            }, left = parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left) || null, top = parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top) || null;
            that.element.animate($.extend(style, top && left ? {
                top: top,
                left: left
            } : {}), {
                duration: o.animateDuration,
                easing: o.animateEasing,
                step: function() {
                    var data = {
                        width: parseInt(that.element.css("width"), 10),
                        height: parseInt(that.element.css("height"), 10),
                        top: parseInt(that.element.css("top"), 10),
                        left: parseInt(that.element.css("left"), 10)
                    };
                    pr && pr.length && $(pr[0]).css({
                        width: data.width,
                        height: data.height
                    }), // propagating resize, and updating values for each animation step
                    that._updateCache(data), that._propagate("resize", event);
                }
            });
        }
    }), $.ui.plugin.add("resizable", "containment", {
        start: function() {
            var element, p, co, ch, cw, width, height, that = $(this).data("ui-resizable"), o = that.options, el = that.element, oc = o.containment, ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
            ce && (that.containerElement = $(ce), /document/.test(oc) || oc === document ? (that.containerOffset = {
                left: 0,
                top: 0
            }, that.containerPosition = {
                left: 0,
                top: 0
            }, that.parentData = {
                element: $(document),
                left: 0,
                top: 0,
                width: $(document).width(),
                height: $(document).height() || document.body.parentNode.scrollHeight
            }) : (element = $(ce), p = [], $([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) {
                p[i] = num(element.css("padding" + name));
            }), that.containerOffset = element.offset(), that.containerPosition = element.position(), 
            that.containerSize = {
                height: element.innerHeight() - p[3],
                width: element.innerWidth() - p[1]
            }, co = that.containerOffset, ch = that.containerSize.height, cw = that.containerSize.width, 
            width = $.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw, height = $.ui.hasScroll(ce) ? ce.scrollHeight : ch, 
            that.parentData = {
                element: ce,
                left: co.left,
                top: co.top,
                width: width,
                height: height
            }));
        },
        resize: function(event) {
            var woset, hoset, isParent, isOffsetRelative, that = $(this).data("ui-resizable"), o = that.options, co = that.containerOffset, cp = that.position, pRatio = that._aspectRatio || event.shiftKey, cop = {
                top: 0,
                left: 0
            }, ce = that.containerElement;
            ce[0] !== document && /static/.test(ce.css("position")) && (cop = co), cp.left < (that._helper ? co.left : 0) && (that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left), 
            pRatio && (that.size.height = that.size.width / that.aspectRatio), that.position.left = o.helper ? co.left : 0), 
            cp.top < (that._helper ? co.top : 0) && (that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top), 
            pRatio && (that.size.width = that.size.height * that.aspectRatio), that.position.top = that._helper ? co.top : 0), 
            that.offset.left = that.parentData.left + that.position.left, that.offset.top = that.parentData.top + that.position.top, 
            woset = Math.abs((that._helper ? that.offset.left - cop.left : that.offset.left - cop.left) + that.sizeDiff.width), 
            hoset = Math.abs((that._helper ? that.offset.top - cop.top : that.offset.top - co.top) + that.sizeDiff.height), 
            isParent = that.containerElement.get(0) === that.element.parent().get(0), isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position")), 
            isParent && isOffsetRelative && (woset -= that.parentData.left), woset + that.size.width >= that.parentData.width && (that.size.width = that.parentData.width - woset, 
            pRatio && (that.size.height = that.size.width / that.aspectRatio)), hoset + that.size.height >= that.parentData.height && (that.size.height = that.parentData.height - hoset, 
            pRatio && (that.size.width = that.size.height * that.aspectRatio));
        },
        stop: function() {
            var that = $(this).data("ui-resizable"), o = that.options, co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement, helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;
            that._helper && !o.animate && /relative/.test(ce.css("position")) && $(this).css({
                left: ho.left - cop.left - co.left,
                width: w,
                height: h
            }), that._helper && !o.animate && /static/.test(ce.css("position")) && $(this).css({
                left: ho.left - cop.left - co.left,
                width: w,
                height: h
            });
        }
    }), $.ui.plugin.add("resizable", "alsoResize", {
        start: function() {
            var that = $(this).data("ui-resizable"), o = that.options, _store = function(exp) {
                $(exp).each(function() {
                    var el = $(this);
                    el.data("ui-resizable-alsoresize", {
                        width: parseInt(el.width(), 10),
                        height: parseInt(el.height(), 10),
                        left: parseInt(el.css("left"), 10),
                        top: parseInt(el.css("top"), 10)
                    });
                });
            };
            "object" != typeof o.alsoResize || o.alsoResize.parentNode ? _store(o.alsoResize) : o.alsoResize.length ? (o.alsoResize = o.alsoResize[0], 
            _store(o.alsoResize)) : $.each(o.alsoResize, function(exp) {
                _store(exp);
            });
        },
        resize: function(event, ui) {
            var that = $(this).data("ui-resizable"), o = that.options, os = that.originalSize, op = that.originalPosition, delta = {
                height: that.size.height - os.height || 0,
                width: that.size.width - os.width || 0,
                top: that.position.top - op.top || 0,
                left: that.position.left - op.left || 0
            }, _alsoResize = function(exp, c) {
                $(exp).each(function() {
                    var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {}, css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? [ "width", "height" ] : [ "width", "height", "top", "left" ];
                    $.each(css, function(i, prop) {
                        var sum = (start[prop] || 0) + (delta[prop] || 0);
                        sum && sum >= 0 && (style[prop] = sum || null);
                    }), el.css(style);
                });
            };
            "object" != typeof o.alsoResize || o.alsoResize.nodeType ? _alsoResize(o.alsoResize) : $.each(o.alsoResize, function(exp, c) {
                _alsoResize(exp, c);
            });
        },
        stop: function() {
            $(this).removeData("resizable-alsoresize");
        }
    }), $.ui.plugin.add("resizable", "ghost", {
        start: function() {
            var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;
            that.ghost = that.originalElement.clone(), that.ghost.css({
                opacity: .25,
                display: "block",
                position: "relative",
                height: cs.height,
                width: cs.width,
                margin: 0,
                left: 0,
                top: 0
            }).addClass("ui-resizable-ghost").addClass("string" == typeof o.ghost ? o.ghost : ""), 
            that.ghost.appendTo(that.helper);
        },
        resize: function() {
            var that = $(this).data("ui-resizable");
            that.ghost && that.ghost.css({
                position: "relative",
                height: that.size.height,
                width: that.size.width
            });
        },
        stop: function() {
            var that = $(this).data("ui-resizable");
            that.ghost && that.helper && that.helper.get(0).removeChild(that.ghost.get(0));
        }
    }), $.ui.plugin.add("resizable", "grid", {
        resize: function() {
            var that = $(this).data("ui-resizable"), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, grid = "number" == typeof o.grid ? [ o.grid, o.grid ] : o.grid, gridX = grid[0] || 1, gridY = grid[1] || 1, ox = Math.round((cs.width - os.width) / gridX) * gridX, oy = Math.round((cs.height - os.height) / gridY) * gridY, newWidth = os.width + ox, newHeight = os.height + oy, isMaxWidth = o.maxWidth && o.maxWidth < newWidth, isMaxHeight = o.maxHeight && o.maxHeight < newHeight, isMinWidth = o.minWidth && o.minWidth > newWidth, isMinHeight = o.minHeight && o.minHeight > newHeight;
            o.grid = grid, isMinWidth && (newWidth += gridX), isMinHeight && (newHeight += gridY), 
            isMaxWidth && (newWidth -= gridX), isMaxHeight && (newHeight -= gridY), /^(se|s|e)$/.test(a) ? (that.size.width = newWidth, 
            that.size.height = newHeight) : /^(ne)$/.test(a) ? (that.size.width = newWidth, 
            that.size.height = newHeight, that.position.top = op.top - oy) : /^(sw)$/.test(a) ? (that.size.width = newWidth, 
            that.size.height = newHeight, that.position.left = op.left - ox) : (that.size.width = newWidth, 
            that.size.height = newHeight, that.position.top = op.top - oy, that.position.left = op.left - ox);
        }
    });
}(jQuery), // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
// requestAnimationFrame polyfill by Erik Mller
// fixes from Paul Irish and Tino Zijdel
function() {
    for (var lastTime = 0, vendors = [ "ms", "moz", "webkit", "o" ], x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"], 
    window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
    window.requestAnimationFrame || (window.requestAnimationFrame = function(callback) {
        var currTime = new Date().getTime(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = window.setTimeout(function() {
            callback(currTime + timeToCall);
        }, timeToCall);
        return lastTime = currTime + timeToCall, id;
    }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function(id) {
        clearTimeout(id);
    });
}(), /*
 jquery.animate-enhanced plugin v1.05
 ---
 http://github.com/benbarnett/jQuery-Animate-Enhanced
 http://benbarnett.net
 @benpbarnett
 ---
 Copyright (c) 2012 Ben Barnett

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ---
 Extends jQuery.animate() to automatically use CSS3 transformations where applicable.
 Tested with jQuery 1.3.2+

 Supports -moz-transition, -webkit-transition, -o-transition, transition

 Targetted properties (for now):
 - left
 - top
 - opacity
 - width
 - height

 Usage (exactly the same as it would be normally):

 jQuery(element).animate({left: 200},  500, function() {
 // callback
 });

 Changelog:
 1.05 (14/08/2013):
 - Merging PR #124 fix for highcharts clash. Thanks @bensonc!

 1.04 (14/08/2013):
 - Using fix from issue #69 by @rickyk586 to support percentages

 1.03 (19/7/2013):
 - Merge PR #129 (Use originalAnimateMethod if a step callback function is provided.) /thx @lehni

 1.02 (8/5/2013):
 - Fixing use3D default flags. It must explicitly be set to false to disable 3d now, the plugin by default will use it if available.

 1.01 (8/5/2013):
 - Adding appropriate display value for wider range of elements (issue #121 - thanks smacky)

 1.0 (8/5/2103):
 - Fix avoidTransforms: true behaviour for directional transitions

 0.99.1 (3/4/2013):
 - Add Set or unset the 'disabled by default' value (PR #117)

 0.99 (5/12/2012):
 - PR #109 Added support for list-item nodes. FadeIn on tags was omitting the list-style support. (thx @SeanCannon)

 0.98 (12/11/2012):
 - Merging pull request #106 thx @gboysko - checking for ownerDocument before using getComputedStyle

 0.97 (6/11/2012):
 - Merging pull request #104 thx @gavrochelegnou - .bind instead of .one

 0.96a (20/08/2012):
 - Checking event is from dispatch target (issue #58)

 0.96 (20/08/2012):
 - Fixes for context, all elements returned as context (issue #84)
 - Reset position with leaveTransforms !== true fixes (issue #93)


 0.95 (20/08/2012):
 - If target opacity == current opacity, pass back to jquery native to get callback firing (#94)

 0.94 (20/08/2012):
 - Addresses Firefox callback mechanisms (issue #94)
 - using $.one() to bind to CSS callbacks in a more generic way

 0.93 (6/8/2012):
 - Adding other Opera 'transitionend' event (re: issue #90)

 0.92 (6/8/2012):
 - Seperate unbinds into different threads (re: issue #91)

 0.91 (2/4/2012):
 - Merge Pull Request #74 - Unit Management

 0.90 (7/3/2012):
 - Adding public $.toggleDisabledByDefault() feature to disable entire plugin by default (Issue #73)

 0.89 (24/1/2012):
 - Adding 'avoidCSSTransitions' property. Set to true to disable entire plugin. (Issue #47)

 0.88 (24/1/2012):
 - Fix Issue #67 for HighchartsJS compatibility

 0.87 (24/1/2012):
 - Fix Issue #66 selfCSSData.original is undefined

 0.86 (9/1/2012):
 - Strict JS fix for undefined variable

 0.85 (20/12/2011):
 - Merge Pull request #57 from Kronuz
 - Codebase cleaned and now passes jshint.
 - Fixed a few bugs (it now saves and restores the original css transition properties).
 - fadeOut() is fixed, it wasn't restoring the opacity after hiding it.

 0.80 (13/09/2011):
 - Issue #28 - Report $(el).is(':animated') fix

 0.79 (06/09/2011):
 - Issue #42 - Right negative position animation: please see issue notes on Github.

 0.78 (02/09/2011):
 - Issue #18 - jQuery/$ reference joys

 0.77 (02/09/2011):
 - Adding feature on Github issue #44 - Use 3D Transitions by default

 0.76 (28/06/2011):
 - Fixing issue #37 - fixed stop() method (with gotoEnd == false)

 0.75 (15/06/2011):
 - Fixing issue #35 to pass actual object back as context for callback

 0.74 (28/05/2011):
 - Fixing issue #29 to play nice with 1.6+

 0.73 (05/03/2011):
 - Merged Pull Request #26: Fixed issue with fadeOut() / "hide" shortcut

 0.72 (05/03/2011):
 - Merged Pull Request #23: Added Penner equation approximations from Matthew Lein's Ceaser, and added failsafe fallbacks

 0.71 (05/03/2011):
 - Merged Pull Request #24: Changes translation object to integers instead of strings to fix relative values bug with leaveTransforms = true

 0.70 (17/03/2011):
 - Merged Pull Request from amlw-nyt to add bottom/right handling

 0.68 (15/02/2011):
 - width/height fixes & queue issues resolved.

 0.67 (15/02/2011):
 - Code cleanups & file size improvements for compression.

 0.66 (15/02/2011):
 - Zero second fadeOut(), fadeIn() fixes

 0.65 (01/02/2011):
 - Callbacks with queue() support refactored to support element arrays

 0.64 (27/01/2011):
 - BUGFIX #13: .slideUp(), .slideToggle(), .slideDown() bugfixes in Webkit

 0.63 (12/01/2011):
 - BUGFIX #11: callbacks not firing when new value == old value

 0.62 (10/01/2011):
 - BUGFIX #11: queue is not a function issue fixed

 0.61 (10/01/2011):
 - BUGFIX #10: Negative positions converting to positive

 0.60 (06/01/2011):
 - Animate function rewrite in accordance with new queue system
 - BUGFIX #8: Left/top position values always assumed relative rather than absolute
 - BUGFIX #9: animation as last item in a chain - the chain is ignored?
 - BUGFIX: width/height CSS3 transformation with left/top working

 0.55 (22/12/2010):
 - isEmptyObject function for <jQuery 1.4 (requires 1.3.2)

 0.54a (22/12/2010):
 - License changed to MIT (http://www.opensource.org/licenses/mit-license.php)

 0.54 (22/12/2010):
 - Removed silly check for 'jQuery UI' bailouts. Sorry.
 - Scoping issues fixed - Issue #4: $(this) should give you a reference to the selector being animated.. per jquery's core animation funciton.

 0.53 (17/11/2010):
 - New $.translate() method to easily calculate current transformed translation
 - Repeater callback bug fix for leaveTransforms:true (was constantly appending properties)

 0.52 (16/11/2010):
 - leaveTransforms: true bug fixes
 - 'Applying' user callback function to retain 'this' context

 0.51 (08/11/2010):
 - Bailing out with jQuery UI. This is only so the plugin plays nice with others and is TEMPORARY.

 0.50 (08/11/2010):
 - Support for $.fn.stop()
 - Fewer jQuery.fn entries to preserve namespace
 - All references $ converted to jQuery
 - jsDoc Toolkit style commenting for docs (coming soon)

 0.49 (19/10/2010):
 - Handling of 'undefined' errors for secondary CSS objects
 - Support to enhance 'width' and 'height' properties (except shortcuts involving jQuery.fx.step, e.g slideToggle)
 - Bugfix: Positioning when using avoidTransforms: true (thanks Ralf Santbergen reports)
 - Bugfix: Callbacks and Scope issues

 0.48 (13/10/2010):
 - Checks for 3d support before applying

 0.47 (12/10/2010);
 - Compatible with .fadeIn(), .fadeOut()
 - Use shortcuts, no duration for jQuery default or "fast" and "slow"
 - Clean up callback event listeners on complete (preventing multiple callbacks)

 0.46 (07/10/2010);
 - Compatible with .slideUp(), .slideDown(), .slideToggle()

 0.45 (06/10/2010):
 - 'Zero' position bug fix (was originally translating by 0 zero pixels, i.e. no movement)

 0.4 (05/10/2010):
 - Iterate over multiple elements and store transforms in jQuery.data per element
 - Include support for relative values (+= / -=)
 - Better unit sanitization
 - Performance tweaks
 - Fix for optional callback function (was required)
 - Applies data[translateX] and data[translateY] to elements for easy access
 - Added 'easeInOutQuint' easing function for CSS transitions (requires jQuery UI for JS anims)
 - Less need for leaveTransforms = true due to better position detections
 */
function(jQuery, originalAnimateMethod, originalStopMethod) {
    /**
     @private
     @name _getUnit
     @function
     @description Return unit value ("px", "%", "em" for re-use correct one when translating)
     @param {variant} [val] Target value
     */
    function _getUnit(val) {
        return val.match(/\D+$/);
    }
    /**
     @private
     @name _interpretValue
     @function
     @description Interpret value ("px", "+=" and "-=" sanitisation)
     @param {object} [element] The Element for current CSS analysis
     @param {variant} [val] Target value
     @param {string} [prop] The property we're looking at
     @param {boolean} [isTransform] Is this a CSS3 transform?
     */
    function _interpretValue(e, val, prop, isTransform) {
        // this is a nasty fix, but we check for prop == 'd' to see if we're dealing with SVG, and abort
        if ("d" != prop && _isValidElement(e)) {
            var parts = rfxnum.exec(val), start = "auto" === e.css(prop) ? 0 : e.css(prop), cleanCSSStart = "string" == typeof start ? _cleanValue(start) : start, cleanStart = ("string" == typeof val ? _cleanValue(val) : val, 
            isTransform === !0 ? 0 : cleanCSSStart), hidden = e.is(":hidden"), translation = e.translation();
            if ("left" == prop && (cleanStart = parseInt(cleanCSSStart, 10) + translation.x), 
            "right" == prop && (cleanStart = parseInt(cleanCSSStart, 10) + translation.x), "top" == prop && (cleanStart = parseInt(cleanCSSStart, 10) + translation.y), 
            "bottom" == prop && (cleanStart = parseInt(cleanCSSStart, 10) + translation.y), 
            // deal with shortcuts
            parts || "show" != val ? parts || "hide" != val || (cleanStart = 0) : (cleanStart = 1, 
            hidden && e.css({
                display: _domElementVisibleDisplayValue(e.context.tagName),
                opacity: 0
            })), parts) {
                var end = parseFloat(parts[2]);
                // If a +=/-= token was provided, we're doing a relative animation
                // check for unit  as per issue #69
                return parts[1] && (end = ("-=" === parts[1] ? -1 : 1) * end + parseInt(cleanStart, 10)), 
                "%" == parts[3] && (end += "%"), end;
            }
            return cleanStart;
        }
    }
    /**
     @private
     @name _getTranslation
     @function
     @description Make a translate or translate3d string
     @param {integer} [x]
     @param {integer} [y]
     @param {boolean} [use3D] Use translate3d if available?
     */
    function _getTranslation(x, y, use3D) {
        return use3D === !0 || use3DByDefault === !0 && use3D !== !1 && has3D ? "translate3d(" + x + "px, " + y + "px, 0)" : "translate(" + x + "px," + y + "px)";
    }
    /**
     @private
     @name _applyCSSTransition
     @function
     @description Build up the CSS object
     @param {object} [e] Element
     @param {string} [property] Property we're dealing with
     @param {integer} [duration] Duration
     @param {string} [easing] Easing function
     @param {variant} [value] String/integer for target value
     @param {boolean} [isTransform] Is this a CSS transformation?
     @param {boolean} [isTranslatable] Is this a CSS translation?
     @param {boolean} [use3D] Use translate3d if available?
     */
    function _applyCSSTransition(e, property, duration, easing, value, isTransform, isTranslatable, use3D) {
        var eCSSData = e.data(DATA_KEY), enhanceData = eCSSData && !_isEmptyObject(eCSSData) ? eCSSData : jQuery.extend(!0, {}, defaultEnhanceData), offsetPosition = value, isDirection = jQuery.inArray(property, directions) > -1;
        if (isDirection) {
            var meta = enhanceData.meta, cleanPropertyValue = _cleanValue(e.css(property)) || 0, stashedProperty = property + "_o";
            offsetPosition = value - cleanPropertyValue, meta[property] = offsetPosition, meta[stashedProperty] = "auto" == e.css(property) ? 0 + offsetPosition : cleanPropertyValue + offsetPosition || 0, 
            enhanceData.meta = meta, // fix 0 issue (transition by 0 = nothing)
            isTranslatable && 0 === offsetPosition && (offsetPosition = 0 - meta[stashedProperty], 
            meta[property] = offsetPosition, meta[stashedProperty] = 0);
        }
        // reapply data and return
        return e.data(DATA_KEY, _applyCSSWithPrefix(e, enhanceData, property, duration, easing, offsetPosition, isTransform, isTranslatable, use3D));
    }
    /**
     @private
     @name _applyCSSWithPrefix
     @function
     @description Helper function to build up CSS properties using the various prefixes
     @param {object} [cssProperties] Current CSS object to merge with
     @param {string} [property]
     @param {integer} [duration]
     @param {string} [easing]
     @param {variant} [value]
     @param {boolean} [isTransform] Is this a CSS transformation?
     @param {boolean} [isTranslatable] Is this a CSS translation?
     @param {boolean} [use3D] Use translate3d if available?
     */
    function _applyCSSWithPrefix(e, cssProperties, property, duration, easing, value, isTransform, isTranslatable, use3D) {
        var saveOriginal = !1, transform = isTransform === !0 && isTranslatable === !0;
        cssProperties = cssProperties || {}, cssProperties.original || (cssProperties.original = {}, 
        saveOriginal = !0), cssProperties.properties = cssProperties.properties || {}, cssProperties.secondary = cssProperties.secondary || {};
        for (var meta = cssProperties.meta, original = cssProperties.original, properties = cssProperties.properties, secondary = cssProperties.secondary, i = cssPrefixes.length - 1; i >= 0; i--) {
            var tp = cssPrefixes[i] + "transition-property", td = cssPrefixes[i] + "transition-duration", tf = cssPrefixes[i] + "transition-timing-function";
            property = transform ? cssPrefixes[i] + "transform" : property, saveOriginal && (original[tp] = e.css(tp) || "", 
            original[td] = e.css(td) || "", original[tf] = e.css(tf) || ""), secondary[property] = transform ? _getTranslation(meta.left, meta.top, use3D) : value, 
            properties[tp] = (properties[tp] ? properties[tp] + "," : "") + property, properties[td] = (properties[td] ? properties[td] + "," : "") + duration + "ms", 
            properties[tf] = (properties[tf] ? properties[tf] + "," : "") + easing;
        }
        return cssProperties;
    }
    /**
     @private
     @name _isBoxShortcut
     @function
     @description Shortcut to detect if we need to step away from slideToggle, CSS accelerated transitions (to come later with fx.step support)
     @param {object} [prop]
     */
    function _isBoxShortcut(prop) {
        for (var property in prop) if (!("width" != property && "height" != property || "show" != prop[property] && "hide" != prop[property] && "toggle" != prop[property])) return !0;
        return !1;
    }
    /**
     @private
     @name _isEmptyObject
     @function
     @description Check if object is empty (<1.4 compatibility)
     @param {object} [obj]
     */
    function _isEmptyObject(obj) {
        for (var i in obj) return !1;
        return !0;
    }
    /**
     * Fetch most appropriate display value for element types
     * @see  https://github.com/benbarnett/jQuery-Animate-Enhanced/issues/121
     * @private
     * @param  {[type]} tagName [description]
     * @return {[type]}         [description]
     */
    function _domElementVisibleDisplayValue(tagName) {
        tagName = tagName.toUpperCase();
        var displayValues = {
            LI: "list-item",
            TR: "table-row",
            TD: "table-cell",
            TH: "table-cell",
            CAPTION: "table-caption",
            COL: "table-column",
            COLGROUP: "table-column-group",
            TFOOT: "table-footer-group",
            THEAD: "table-header-group",
            TBODY: "table-row-group"
        };
        return "string" == typeof displayValues[tagName] ? displayValues[tagName] : "block";
    }
    /**
     @private
     @name _cleanValue
     @function
     @description Remove 'px' and other artifacts
     @param {variant} [val]
     */
    function _cleanValue(val) {
        return parseFloat(val.replace(_getUnit(val), ""));
    }
    function _isValidElement(element) {
        var allValid = !0;
        return element.each(function(index, el) {
            return allValid = allValid && el.ownerDocument;
        }), allValid;
    }
    /**
     @private
     @name _appropriateProperty
     @function
     @description Function to check if property should be handled by plugin
     @param {string} [prop]
     @param {variant} [value]
     */
    function _appropriateProperty(prop, value, element) {
        if (!_isValidElement(element)) return !1;
        var is = jQuery.inArray(prop, cssTransitionProperties) > -1;
        return "width" != prop && "height" != prop && "opacity" != prop || parseFloat(value) !== parseFloat(element.css(prop)) || (is = !1), 
        is;
    }
    // ----------
    // Plugin variables
    // ----------
    var cssTransitionProperties = [ "top", "right", "bottom", "left", "opacity", "height", "width" ], directions = [ "top", "right", "bottom", "left" ], cssPrefixes = [ "-webkit-", "-moz-", "-o-", "" ], pluginOptions = [ "avoidTransforms", "useTranslate3d", "leaveTransforms" ], rfxnum = /^([+-]=)?([\d+-.]+)(.*)$/, rupper = /([A-Z])/g, defaultEnhanceData = {
        secondary: {},
        meta: {
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
        }
    }, valUnit = "px", DATA_KEY = "jQe", CUBIC_BEZIER_OPEN = "cubic-bezier(", CUBIC_BEZIER_CLOSE = ")", originalAnimatedFilter = null, pluginDisabledDefault = !1, thisBody = document.body || document.documentElement, thisStyle = thisBody.style, transitionEndEvent = "webkitTransitionEnd oTransitionEnd transitionend", cssTransitionsSupported = void 0 !== thisStyle.WebkitTransition || void 0 !== thisStyle.MozTransition || void 0 !== thisStyle.OTransition || void 0 !== thisStyle.transition, has3D = "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix(), use3DByDefault = has3D;
    // ----------
    // Extended :animated filter
    // ----------
    jQuery.expr && jQuery.expr.filters && (originalAnimatedFilter = jQuery.expr.filters.animated, 
    jQuery.expr.filters.animated = function(elem) {
        return jQuery(elem).data("events") && jQuery(elem).data("events")[transitionEndEvent] ? !0 : originalAnimatedFilter.call(this, elem);
    }), jQuery.extend({
        /**
         @public
         @name toggle3DByDefault
         @function
         @description Toggle for plugin settings to automatically use translate3d (where available). Usage: $.toggle3DByDefault
         */
        toggle3DByDefault: function() {
            return use3DByDefault = !use3DByDefault;
        },
        /**
         @public
         @name toggleDisabledByDefault
         @function
         @description Toggle the plugin to be disabled by default (can be overridden per animation with avoidCSSTransitions)
         */
        toggleDisabledByDefault: function() {
            return pluginDisabledDefault = !pluginDisabledDefault;
        },
        /**
         @public
         @name setDisabledByDefault
         @function
         @description Set or unset the 'disabled by default' value
         */
        setDisabledByDefault: function(newValue) {
            return pluginDisabledDefault = newValue;
        }
    }), /**
     @public
     @name translation
     @function
     @description Get current X and Y translations
     */
    jQuery.fn.translation = function() {
        if (!this[0]) return null;
        var elem = this[0], cStyle = window.getComputedStyle(elem, null), translation = {
            x: 0,
            y: 0
        };
        if (cStyle) for (var i = cssPrefixes.length - 1; i >= 0; i--) {
            var transform = cStyle.getPropertyValue(cssPrefixes[i] + "transform");
            if (transform && /matrix/i.test(transform)) {
                var explodedMatrix = transform.replace(/^matrix\(/i, "").split(/, |\)$/g);
                translation = {
                    x: parseInt(explodedMatrix[4], 10),
                    y: parseInt(explodedMatrix[5], 10)
                };
                break;
            }
        }
        return translation;
    }, /**
     @public
     @name jQuery.fn.animate
     @function
     @description The enhanced jQuery.animate function
     @param {string} [property]
     @param {string} [speed]
     @param {string} [easing]
     @param {function} [callback]
     */
    jQuery.fn.animate = function(prop, speed, easing, callback) {
        prop = prop || {};
        var isTranslatable = !("undefined" != typeof prop.bottom || "undefined" != typeof prop.right), optall = jQuery.speed(speed, easing, callback), callbackQueue = 0, propertyCallback = function() {
            callbackQueue--, 0 === callbackQueue && "function" == typeof optall.complete && optall.complete.apply(this, arguments);
        }, bypassPlugin = "undefined" != typeof prop.avoidCSSTransitions ? prop.avoidCSSTransitions : pluginDisabledDefault;
        return bypassPlugin === !0 || !cssTransitionsSupported || _isEmptyObject(prop) || _isBoxShortcut(prop) || optall.duration <= 0 || optall.step ? originalAnimateMethod.apply(this, arguments) : this[optall.queue === !0 ? "queue" : "each"](function() {
            var self = jQuery(this), opt = jQuery.extend({}, optall), cssCallback = function(e) {
                var selfCSSData = self.data(DATA_KEY) || {
                    original: {}
                }, restore = {};
                if (2 == e.eventPhase) {
                    // convert translations to left & top for layout
                    if (prop.leaveTransforms !== !0) {
                        for (var i = cssPrefixes.length - 1; i >= 0; i--) restore[cssPrefixes[i] + "transform"] = "";
                        if (isTranslatable && "undefined" != typeof selfCSSData.meta) for (var dir, j = 0; dir = directions[j]; ++j) restore[dir] = selfCSSData.meta[dir + "_o"] + valUnit, 
                        jQuery(this).css(dir, restore[dir]);
                    }
                    // remove transition timing functions
                    self.unbind(transitionEndEvent).css(selfCSSData.original).css(restore).data(DATA_KEY, null), 
                    // if we used the fadeOut shortcut make sure elements are display:none
                    "hide" === prop.opacity && self.css({
                        display: "none",
                        opacity: ""
                    }), // run the main callback function
                    propertyCallback.call(this);
                }
            }, easings = {
                bounce: CUBIC_BEZIER_OPEN + "0.0, 0.35, .5, 1.3" + CUBIC_BEZIER_CLOSE,
                linear: "linear",
                swing: "ease-in-out",
                // Penner equation approximations from Matthew Lein's Ceaser: http://matthewlein.com/ceaser/
                easeInQuad: CUBIC_BEZIER_OPEN + "0.550, 0.085, 0.680, 0.530" + CUBIC_BEZIER_CLOSE,
                easeInCubic: CUBIC_BEZIER_OPEN + "0.550, 0.055, 0.675, 0.190" + CUBIC_BEZIER_CLOSE,
                easeInQuart: CUBIC_BEZIER_OPEN + "0.895, 0.030, 0.685, 0.220" + CUBIC_BEZIER_CLOSE,
                easeInQuint: CUBIC_BEZIER_OPEN + "0.755, 0.050, 0.855, 0.060" + CUBIC_BEZIER_CLOSE,
                easeInSine: CUBIC_BEZIER_OPEN + "0.470, 0.000, 0.745, 0.715" + CUBIC_BEZIER_CLOSE,
                easeInExpo: CUBIC_BEZIER_OPEN + "0.950, 0.050, 0.795, 0.035" + CUBIC_BEZIER_CLOSE,
                easeInCirc: CUBIC_BEZIER_OPEN + "0.600, 0.040, 0.980, 0.335" + CUBIC_BEZIER_CLOSE,
                easeInBack: CUBIC_BEZIER_OPEN + "0.600, -0.280, 0.735, 0.045" + CUBIC_BEZIER_CLOSE,
                easeOutQuad: CUBIC_BEZIER_OPEN + "0.250, 0.460, 0.450, 0.940" + CUBIC_BEZIER_CLOSE,
                easeOutCubic: CUBIC_BEZIER_OPEN + "0.215, 0.610, 0.355, 1.000" + CUBIC_BEZIER_CLOSE,
                easeOutQuart: CUBIC_BEZIER_OPEN + "0.165, 0.840, 0.440, 1.000" + CUBIC_BEZIER_CLOSE,
                easeOutQuint: CUBIC_BEZIER_OPEN + "0.230, 1.000, 0.320, 1.000" + CUBIC_BEZIER_CLOSE,
                easeOutSine: CUBIC_BEZIER_OPEN + "0.390, 0.575, 0.565, 1.000" + CUBIC_BEZIER_CLOSE,
                easeOutExpo: CUBIC_BEZIER_OPEN + "0.190, 1.000, 0.220, 1.000" + CUBIC_BEZIER_CLOSE,
                easeOutCirc: CUBIC_BEZIER_OPEN + "0.075, 0.820, 0.165, 1.000" + CUBIC_BEZIER_CLOSE,
                easeOutBack: CUBIC_BEZIER_OPEN + "0.175, 0.885, 0.320, 1.275" + CUBIC_BEZIER_CLOSE,
                easeInOutQuad: CUBIC_BEZIER_OPEN + "0.455, 0.030, 0.515, 0.955" + CUBIC_BEZIER_CLOSE,
                easeInOutCubic: CUBIC_BEZIER_OPEN + "0.645, 0.045, 0.355, 1.000" + CUBIC_BEZIER_CLOSE,
                easeInOutQuart: CUBIC_BEZIER_OPEN + "0.770, 0.000, 0.175, 1.000" + CUBIC_BEZIER_CLOSE,
                easeInOutQuint: CUBIC_BEZIER_OPEN + "0.860, 0.000, 0.070, 1.000" + CUBIC_BEZIER_CLOSE,
                easeInOutSine: CUBIC_BEZIER_OPEN + "0.445, 0.050, 0.550, 0.950" + CUBIC_BEZIER_CLOSE,
                easeInOutExpo: CUBIC_BEZIER_OPEN + "1.000, 0.000, 0.000, 1.000" + CUBIC_BEZIER_CLOSE,
                easeInOutCirc: CUBIC_BEZIER_OPEN + "0.785, 0.135, 0.150, 0.860" + CUBIC_BEZIER_CLOSE,
                easeInOutBack: CUBIC_BEZIER_OPEN + "0.680, -0.550, 0.265, 1.550" + CUBIC_BEZIER_CLOSE
            }, domProperties = {}, cssEasing = easings[opt.easing || "swing"] ? easings[opt.easing || "swing"] : opt.easing || "swing";
            // seperate out the properties for the relevant animation functions
            for (var p in prop) if (-1 === jQuery.inArray(p, pluginOptions)) {
                var isDirection = jQuery.inArray(p, directions) > -1, cleanVal = _interpretValue(self, prop[p], p, isDirection && prop.avoidTransforms !== !0);
                /**prop.avoidTransforms !== true && **/ _appropriateProperty(p, cleanVal, self) ? _applyCSSTransition(self, p, opt.duration, cssEasing, cleanVal, //isDirection && prop.avoidTransforms === true ? cleanVal + valUnit : cleanVal,
                isDirection && prop.avoidTransforms !== !0, isTranslatable, prop.useTranslate3d) : domProperties[p] = prop[p];
            }
            self.unbind(transitionEndEvent);
            var selfCSSData = self.data(DATA_KEY);
            if (!selfCSSData || _isEmptyObject(selfCSSData) || _isEmptyObject(selfCSSData.secondary)) // it won't get fired otherwise
            opt.queue = !1; else {
                callbackQueue++, self.css(selfCSSData.properties);
                // store in a var to avoid any timing issues, depending on animation duration
                var secondary = selfCSSData.secondary;
                // has to be done in a timeout to ensure transition properties are set
                setTimeout(function() {
                    self.bind(transitionEndEvent, cssCallback).css(secondary);
                });
            }
            // strict JS compliance
            // fire up DOM based animations
            return _isEmptyObject(domProperties) || (callbackQueue++, originalAnimateMethod.apply(self, [ domProperties, {
                duration: opt.duration,
                easing: jQuery.easing[opt.easing] ? opt.easing : jQuery.easing.swing ? "swing" : "linear",
                complete: propertyCallback,
                queue: opt.queue
            } ])), !0;
        });
    }, jQuery.fn.animate.defaults = {}, /**
     @public
     @name jQuery.fn.stop
     @function
     @description The enhanced jQuery.stop function (resets transforms to left/top)
     @param {boolean} [clearQueue]
     @param {boolean} [gotoEnd]
     @param {boolean} [leaveTransforms] Leave transforms/translations as they are? Default: false (reset translations to calculated explicit left/top props)
     */
    jQuery.fn.stop = function(clearQueue, gotoEnd, leaveTransforms) {
        // clear the queue?
        // route to appropriate stop methods
        return cssTransitionsSupported ? (clearQueue && this.queue([]), this.each(function() {
            var self = jQuery(this), selfCSSData = self.data(DATA_KEY);
            // is this a CSS transition?
            if (selfCSSData && !_isEmptyObject(selfCSSData)) {
                var i, restore = {};
                if (gotoEnd) {
                    if (// grab end state properties
                    restore = selfCSSData.secondary, !leaveTransforms && void 0 !== typeof selfCSSData.meta.left_o || void 0 !== typeof selfCSSData.meta.top_o) // remove the transformations
                    for (restore.left = void 0 !== typeof selfCSSData.meta.left_o ? selfCSSData.meta.left_o : "auto", 
                    restore.top = void 0 !== typeof selfCSSData.meta.top_o ? selfCSSData.meta.top_o : "auto", 
                    i = cssPrefixes.length - 1; i >= 0; i--) restore[cssPrefixes[i] + "transform"] = "";
                } else if (!_isEmptyObject(selfCSSData.secondary)) {
                    var cStyle = window.getComputedStyle(self[0], null);
                    if (cStyle) // grab current properties
                    for (var prop in selfCSSData.secondary) if (selfCSSData.secondary.hasOwnProperty(prop) && (prop = prop.replace(rupper, "-$1").toLowerCase(), 
                    restore[prop] = cStyle.getPropertyValue(prop), !leaveTransforms && /matrix/i.test(restore[prop]))) {
                        var explodedMatrix = restore[prop].replace(/^matrix\(/i, "").split(/, |\)$/g);
                        // remove the transformations
                        for (// apply the explicit left/top props
                        restore.left = parseFloat(explodedMatrix[4]) + parseFloat(self.css("left")) + valUnit || "auto", 
                        restore.top = parseFloat(explodedMatrix[5]) + parseFloat(self.css("top")) + valUnit || "auto", 
                        i = cssPrefixes.length - 1; i >= 0; i--) restore[cssPrefixes[i] + "transform"] = "";
                    }
                }
                // Remove transition timing functions
                // Moving to seperate thread (re: Animation reverts when finished in Android - issue #91)
                self.unbind(transitionEndEvent), self.css(selfCSSData.original).css(restore).data(DATA_KEY, null);
            } else // dom transition
            originalStopMethod.apply(self, [ clearQueue, gotoEnd ]);
        }), this) : originalStopMethod.apply(this, [ clearQueue, gotoEnd ]);
    };
}(jQuery, jQuery.fn.animate, jQuery.fn.stop), /*
 * ----------------------------- JSTORAGE -------------------------------------
 * Simple local storage wrapper to save data on the browser side, supporting
 * all major browsers - IE6+, Firefox2+, Safari4+, Chrome4+ and Opera 10.5+
 *
 * Copyright (c) 2010 - 2012 Andris Reinman, andris.reinman@gmail.com
 * Project homepage: www.jstorage.info
 *
 * Licensed under MIT-style license:
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
function() {
    ////////////////////////// PRIVATE METHODS ////////////////////////
    /**
     * Initialization function. Detects if the browser supports DOM Storage
     * or userData behavior and behaves accordingly.
     */
    function _init() {
        /* Check if browser supports localStorage */
        var localStorageReallyWorks = !1;
        if ("localStorage" in window) try {
            window.localStorage.setItem("_tmptest", "tmpval"), localStorageReallyWorks = !0, 
            window.localStorage.removeItem("_tmptest");
        } catch (BogusQuotaExceededErrorOnIos5) {}
        if (localStorageReallyWorks) try {
            window.localStorage && (_storage_service = window.localStorage, _backend = "localStorage", 
            _observer_update = _storage_service.jStorage_update);
        } catch (E3) {} else if ("globalStorage" in window) try {
            window.globalStorage && (_storage_service = window.globalStorage[window.location.hostname], 
            _backend = "globalStorage", _observer_update = _storage_service.jStorage_update);
        } catch (E4) {} else {
            if (_storage_elm = document.createElement("link"), !_storage_elm.addBehavior) return void (_storage_elm = null);
            /* Use a DOM element to act as userData storage */
            _storage_elm.style.behavior = "url(#default#userData)", /* userData element needs to be inserted into the DOM! */
            document.getElementsByTagName("head")[0].appendChild(_storage_elm);
            try {
                _storage_elm.load("jStorage");
            } catch (E) {
                // try to reset cache
                _storage_elm.setAttribute("jStorage", "{}"), _storage_elm.save("jStorage"), _storage_elm.load("jStorage");
            }
            var data = "{}";
            try {
                data = _storage_elm.getAttribute("jStorage");
            } catch (E5) {}
            try {
                _observer_update = _storage_elm.getAttribute("jStorage_update");
            } catch (E6) {}
            _storage_service.jStorage = data, _backend = "userDataBehavior";
        }
        // Load data from storage
        _load_storage(), // remove dead keys
        _handleTTL(), // create localStorage and sessionStorage polyfills if needed
        _createPolyfillStorage("local"), _createPolyfillStorage("session"), // start listening for changes
        _setupObserver(), // initialize publish-subscribe service
        _handlePubSub(), // handle cached navigation
        "addEventListener" in window && window.addEventListener("pageshow", function(event) {
            event.persisted && _storageObserver();
        }, !1);
    }
    /**
     * Create a polyfill for localStorage (type="local") or sessionStorage (type="session")
     *
     * @param {string} type Either "local" or "session"
     *@param {Boolean} forceCreate If set to true, recreate the polyfill (needed with flush)
     */
    function _createPolyfillStorage(type, forceCreate) {
        function _sessionStoragePolyfillUpdate() {
            if ("session" == type) try {
                storage_source = JSON.parse(window.name || "{}");
            } catch (E) {
                storage_source = {};
            }
        }
        function _sessionStoragePolyfillSave() {
            "session" == type && (window.name = JSON.stringify(storage_source));
        }
        {
            var i, storage, _skipSave = !1, _length = 0, storage_source = {};
            Math.random();
        }
        if (forceCreate || "undefined" == typeof window[type + "Storage"]) {
            // Use globalStorage for localStorage if available
            if ("local" == type && window.globalStorage) return void (localStorage = window.globalStorage[window.location.hostname]);
            // only IE6/7 from this point on
            if ("userDataBehavior" == _backend) {
                // Remove existing storage element if available
                forceCreate && window[type + "Storage"] && window[type + "Storage"].parentNode && window[type + "Storage"].parentNode.removeChild(window[type + "Storage"]), 
                storage = document.createElement("button"), document.getElementsByTagName("head")[0].appendChild(storage), 
                "local" == type ? storage_source = _storage : "session" == type && _sessionStoragePolyfillUpdate();
                for (i in storage_source) storage_source.hasOwnProperty(i) && "__jstorage_meta" != i && "length" != i && "undefined" != typeof storage_source[i] && (i in storage || _length++, 
                storage[i] = storage_source[i]);
                // Polyfill API
                /**
         * Indicates how many keys are stored in the storage
         */
                storage.length = _length, /**
         * Returns the key of the nth stored value
         *
         * @param {number} n Index position
         * @return {string} Key name of the nth stored value
         */
                storage.key = function(n) {
                    var i, count = 0;
                    _sessionStoragePolyfillUpdate();
                    for (i in storage_source) if (storage_source.hasOwnProperty(i) && "__jstorage_meta" != i && "length" != i && "undefined" != typeof storage_source[i]) {
                        if (count == n) return i;
                        count++;
                    }
                }, /**
         * Returns the current value associated with the given key
         *
         * @param {string} key key name
         * @return {Mixed} Stored value
         */
                storage.getItem = function(key) {
                    return _sessionStoragePolyfillUpdate(), "session" == type ? storage_source[key] : $.jStorage.get(key);
                }, /**
         * Sets or updates value for a give key
         *
         * @param {string} key Key name to be updated
         * @param {string} value String value to be stored
         */
                storage.setItem = function(key, value) {
                    "undefined" != typeof value && (storage[key] = (value || "").toString());
                }, /**
         * Removes key from the storage
         *
         * @param {string} key Key name to be removed
         */
                storage.removeItem = function(key) {
                    return "local" == type ? $.jStorage.deleteKey(key) : (storage[key] = void 0, _skipSave = !0, 
                    key in storage && storage.removeAttribute(key), void (_skipSave = !1));
                }, /**
         * Clear storage
         */
                storage.clear = function() {
                    return "session" == type ? (window.name = "", void _createPolyfillStorage("session", !0)) : void $.jStorage.flush();
                }, "local" == type && (_localStoragePolyfillSetKey = function(key, value) {
                    "length" != key && (_skipSave = !0, "undefined" == typeof value ? key in storage && (_length--, 
                    storage.removeAttribute(key)) : (key in storage || _length++, storage[key] = (value || "").toString()), 
                    storage.length = _length, _skipSave = !1);
                }), storage.attachEvent("onpropertychange", function(e) {
                    if ("length" != e.propertyName && !_skipSave && "length" != e.propertyName) {
                        if ("local" == type) e.propertyName in storage_source || "undefined" == typeof storage[e.propertyName] || _length++; else if ("session" == type) return _sessionStoragePolyfillUpdate(), 
                        "undefined" == typeof storage[e.propertyName] || e.propertyName in storage_source ? "undefined" == typeof storage[e.propertyName] && e.propertyName in storage_source ? (delete storage_source[e.propertyName], 
                        _length--) : storage_source[e.propertyName] = storage[e.propertyName] : (storage_source[e.propertyName] = storage[e.propertyName], 
                        _length++), _sessionStoragePolyfillSave(), void (storage.length = _length);
                        $.jStorage.set(e.propertyName, storage[e.propertyName]), storage.length = _length;
                    }
                }), window[type + "Storage"] = storage;
            }
        }
    }
    /**
     * Reload data from storage when needed
     */
    function _reloadData() {
        var data = "{}";
        if ("userDataBehavior" == _backend) {
            _storage_elm.load("jStorage");
            try {
                data = _storage_elm.getAttribute("jStorage");
            } catch (E5) {}
            try {
                _observer_update = _storage_elm.getAttribute("jStorage_update");
            } catch (E6) {}
            _storage_service.jStorage = data;
        }
        _load_storage(), // remove dead keys
        _handleTTL(), _handlePubSub();
    }
    /**
     * Sets up a storage change observer
     */
    function _setupObserver() {
        "localStorage" == _backend || "globalStorage" == _backend ? "addEventListener" in window ? window.addEventListener("storage", _storageObserver, !1) : document.attachEvent("onstorage", _storageObserver) : "userDataBehavior" == _backend && setInterval(_storageObserver, 1e3);
    }
    /**
     * Fired on any kind of data change, needs to check if anything has
     * really been changed
     */
    function _storageObserver() {
        var updateTime;
        // cumulate change notifications with timeout
        clearTimeout(_observer_timeout), _observer_timeout = setTimeout(function() {
            if ("localStorage" == _backend || "globalStorage" == _backend) updateTime = _storage_service.jStorage_update; else if ("userDataBehavior" == _backend) {
                _storage_elm.load("jStorage");
                try {
                    updateTime = _storage_elm.getAttribute("jStorage_update");
                } catch (E5) {}
            }
            updateTime && updateTime != _observer_update && (_observer_update = updateTime, 
            _checkUpdatedKeys());
        }, 25);
    }
    /**
     * Reloads the data and checks if any keys are changed
     */
    function _checkUpdatedKeys() {
        var newCrc32List, oldCrc32List = JSON.parse(JSON.stringify(_storage.__jstorage_meta.CRC32));
        _reloadData(), newCrc32List = JSON.parse(JSON.stringify(_storage.__jstorage_meta.CRC32));
        var key, updated = [], removed = [];
        for (key in oldCrc32List) if (oldCrc32List.hasOwnProperty(key)) {
            if (!newCrc32List[key]) {
                removed.push(key);
                continue;
            }
            oldCrc32List[key] != newCrc32List[key] && "2." == String(oldCrc32List[key]).substr(0, 2) && updated.push(key);
        }
        for (key in newCrc32List) newCrc32List.hasOwnProperty(key) && (oldCrc32List[key] || updated.push(key));
        _fireObservers(updated, "updated"), _fireObservers(removed, "deleted");
    }
    /**
     * Fires observers for updated keys
     *
     * @param {Array|String} keys Array of key names or a key
     * @param {string} action What happened with the value (updated, deleted, flushed)
     */
    function _fireObservers(keys, action) {
        if (keys = [].concat(keys || []), "flushed" == action) {
            keys = [];
            for (var key in _observers) _observers.hasOwnProperty(key) && keys.push(key);
            action = "deleted";
        }
        for (var i = 0, len = keys.length; len > i; i++) if (_observers[keys[i]]) for (var j = 0, jlen = _observers[keys[i]].length; jlen > j; j++) _observers[keys[i]][j](keys[i], action);
    }
    /**
     * Publishes key change to listeners
     */
    function _publishChange() {
        var updateTime = (+new Date()).toString();
        "localStorage" == _backend || "globalStorage" == _backend ? _storage_service.jStorage_update = updateTime : "userDataBehavior" == _backend && (_storage_elm.setAttribute("jStorage_update", updateTime), 
        _storage_elm.save("jStorage")), _storageObserver();
    }
    /**
     * Loads the data from the storage based on the supported mechanism
     */
    function _load_storage() {
        /* if jStorage string is retrieved, then decode it */
        if (_storage_service.jStorage) try {
            _storage = JSON.parse(String(_storage_service.jStorage));
        } catch (E6) {
            _storage_service.jStorage = "{}";
        } else _storage_service.jStorage = "{}";
        _storage_size = _storage_service.jStorage ? String(_storage_service.jStorage).length : 0, 
        _storage.__jstorage_meta || (_storage.__jstorage_meta = {}), _storage.__jstorage_meta.CRC32 || (_storage.__jstorage_meta.CRC32 = {});
    }
    /**
     * This functions provides the "save" mechanism to store the jStorage object
     */
    function _save() {
        _dropOldEvents();
        // remove expired events
        try {
            _storage_service.jStorage = JSON.stringify(_storage), // If userData is used as the storage engine, additional
            _storage_elm && (_storage_elm.setAttribute("jStorage", _storage_service.jStorage), 
            _storage_elm.save("jStorage")), _storage_size = _storage_service.jStorage ? String(_storage_service.jStorage).length : 0;
        } catch (E7) {}
    }
    /**
     * Function checks if a key is set and is string or numberic
     *
     * @param {string} key Key name
     */
    function _checkKey(key) {
        if (!key || "string" != typeof key && "number" != typeof key) throw new TypeError("Key name must be string or numeric");
        if ("__jstorage_meta" == key) throw new TypeError("Reserved key name");
        return !0;
    }
    /**
     * Removes expired keys
     */
    function _handleTTL() {
        var curtime, i, TTL, CRC32, nextExpire = 1/0, changed = !1, deleted = [];
        if (clearTimeout(_ttl_timeout), _storage.__jstorage_meta && "object" == typeof _storage.__jstorage_meta.TTL) {
            curtime = +new Date(), TTL = _storage.__jstorage_meta.TTL, CRC32 = _storage.__jstorage_meta.CRC32;
            for (i in TTL) TTL.hasOwnProperty(i) && (TTL[i] <= curtime ? (delete TTL[i], delete CRC32[i], 
            delete _storage[i], changed = !0, deleted.push(i)) : TTL[i] < nextExpire && (nextExpire = TTL[i]));
            // set next check
            1/0 != nextExpire && (_ttl_timeout = setTimeout(_handleTTL, nextExpire - curtime)), 
            // save changes
            changed && (_save(), _publishChange(), _fireObservers(deleted, "deleted"));
        }
    }
    /**
     * Checks if there's any events on hold to be fired to listeners
     */
    function _handlePubSub() {
        if (_storage.__jstorage_meta.PubSub) {
            for (var pubelm, _pubsubCurrent = _pubsub_last, i = len = _storage.__jstorage_meta.PubSub.length - 1; i >= 0; i--) pubelm = _storage.__jstorage_meta.PubSub[i], 
            pubelm[0] > _pubsub_last && (_pubsubCurrent = pubelm[0], _fireSubscribers(pubelm[1], pubelm[2]));
            _pubsub_last = _pubsubCurrent;
        }
    }
    /**
     * Fires all subscriber listeners for a pubsub channel
     *
     * @param {string} channel Channel name
     * @param {Mixed} payload Payload data to deliver
     */
    function _fireSubscribers(channel, payload) {
        if (_pubsub_observers[channel]) for (var i = 0, len = _pubsub_observers[channel].length; len > i; i++) // send immutable data that can't be modified by listeners
        _pubsub_observers[channel][i](channel, JSON.parse(JSON.stringify(payload)));
    }
    /**
     * Remove old events from the publish stream (at least 2sec old)
     */
    function _dropOldEvents() {
        if (_storage.__jstorage_meta.PubSub) {
            for (var retire = +new Date() - 2e3, i = 0, len = _storage.__jstorage_meta.PubSub.length; len > i; i++) if (_storage.__jstorage_meta.PubSub[i][0] <= retire) {
                // deleteCount is needed for IE6
                _storage.__jstorage_meta.PubSub.splice(i, _storage.__jstorage_meta.PubSub.length - i);
                break;
            }
            _storage.__jstorage_meta.PubSub.length || delete _storage.__jstorage_meta.PubSub;
        }
    }
    /**
     * Publish payload to a channel
     *
     * @param {string} channel Channel name
     * @param {Mixed} payload Payload to send to the subscribers
     */
    function _publish(channel, payload) {
        _storage.__jstorage_meta || (_storage.__jstorage_meta = {}), _storage.__jstorage_meta.PubSub || (_storage.__jstorage_meta.PubSub = []), 
        _storage.__jstorage_meta.PubSub.unshift([ +new Date(), channel, payload ]), _save(), 
        _publishChange();
    }
    /**
     * JS Implementation of MurmurHash2
     *
     *  SOURCE: https://github.com/garycourt/murmurhash-js (MIT licensed)
     *
     * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
     * @see http://github.com/garycourt/murmurhash-js
     * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
     * @see http://sites.google.com/site/murmurhash/
     *
     * @param {string} str ASCII only
     * @param {number} seed Positive integer only
     * @return {number} 32-bit positive integer hash
     */
    function murmurhash2_32_gc(str, seed) {
        for (var k, l = str.length, h = seed ^ l, i = 0; l >= 4; ) k = 255 & str.charCodeAt(i) | (255 & str.charCodeAt(++i)) << 8 | (255 & str.charCodeAt(++i)) << 16 | (255 & str.charCodeAt(++i)) << 24, 
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16), k ^= k >>> 24, 
        k = 1540483477 * (65535 & k) + ((1540483477 * (k >>> 16) & 65535) << 16), h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16) ^ k, 
        l -= 4, ++i;
        switch (l) {
          case 3:
            h ^= (255 & str.charCodeAt(i + 2)) << 16;

          case 2:
            h ^= (255 & str.charCodeAt(i + 1)) << 8;

          case 1:
            h ^= 255 & str.charCodeAt(i), h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16);
        }
        return h ^= h >>> 13, h = 1540483477 * (65535 & h) + ((1540483477 * (h >>> 16) & 65535) << 16), 
        h ^= h >>> 15, h >>> 0;
    }
    var /* jStorage version */
    JSTORAGE_VERSION = "0.3.2", /* detect a dollar object or create one if not found */
    $ = window.jQuery || window.$ || (window.$ = {}), /* check for a JSON handling support */
    JSON = {
        parse: window.JSON && (window.JSON.parse || window.JSON.decode) || String.prototype.evalJSON && function(str) {
            return String(str).evalJSON();
        } || $.parseJSON || $.evalJSON,
        stringify: Object.toJSON || window.JSON && (window.JSON.stringify || window.JSON.encode) || $.toJSON
    };
    // Break if no JSON support was found
    if (!JSON.parse || !JSON.stringify) throw new Error("No JSON support found, include //cdnjs.cloudflare.com/ajax/libs/json2/20110223/json2.js to page");
    var /* Next check for TTL */
    _ttl_timeout, /* This is the object, that holds the cached values */
    _storage = {
        __jstorage_meta: {
            CRC32: {}
        }
    }, /* Actual browser storage (localStorage or globalStorage['domain']) */
    _storage_service = {
        jStorage: "{}"
    }, /* DOM element for older IE versions, holds userData behavior */
    _storage_elm = null, /* How much space does the storage take */
    _storage_size = 0, /* which backend is currently used */
    _backend = !1, /* onchange observers */
    _observers = {}, /* timeout to wait after onchange event */
    _observer_timeout = !1, /* last update time */
    _observer_update = 0, /* pubsub observers */
    _pubsub_observers = {}, /* skip published items older than current timestamp */
    _pubsub_last = +new Date(), /**
         * XML encoding and decoding as XML nodes can't be JSON'ized
         * XML nodes are encoded and decoded if the node is the value to be saved
         * but not if it's as a property of another object
         * Eg. -
         *   $.jStorage.set("key", xmlNode);        // IS OK
         *   $.jStorage.set("key", {xml: xmlNode}); // NOT OK
         */
    _XMLService = {
        /**
             * Validates a XML node to be XML
             * based on jQuery.isXML function
             */
        isXML: function(elm) {
            var documentElement = (elm ? elm.ownerDocument || elm : 0).documentElement;
            return documentElement ? "HTML" !== documentElement.nodeName : !1;
        },
        /**
             * Encodes a XML node to string
             * based on http://www.mercurytide.co.uk/news/article/issues-when-working-ajax/
             */
        encode: function(xmlNode) {
            if (!this.isXML(xmlNode)) return !1;
            try {
                // Mozilla, Webkit, Opera
                return new XMLSerializer().serializeToString(xmlNode);
            } catch (E1) {
                try {
                    // IE
                    return xmlNode.xml;
                } catch (E2) {}
            }
            return !1;
        },
        /**
             * Decodes a XML node from string
             * loosely based on http://outwestmedia.com/jquery-plugins/xmldom/
             */
        decode: function(xmlString) {
            var resultXML, dom_parser = "DOMParser" in window && new DOMParser().parseFromString || window.ActiveXObject && function(_xmlString) {
                var xml_doc = new ActiveXObject("Microsoft.XMLDOM");
                return xml_doc.async = "false", xml_doc.loadXML(_xmlString), xml_doc;
            };
            return dom_parser ? (resultXML = dom_parser.call("DOMParser" in window && new DOMParser() || window, xmlString, "text/xml"), 
            this.isXML(resultXML) ? resultXML : !1) : !1;
        }
    }, _localStoragePolyfillSetKey = function() {};
    ////////////////////////// PUBLIC INTERFACE /////////////////////////
    $.jStorage = {
        /* Version number */
        version: JSTORAGE_VERSION,
        /**
         * Sets a key's value.
         *
         * @param {string} key Key to set. If this value is not set or not
         *              a string an exception is raised.
         * @param {Mixed} value Value to set. This can be any value that is JSON
         *              compatible (Numbers, Strings, Objects etc.).
         * @param {object} [options] - possible options to use
         * @param {number} [options.TTL] - optional TTL value
         * @return {Mixed} the used value
         */
        set: function(key, value, options) {
            // undefined values are deleted automatically
            if (_checkKey(key), options = options || {}, "undefined" == typeof value) return this.deleteKey(key), 
            value;
            if (_XMLService.isXML(value)) value = {
                _is_xml: !0,
                xml: _XMLService.encode(value)
            }; else {
                if ("function" == typeof value) return void 0;
                value && "object" == typeof value && (// clone the object before saving to _storage tree
                value = JSON.parse(JSON.stringify(value)));
            }
            // also handles saving and _publishChange
            return _storage[key] = value, _storage.__jstorage_meta.CRC32[key] = "2." + murmurhash2_32_gc(JSON.stringify(value)), 
            this.setTTL(key, options.TTL || 0), _localStoragePolyfillSetKey(key, value), _fireObservers(key, "updated"), 
            value;
        },
        /**
         * Looks up a key in cache
         *
         * @param {string} key - Key to look up.
         * @param {mixed} def - Default value to return, if key didn't exist.
         * @return {Mixed} the key value, default value or null
         */
        get: function(key, def) {
            return _checkKey(key), key in _storage ? _storage[key] && "object" == typeof _storage[key] && _storage[key]._is_xml ? _XMLService.decode(_storage[key].xml) : _storage[key] : "undefined" == typeof def ? null : def;
        },
        /**
         * Deletes a key from cache.
         *
         * @param {string} key - Key to delete.
         * @return {Boolean} true if key existed or false if it didn't
         */
        deleteKey: function(key) {
            // remove from TTL list
            return _checkKey(key), key in _storage ? (delete _storage[key], "object" == typeof _storage.__jstorage_meta.TTL && key in _storage.__jstorage_meta.TTL && delete _storage.__jstorage_meta.TTL[key], 
            delete _storage.__jstorage_meta.CRC32[key], _localStoragePolyfillSetKey(key, void 0), 
            _save(), _publishChange(), _fireObservers(key, "deleted"), !0) : !1;
        },
        /**
         * Sets a TTL for a key, or remove it if ttl value is 0 or below
         *
         * @param {string} key - key to set the TTL for
         * @param {number} ttl - TTL timeout in milliseconds
         * @return {Boolean} true if key existed or false if it didn't
         */
        setTTL: function(key, ttl) {
            var curtime = +new Date();
            // Set TTL value for the key
            return _checkKey(key), ttl = Number(ttl) || 0, key in _storage ? (_storage.__jstorage_meta.TTL || (_storage.__jstorage_meta.TTL = {}), 
            ttl > 0 ? _storage.__jstorage_meta.TTL[key] = curtime + ttl : delete _storage.__jstorage_meta.TTL[key], 
            _save(), _handleTTL(), _publishChange(), !0) : !1;
        },
        /**
         * Gets remaining TTL (in milliseconds) for a key or 0 when no TTL has been set
         *
         * @param {string} key Key to check
         * @return {number} Remaining TTL in milliseconds
         */
        getTTL: function(key) {
            var ttl, curtime = +new Date();
            return _checkKey(key), key in _storage && _storage.__jstorage_meta.TTL && _storage.__jstorage_meta.TTL[key] ? (ttl = _storage.__jstorage_meta.TTL[key] - curtime, 
            ttl || 0) : 0;
        },
        /**
         * Deletes everything in cache.
         *
         * @return {Boolean} Always true
         */
        flush: function() {
            return _storage = {
                __jstorage_meta: {
                    CRC32: {}
                }
            }, _createPolyfillStorage("local", !0), _save(), _publishChange(), _fireObservers(null, "flushed"), 
            !0;
        },
        /**
         * Returns a read-only copy of _storage
         *
         * @return {object} Read-only copy of _storage
        */
        storageObj: function() {
            function F() {}
            return F.prototype = _storage, new F();
        },
        /**
         * Returns an index of all used keys as an array
         * ['key1', 'key2',..'keyN']
         *
         * @return {Array} Used keys
        */
        index: function() {
            var i, index = [];
            for (i in _storage) _storage.hasOwnProperty(i) && "__jstorage_meta" != i && index.push(i);
            return index;
        },
        /**
         * How much space in bytes does the storage take?
         *
         * @return {number} Storage size in chars (not the same as in bytes,
         *                  since some chars may take several bytes)
         */
        storageSize: function() {
            return _storage_size;
        },
        /**
         * Which backend is currently in use?
         *
         * @return {string} Backend name
         */
        currentBackend: function() {
            return _backend;
        },
        /**
         * Test if storage is available
         *
         * @return {Boolean} True if storage can be used
         */
        storageAvailable: function() {
            return !!_backend;
        },
        /**
         * Register change listeners
         *
         * @param {string} key Key name
         * @param {Function} callback Function to run when the key changes
         */
        listenKeyChange: function(key, callback) {
            _checkKey(key), _observers[key] || (_observers[key] = []), _observers[key].push(callback);
        },
        /**
         * Remove change listeners
         *
         * @param {string} key Key name to unregister listeners against
         * @param {Function} [callback] If set, unregister the callback, if not - unregister all
         */
        stopListening: function(key, callback) {
            if (_checkKey(key), _observers[key]) {
                if (!callback) return void delete _observers[key];
                for (var i = _observers[key].length - 1; i >= 0; i--) _observers[key][i] == callback && _observers[key].splice(i, 1);
            }
        },
        /**
         * Subscribe to a Publish/Subscribe event stream
         *
         * @param {string} channel Channel name
         * @param {Function} callback Function to run when the something is published to the channel
         */
        subscribe: function(channel, callback) {
            if (channel = (channel || "").toString(), !channel) throw new TypeError("Channel not defined");
            _pubsub_observers[channel] || (_pubsub_observers[channel] = []), _pubsub_observers[channel].push(callback);
        },
        /**
         * Publish data to an event stream
         *
         * @param {string} channel Channel name
         * @param {Mixed} payload Payload to deliver
         */
        publish: function(channel, payload) {
            if (channel = (channel || "").toString(), !channel) throw new TypeError("Channel not defined");
            _publish(channel, payload);
        },
        /**
         * Reloads the data from browser storage
         */
        reInit: function() {
            _reloadData();
        }
    }, // Initialize jStorage
    _init();
}();

/* 
 * a backwards compatable implementation of postMessage
 * by Josh Fraser (joshfraser.com)
 * released under the Apache 2.0 license.  
 *
 * this code was adapted from Ben Alman's jQuery postMessage code found at:
 * http://benalman.com/projects/jquery-postmessage-plugin/
 * 
 * other inspiration was taken from Luke Shepard's code for Facebook Connect:
 * http://github.com/facebook/connect-js/blob/master/src/core/xd.js
 *
 * the goal of this project was to make a backwards compatable version of postMessage
 * without having any dependency on jQuery or the FB Connect libraries
 *
 * my goal was to keep this as terse as possible since my own purpose was to use this 
 * as part of a distributed widget where filesize could be sensative.
 * 
 */
// everything is wrapped in the XD function to reduce namespace collisions
var XD = function() {
    "use strict";
    /* jshint sub:true */
    var interval_id, last_hash, attached_callback, cache_bust = 1, window = this;
    return {
        postMessage: function(message, target_url, target) {
            target_url && (target = target || parent, // default to parent
            window.postMessage ? // the browser supports window.postMessage, so call it with a targetOrigin
            // set appropriately, based on the target_url parameter.
            target.postMessage(message, target_url.replace(/([^:]+:\/\/[^\/]+).*/, "$1")) : target_url && (// the browser does not support window.postMessage, so set the location
            // of the target to target_url#message. A bit ugly, but it works! A cache
            // bust parameter is added to ensure that repeat messages trigger the callback.
            target.location = target_url.replace(/#.*$/, "") + "#" + +new Date() + cache_bust++ + "&" + message));
        },
        receiveMessage: function(callback, source_origin) {
            // browser supports window.postMessage
            window && window.postMessage ? (// bind the callback to the actual event associated with window.postMessage
            callback && (attached_callback = function(e) {
                return "file:" === window.location.protocol && callback(e), "string" == typeof source_origin && e.origin !== source_origin || "[object Function]" === Object.prototype.toString.call(source_origin) && source_origin(e.origin) === !1 ? !1 : void callback(e);
            }), window.addEventListener ? window[callback ? "addEventListener" : "removeEventListener"]("message", attached_callback, !1) : window[callback ? "attachEvent" : "detachEvent"]("onmessage", attached_callback)) : (// a polling loop is started & callback is called whenever the location.hash changes
            interval_id && clearInterval(interval_id), interval_id = null, callback && (interval_id = setInterval(function() {
                var hash = document.location.hash, re = /^#?\d+&/;
                hash !== last_hash && re.test(hash) && (last_hash = hash, callback({
                    data: hash.replace(re, "")
                }));
            }, 100)));
        }
    };
}();

/*!
 * jQuery UI Touch Punch 0.2.2
 *
 * Copyright 2011, Dave Furfero
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * Depends:
 *  jquery.ui.widget.js
 *  jquery.ui.mouse.js
 */
!function($) {
    /**
   * Simulate a mouse event based on a corresponding touch event
   * @param {Object} event A touch event
   * @param {String} simulatedType The corresponding mouse event
   */
    function simulateMouseEvent(event, simulatedType) {
        // Ignore multi-touch events
        if (!(event.originalEvent.touches.length > 1)) {
            event.preventDefault();
            var touch = event.originalEvent.changedTouches[0], simulatedEvent = document.createEvent("MouseEvents");
            // Initialize the simulated mouse event using the touch event's coordinates
            simulatedEvent.initMouseEvent(simulatedType, // type
            !0, // bubbles                    
            !0, // cancelable                 
            window, // view                       
            1, // detail                     
            touch.screenX, // screenX                    
            touch.screenY, // screenY                    
            touch.clientX, // clientX                    
            touch.clientY, // clientY                    
            !1, // ctrlKey                    
            !1, // altKey                     
            !1, // shiftKey                   
            !1, // metaKey                    
            0, // button                     
            null), // Dispatch the simulated event to the target element
            event.target.dispatchEvent(simulatedEvent);
        }
    }
    // Ignore browsers without touch support
    if (// Detect touch support
    $.support.touch = "ontouchend" in document, $.support.touch) {
        var touchHandled, mouseProto = $.ui.mouse.prototype, _mouseInit = mouseProto._mouseInit;
        /**
   * Handle the jQuery UI widget's touchstart events
   * @param {Object} event The widget element's touchstart event
   */
        mouseProto._touchStart = function(event) {
            var self = this;
            // Ignore the event if another widget is already being handled
            !touchHandled && self._mouseCapture(event.originalEvent.changedTouches[0]) && (// Set the flag to prevent other widgets from inheriting the touch event
            touchHandled = !0, // Track movement to determine if interaction was a click
            self._touchMoved = !1, // Simulate the mouseover event
            simulateMouseEvent(event, "mouseover"), // Simulate the mousemove event
            simulateMouseEvent(event, "mousemove"), // Simulate the mousedown event
            simulateMouseEvent(event, "mousedown"));
        }, /**
   * Handle the jQuery UI widget's touchmove events
   * @param {Object} event The document's touchmove event
   */
        mouseProto._touchMove = function(event) {
            // Ignore event if not handled
            touchHandled && (// Interaction was not a click
            this._touchMoved = !0, // Simulate the mousemove event
            simulateMouseEvent(event, "mousemove"));
        }, /**
   * Handle the jQuery UI widget's touchend events
   * @param {Object} event The document's touchend event
   */
        mouseProto._touchEnd = function(event) {
            // Ignore event if not handled
            touchHandled && (// Simulate the mouseup event
            simulateMouseEvent(event, "mouseup"), // Simulate the mouseout event
            simulateMouseEvent(event, "mouseout"), // If the touch interaction did not move, it should trigger a click
            this._touchMoved || // Simulate the click event
            simulateMouseEvent(event, "click"), // Unset the flag to allow other widgets to inherit the touch event
            touchHandled = !1);
        }, /**
   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.
   * This method extends the widget with bound touch event handlers that
   * translate touch events to mouse events and pass them to the widget's
   * original mouse event handling methods.
   */
        mouseProto._mouseInit = function() {
            var self = this;
            // Delegate the touch handlers to the widget's element
            self.element.bind("touchstart", $.proxy(self, "_touchStart")).bind("touchmove", $.proxy(self, "_touchMove")).bind("touchend", $.proxy(self, "_touchEnd")), 
            // Call the original $.ui.mouse init method
            _mouseInit.call(self);
        };
    }
}(jQuery), /*
 * @fileOverview TouchSwipe - jQuery Plugin
 * @version 1.6.5
 *
 * @author Matt Bryson http://www.github.com/mattbryson
 * @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
 * @see http://labs.skinkers.com/touchSwipe/
 * @see http://plugins.jquery.com/project/touchSwipe
 *
 * Copyright (c) 2010 Matt Bryson
 * Dual licensed under the MIT or GPL Version 2 licenses.
 *
 *
 * Changelog
 * $Date: 2010-12-12 (Wed, 12 Dec 2010) $
 * $version: 1.0.0
 * $version: 1.0.1 - removed multibyte comments
 *
 * $Date: 2011-21-02 (Mon, 21 Feb 2011) $
 * $version: 1.1.0 	- added allowPageScroll property to allow swiping and scrolling of page
 *					- changed handler signatures so one handler can be used for multiple events
 * $Date: 2011-23-02 (Wed, 23 Feb 2011) $
 * $version: 1.2.0 	- added click handler. This is fired if the user simply clicks and does not swipe. The event object and click target are passed to handler.
 *					- If you use the http://code.google.com/p/jquery-ui-for-ipad-and-iphone/ plugin, you can also assign jQuery mouse events to children of a touchSwipe object.
 * $version: 1.2.1 	- removed console log!
 *
 * $version: 1.2.2 	- Fixed bug where scope was not preserved in callback methods.
 *
 * $Date: 2011-28-04 (Thurs, 28 April 2011) $
 * $version: 1.2.4 	- Changed licence terms to be MIT or GPL inline with jQuery. Added check for support of touch events to stop non compatible browsers erroring.
 *
 * $Date: 2011-27-09 (Tues, 27 September 2011) $
 * $version: 1.2.5 	- Added support for testing swipes with mouse on desktop browser (thanks to https://github.com/joelhy)
 *
 * $Date: 2012-14-05 (Mon, 14 May 2012) $
 * $version: 1.2.6 	- Added timeThreshold between start and end touch, so user can ignore slow swipes (thanks to Mark Chase). Default is null, all swipes are detected
 *
 * $Date: 2012-05-06 (Tues, 05 June 2012) $
 * $version: 1.2.7 	- Changed time threshold to have null default for backwards compatibility. Added duration param passed back in events, and refactored how time is handled.
 *
 * $Date: 2012-05-06 (Tues, 05 June 2012) $
 * $version: 1.2.8 	- Added the possibility to return a value like null or false in the trigger callback. In that way we can control when the touch start/move should take effect or not (simply by returning in some cases return null; or return false;) This effects the ontouchstart/ontouchmove event.
 *
 * $Date: 2012-06-06 (Wed, 06 June 2012) $
 * $version: 1.3.0 	- Refactored whole plugin to allow for methods to be executed, as well as exposed defaults for user override. Added 'enable', 'disable', and 'destroy' methods
 *
 * $Date: 2012-05-06 (Fri, 05 June 2012) $
 * $version: 1.3.1 	- Bug fixes  - bind() with false as last argument is no longer supported in jQuery 1.6, also, if you just click, the duration is now returned correctly.
 *
 * $Date: 2012-29-07 (Sun, 29 July 2012) $
 * $version: 1.3.2	- Added fallbackToMouseEvents option to NOT capture mouse events on non touch devices.
 * 			- Added "all" fingers value to the fingers property, so any combination of fingers triggers the swipe, allowing event handlers to check the finger count
 *
 * $Date: 2012-09-08 (Thurs, 9 Aug 2012) $
 * $version: 1.3.3	- Code tidy prep for minefied version
 *
 * $Date: 2012-04-10 (wed, 4 Oct 2012) $
 * $version: 1.4.0	- Added pinch support, pinchIn and pinchOut
 *
 * $Date: 2012-11-10 (Thurs, 11 Oct 2012) $
 * $version: 1.5.0	- Added excludedElements, a jquery selector that specifies child elements that do NOT trigger swipes. By default, this is one select that removes all form, input select, button and anchor elements.
 *
 * $Date: 2012-22-10 (Mon, 22 Oct 2012) $
 * $version: 1.5.1	- Fixed bug with jQuery 1.8 and trailing comma in excludedElements
 *					- Fixed bug with IE and eventPreventDefault()
 * $Date: 2013-01-12 (Fri, 12 Jan 2013) $
 * $version: 1.6.0	- Fixed bugs with pinching, mainly when both pinch and swipe enabled, as well as adding time threshold for multifinger gestures, so releasing one finger beofre the other doesnt trigger as single finger gesture.
 *					- made the demo site all static local HTML pages so they can be run locally by a developer
 *					- added jsDoc comments and added documentation for the plugin
 *					- code tidy
 *					- added triggerOnTouchLeave property that will end the event when the user swipes off the element.
 * $Date: 2013-03-23 (Sat, 23 Mar 2013) $
 * $version: 1.6.1	- Added support for ie8 touch events
 * $version: 1.6.2	- Added support for events binding with on / off / bind in jQ for all callback names.
 *                   - Deprecated the 'click' handler in favour of tap.
 *                   - added cancelThreshold property
 *                   - added option method to update init options at runtime
 *
 * $version 1.6.3    - added doubletap, longtap events and longTapThreshold, doubleTapThreshold property
 * $Date: 2013-04-04 (Thurs, 04 April 2013) $
 * $version 1.6.4    - Fixed bug with cancelThreshold introduced in 1.6.3, where swipe status no longer fired start event, and stopped once swiping back.
 *
 * $Date: 2013-08-24 (Sat, 24 Aug 2013) $
 * $version 1.6.5    - Merged a few pull requests fixing various bugs, added AMD support.

 */
/**
 * See (http://jquery.com/).
 * @name $
 * @class
 * See the jQuery Library  (http://jquery.com/) for full details.  This just
 * documents the function and classes that are added to jQuery by this plug-in.
 */
/**
 * See (http://jquery.com/)
 * @name fn
 * @class
 * See the jQuery Library  (http://jquery.com/) for full details.  This just
 * documents the function and classes that are added to jQuery by this plug-in.
 * @memberOf $
 */
function(factory) {
    "function" == typeof define && define.amd && define.amd.jQuery ? // AMD. Register as anonymous module.
    define([ "jquery" ], factory) : // Browser globals.
    factory(jQuery);
}(function($) {
    "use strict";
    /**
     * Initialise the plugin for each DOM element matched
     * This creates a new instance of the main TouchSwipe class for each DOM element, and then
     * saves a reference to that instance in the elements data property.
     * @internal
     */
    function init(options) {
        //For each element instantiate the plugin
        //Prep and extend the options
        //Check for deprecated options
        //Ensure that any old click handlers are assigned to the new tap, unless we have a tap
        //pass empty object so we dont modify the defaults
        return !options || void 0 !== options.allowPageScroll || void 0 === options.swipe && void 0 === options.swipeStatus || (options.allowPageScroll = NONE), 
        void 0 !== options.click && void 0 === options.tap && (options.tap = options.click), 
        options || (options = {}), options = $.extend({}, $.fn.swipe.defaults, options), 
        this.each(function() {
            var $this = $(this), plugin = $this.data(PLUGIN_NS);
            plugin || (plugin = new TouchSwipe(this, options), $this.data(PLUGIN_NS, plugin));
        });
    }
    /**
     * Main TouchSwipe Plugin Class.
     * Do not use this to construct your TouchSwipe object, use the jQuery plugin method $.fn.swipe(); {@link $.fn.swipe}
     * @private
     * @name TouchSwipe
     * @param {DOMNode} element The HTML DOM object to apply to plugin to
     * @param {Object} options The options to configure the plugin with.  @link {$.fn.swipe.defaults}
     * @see $.fh.swipe.defaults
     * @see $.fh.swipe
     * @class
     */
    function TouchSwipe(element, options) {
        //
        // Private methods
        //
        //
        // EVENTS
        //
        /**
         * Event handler for a touch start event.
         * Stops the default click event from triggering and stores where we touched
         * @inner
         * @param {object} jqEvent The normalised jQuery event object.
         */
        function touchStart(jqEvent) {
            //If we already in a touch event (a finger already in use) then ignore subsequent ones..
            if (!(getTouchInProgress() || $(jqEvent.target).closest(options.excludedElements, $element).length > 0)) //Check if this element matches any in the excluded elements selectors,  or its parent is excluded, if so, DON'T swipe
            {
                //As we use Jquery bind for events, we need to target the original event object
                //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
                var ret, event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent, evt = SUPPORTS_TOUCH ? event.touches[0] : event;
                //If we have a return value from the users handler, then return and cancel
                //If we support touches, get the finger count
                // get the total number of fingers touching the screen
                //clear vars..
                // check the number of fingers is what we are looking for, or we are capturing pinches
                // get the coordinates of the touch
                //Keep track of the initial pinch distance, so we can calculate the diff later
                //Store second finger data as start
                //A touch with more or less than the fingers we are looking for, so cancel
                //If we have a return value from the users handler, then return and cancel
                return phase = PHASE_START, SUPPORTS_TOUCH ? fingerCount = event.touches.length : jqEvent.preventDefault(), 
                distance = 0, direction = null, pinchDirection = null, duration = 0, startTouchesDistance = 0, 
                endTouchesDistance = 0, pinchZoom = 1, pinchDistance = 0, fingerData = createAllFingerData(), 
                maximumsMap = createMaximumsData(), cancelMultiFingerRelease(), !SUPPORTS_TOUCH || fingerCount === options.fingers || options.fingers === ALL_FINGERS || hasPinches() ? (createFingerData(0, evt), 
                startTime = getTimeStamp(), 2 == fingerCount && (createFingerData(1, event.touches[1]), 
                startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)), 
                (options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event, phase))) : ret = !1, 
                ret === !1 ? (phase = PHASE_CANCEL, triggerHandler(event, phase), ret) : (setTouchInProgress(!0), 
                null);
            }
        }
        /**
         * Event handler for a touch move event.
         * If we change fingers during move, then cancel the event
         * @inner
         * @param {object} jqEvent The normalised jQuery event object.
         */
        function touchMove(jqEvent) {
            //As we use Jquery bind for events, we need to target the original event object
            //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
            var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;
            //If we are ending, cancelling, or within the threshold of 2 fingers being released, don't track anything..
            if (phase !== PHASE_END && phase !== PHASE_CANCEL && !inMultiFingerRelease()) {
                var ret, evt = SUPPORTS_TOUCH ? event.touches[0] : event, currentFinger = updateFingerData(evt);
                if (endTime = getTimeStamp(), SUPPORTS_TOUCH && (fingerCount = event.touches.length), 
                phase = PHASE_MOVE, //If we have 2 fingers get Touches distance as well
                2 == fingerCount && (//Keep track of the initial pinch distance, so we can calculate the diff later
                //We do this here as well as the start event, in case they start with 1 finger, and the press 2 fingers
                0 == startTouchesDistance ? (//Create second finger if this is the first time...
                createFingerData(1, event.touches[1]), startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start)) : (//Else just update the second finger
                updateFingerData(event.touches[1]), endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end), 
                pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end)), 
                pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance), pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance)), 
                fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH || hasPinches()) {
                    //If we trigger end events when threshold are met, or trigger events when touch leaves element
                    if (direction = calculateDirection(currentFinger.start, currentFinger.end), //Check if we need to prevent default event (page scroll / pinch zoom) or not
                    validateDefaultEvent(jqEvent, direction), //Distance and duration are all off the main finger
                    distance = calculateDistance(currentFinger.start, currentFinger.end), duration = calculateDuration(), 
                    //Cache the maximum distance we made in this direction
                    setMaxDistance(direction, distance), (options.swipeStatus || options.pinchStatus) && (ret = triggerHandler(event, phase)), 
                    !options.triggerOnTouchEnd || options.triggerOnTouchLeave) {
                        var inBounds = !0;
                        //If checking if we leave the element, run the bounds check (we can use touchleave as its not supported on webkit)
                        if (options.triggerOnTouchLeave) {
                            var bounds = getbounds(this);
                            inBounds = isInBounds(currentFinger.end, bounds);
                        }
                        //Trigger end handles as we swipe if thresholds met or if we have left the element if the user has asked to check these..
                        !options.triggerOnTouchEnd && inBounds ? phase = getNextPhase(PHASE_MOVE) : options.triggerOnTouchLeave && !inBounds && (phase = getNextPhase(PHASE_END)), 
                        (phase == PHASE_CANCEL || phase == PHASE_END) && triggerHandler(event, phase);
                    }
                } else phase = PHASE_CANCEL, triggerHandler(event, phase);
                ret === !1 && (phase = PHASE_CANCEL, triggerHandler(event, phase));
            }
        }
        /**
         * Event handler for a touch end event.
         * Calculate the direction and trigger events
         * @inner
         * @param {object} jqEvent The normalised jQuery event object.
         */
        function touchEnd(jqEvent) {
            //As we use Jquery bind for events, we need to target the original event object
            var event = jqEvent.originalEvent;
            //If we are still in a touch with another finger return
            //This allows us to wait a fraction and see if the other finger comes up, if it does within the threshold, then we treat it as a multi release, not a single release.
            //If we are still in a touch with another finger return
            //This allows us to wait a fraction and see if the other finger comes up, if it does within the threshold, then we treat it as a multi release, not a single release.
            //If a previous finger has been released, check how long ago, if within the threshold, then assume it was a multifinger release.
            //This is used to allow 2 fingers to release fractionally after each other, whilst maintainig the event as containg 2 fingers, not 1
            //call this on jq event so we are cross browser
            //Set end of swipe
            //Get duration incase move was never fired
            //If we trigger handlers at end of swipe OR, we trigger during, but they didnt trigger and we are still in the move phase
            //Trigger the pinch events...
            return SUPPORTS_TOUCH && event.touches.length > 0 ? (startMultiFingerRelease(), 
            !0) : (inMultiFingerRelease() && (fingerCount = previousTouchFingerCount), jqEvent.preventDefault(), 
            endTime = getTimeStamp(), duration = calculateDuration(), didSwipeBackToCancel() ? (phase = PHASE_CANCEL, 
            triggerHandler(event, phase)) : options.triggerOnTouchEnd || 0 == options.triggerOnTouchEnd && phase === PHASE_MOVE ? (phase = PHASE_END, 
            triggerHandler(event, phase)) : !options.triggerOnTouchEnd && hasTap() ? (phase = PHASE_END, 
            triggerHandlerForGesture(event, phase, TAP)) : phase === PHASE_MOVE && (phase = PHASE_CANCEL, 
            triggerHandler(event, phase)), setTouchInProgress(!1), null);
        }
        /**
         * Event handler for a touch cancel event.
         * Clears current vars
         * @inner
         */
        function touchCancel() {
            // reset the variables back to default values
            fingerCount = 0, endTime = 0, startTime = 0, startTouchesDistance = 0, endTouchesDistance = 0, 
            pinchZoom = 1, //If we were in progress of tracking a possible multi touch end, then re set it.
            cancelMultiFingerRelease(), setTouchInProgress(!1);
        }
        /**
         * Event handler for a touch leave event.
         * This is only triggered on desktops, in touch we work this out manually
         * as the touchleave event is not supported in webkit
         * @inner
         */
        function touchLeave(jqEvent) {
            var event = jqEvent.originalEvent;
            //If we have the trigger on leave property set....
            options.triggerOnTouchLeave && (phase = getNextPhase(PHASE_END), triggerHandler(event, phase));
        }
        /**
         * Removes all listeners that were associated with the plugin
         * @inner
         */
        function removeListeners() {
            $element.unbind(START_EV, touchStart), $element.unbind(CANCEL_EV, touchCancel), 
            $element.unbind(MOVE_EV, touchMove), $element.unbind(END_EV, touchEnd), //we only have leave events on desktop, we manually calculate leave on touch as its not supported in webkit
            LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave), setTouchInProgress(!1);
        }
        /**
         * Checks if the time and distance thresholds have been met, and if so then the appropriate handlers are fired.
         */
        function getNextPhase(currentPhase) {
            var nextPhase = currentPhase, validTime = validateSwipeTime(), validDistance = validateSwipeDistance(), didCancel = didSwipeBackToCancel();
            //If we have exceeded our time, then cancel
            return !validTime || didCancel ? nextPhase = PHASE_CANCEL : !validDistance || currentPhase != PHASE_MOVE || options.triggerOnTouchEnd && !options.triggerOnTouchLeave ? !validDistance && currentPhase == PHASE_END && options.triggerOnTouchLeave && (nextPhase = PHASE_CANCEL) : nextPhase = PHASE_END, 
            nextPhase;
        }
        /**
         * Trigger the relevant event handler
         * The handlers are passed the original event, the element that was swiped, and in the case of the catch all handler, the direction that was swiped, "left", "right", "up", or "down"
         * @param {object} event the original event object
         * @param {string} phase the phase of the swipe (start, end cancel etc) {@link $.fn.swipe.phases}
         * @inner
         */
        function triggerHandler(event, phase) {
            var ret = void 0;
            // SWIPE GESTURES
            //hasSwipes as status needs to fire even if swipe is invalid
            //Trigger the swipe events...
            //Trigger the pinch events...
            // CLICK / TAP (if the above didn't cancel)
            //Trigger the tap events...
            //Trigger the tap events...
            //Trigger the tap event..
            // If we are cancelling the gesture, then manually trigger the reset handler
            // If we are ending the gesture, then manually trigger the reset handler IF all fingers are off
            //If we support touch, then check that all fingers are off before we cancel
            return didSwipe() || hasSwipes() ? ret = triggerHandlerForGesture(event, phase, SWIPE) : (didPinch() || hasPinches()) && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, PINCH)), 
            didDoubleTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP) : didLongTap() && ret !== !1 ? ret = triggerHandlerForGesture(event, phase, LONG_TAP) : didTap() && ret !== !1 && (ret = triggerHandlerForGesture(event, phase, TAP)), 
            phase === PHASE_CANCEL && touchCancel(event), phase === PHASE_END && (SUPPORTS_TOUCH ? 0 == event.touches.length && touchCancel(event) : touchCancel(event)), 
            ret;
        }
        /**
         * Trigger the relevant event handler
         * The handlers are passed the original event, the element that was swiped, and in the case of the catch all handler, the direction that was swiped, "left", "right", "up", or "down"
         * @param {object} event the original event object
         * @param {string} phase the phase of the swipe (start, end cancel etc) {@link $.fn.swipe.phases}
         * @param {string} gesture the gesture to trigger a handler for : PINCH or SWIPE {@link $.fn.swipe.gestures}
         * @return Boolean False, to indicate that the event should stop propagation, or void.
         * @inner
         */
        function triggerHandlerForGesture(event, phase, gesture) {
            var ret = void 0;
            //SWIPES....
            if (gesture == SWIPE) {
                //Fire the callback
                if (//Trigger status every time..
                //Trigger the event...
                $element.trigger("swipeStatus", [ phase, direction || null, distance || 0, duration || 0, fingerCount ]), 
                options.swipeStatus && (ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount), 
                ret === !1)) return !1;
                if (phase == PHASE_END && validateSwipe()) {
                    //Fire catch all callback
                    if (//Fire the catch all event
                    $element.trigger("swipe", [ direction, distance, duration, fingerCount ]), options.swipe && (ret = options.swipe.call($element, event, direction, distance, duration, fingerCount), 
                    ret === !1)) return !1;
                    //trigger direction specific event handlers
                    switch (direction) {
                      case LEFT:
                        //Trigger the event
                        $element.trigger("swipeLeft", [ direction, distance, duration, fingerCount ]), //Fire the callback
                        options.swipeLeft && (ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount));
                        break;

                      case RIGHT:
                        //Trigger the event
                        $element.trigger("swipeRight", [ direction, distance, duration, fingerCount ]), 
                        //Fire the callback
                        options.swipeRight && (ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount));
                        break;

                      case UP:
                        //Trigger the event
                        $element.trigger("swipeUp", [ direction, distance, duration, fingerCount ]), //Fire the callback
                        options.swipeUp && (ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount));
                        break;

                      case DOWN:
                        //Trigger the event
                        $element.trigger("swipeDown", [ direction, distance, duration, fingerCount ]), //Fire the callback
                        options.swipeDown && (ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount));
                    }
                }
            }
            //PINCHES....
            if (gesture == PINCH) {
                //Fire the callback
                if (//Trigger the event
                $element.trigger("pinchStatus", [ phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom ]), 
                options.pinchStatus && (ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom), 
                ret === !1)) return !1;
                if (phase == PHASE_END && validatePinch()) switch (pinchDirection) {
                  case IN:
                    //Trigger the event
                    $element.trigger("pinchIn", [ pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom ]), 
                    //Fire the callback
                    options.pinchIn && (ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom));
                    break;

                  case OUT:
                    //Trigger the event
                    $element.trigger("pinchOut", [ pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom ]), 
                    //Fire the callback
                    options.pinchOut && (ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom));
                }
            }
            //Cancel any existing double tap
            //If we are also looking for doubelTaps, wait incase this is one...
            //Cache the time of this tap
            //Now wait for the double tap timeout, and trigger this single tap
            //if its not cancelled by a double tap
            //Trigger the event
            //Fire the callback
            //Cancel any pending singletap
            //Trigger the event
            //Fire the callback
            //Cancel any pending singletap (shouldnt be one)
            //Trigger the event
            //Fire the callback
            return gesture == TAP ? (phase === PHASE_CANCEL || phase === PHASE_END) && (clearTimeout(singleTapTimeout), 
            hasDoubleTap() && !inDoubleTap() ? (doubleTapStartTime = getTimeStamp(), singleTapTimeout = setTimeout($.proxy(function() {
                doubleTapStartTime = null, //Trigger the event
                $element.trigger("tap", [ event.target ]), //Fire the callback
                options.tap && (ret = options.tap.call($element, event, event.target));
            }, this), options.doubleTapThreshold)) : (doubleTapStartTime = null, $element.trigger("tap", [ event.target ]), 
            options.tap && (ret = options.tap.call($element, event, event.target)))) : gesture == DOUBLE_TAP ? (phase === PHASE_CANCEL || phase === PHASE_END) && (clearTimeout(singleTapTimeout), 
            doubleTapStartTime = null, $element.trigger("doubletap", [ event.target ]), options.doubleTap && (ret = options.doubleTap.call($element, event, event.target))) : gesture == LONG_TAP && (phase === PHASE_CANCEL || phase === PHASE_END) && (clearTimeout(singleTapTimeout), 
            doubleTapStartTime = null, $element.trigger("longtap", [ event.target ]), options.longTap && (ret = options.longTap.call($element, event, event.target))), 
            ret;
        }
        //
        // GESTURE VALIDATION
        //
        /**
         * Checks the user has swipe far enough
         * @return Boolean if <code>threshold</code> has been set, return true if the threshold was met, else false.
         * If no threshold was set, then we return true.
         * @inner
         */
        function validateSwipeDistance() {
            var valid = !0;
            //If we made it past the min swipe distance..
            return null !== options.threshold && (valid = distance >= options.threshold), valid;
        }
        /**
         * Checks the user has swiped back to cancel.
         * @return Boolean if <code>cancelThreshold</code> has been set, return true if the cancelThreshold was met, else false.
         * If no cancelThreshold was set, then we return true.
         * @inner
         */
        function didSwipeBackToCancel() {
            var cancelled = !1;
            return null !== options.cancelThreshold && null !== direction && (cancelled = getMaxDistance(direction) - distance >= options.cancelThreshold), 
            cancelled;
        }
        /**
         * Checks the user has pinched far enough
         * @return Boolean if <code>pinchThreshold</code> has been set, return true if the threshold was met, else false.
         * If no threshold was set, then we return true.
         * @inner
         */
        function validatePinchDistance() {
            return null !== options.pinchThreshold ? pinchDistance >= options.pinchThreshold : !0;
        }
        /**
         * Checks that the time taken to swipe meets the minimum / maximum requirements
         * @return Boolean
         * @inner
         */
        function validateSwipeTime() {
            var result;
            //If no time set, then return true
            return result = options.maxTimeThreshold && duration >= options.maxTimeThreshold ? !1 : !0;
        }
        /**
         * Checks direction of the swipe and the value allowPageScroll to see if we should allow or prevent the default behaviour from occurring.
         * This will essentially allow page scrolling or not when the user is swiping on a touchSwipe object.
         * @param {object} jqEvent The normalised jQuery representation of the event object.
         * @param {string} direction The direction of the event. See {@link $.fn.swipe.directions}
         * @see $.fn.swipe.directions
         * @inner
         */
        function validateDefaultEvent(jqEvent, direction) {
            if (options.allowPageScroll === NONE || hasPinches()) jqEvent.preventDefault(); else {
                var auto = options.allowPageScroll === AUTO;
                switch (direction) {
                  case LEFT:
                    (options.swipeLeft && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
                    break;

                  case RIGHT:
                    (options.swipeRight && auto || !auto && options.allowPageScroll != HORIZONTAL) && jqEvent.preventDefault();
                    break;

                  case UP:
                    (options.swipeUp && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
                    break;

                  case DOWN:
                    (options.swipeDown && auto || !auto && options.allowPageScroll != VERTICAL) && jqEvent.preventDefault();
                }
            }
        }
        // PINCHES
        /**
         * Returns true of the current pinch meets the thresholds
         * @return Boolean
         * @inner
         */
        function validatePinch() {
            var hasCorrectFingerCount = validateFingers(), hasEndPoint = validateEndPoint(), hasCorrectDistance = validatePinchDistance();
            return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;
        }
        /**
         * Returns true if any Pinch events have been registered
         * @return Boolean
         * @inner
         */
        function hasPinches() {
            //Enure we dont return 0 or null for false values
            return !!(options.pinchStatus || options.pinchIn || options.pinchOut);
        }
        /**
         * Returns true if we are detecting pinches, and have one
         * @return Boolean
         * @inner
         */
        function didPinch() {
            //Enure we dont return 0 or null for false values
            return !(!validatePinch() || !hasPinches());
        }
        // SWIPES
        /**
         * Returns true if the current swipe meets the thresholds
         * @return Boolean
         * @inner
         */
        function validateSwipe() {
            //Check validity of swipe
            var hasValidTime = validateSwipeTime(), hasValidDistance = validateSwipeDistance(), hasCorrectFingerCount = validateFingers(), hasEndPoint = validateEndPoint(), didCancel = didSwipeBackToCancel(), valid = !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;
            return valid;
        }
        /**
         * Returns true if any Swipe events have been registered
         * @return Boolean
         * @inner
         */
        function hasSwipes() {
            //Enure we dont return 0 or null for false values
            return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown);
        }
        /**
         * Returns true if we are detecting swipes and have one
         * @return Boolean
         * @inner
         */
        function didSwipe() {
            //Enure we dont return 0 or null for false values
            return !(!validateSwipe() || !hasSwipes());
        }
        /**
         * Returns true if we have matched the number of fingers we are looking for
         * @return Boolean
         * @inner
         */
        function validateFingers() {
            //The number of fingers we want were matched, or on desktop we ignore
            return fingerCount === options.fingers || options.fingers === ALL_FINGERS || !SUPPORTS_TOUCH;
        }
        /**
         * Returns true if we have an end point for the swipe
         * @return Boolean
         * @inner
         */
        function validateEndPoint() {
            //We have an end value for the finger
            return 0 !== fingerData[0].end.x;
        }
        // TAP / CLICK
        /**
         * Returns true if a click / tap events have been registered
         * @return Boolean
         * @inner
         */
        function hasTap() {
            //Enure we dont return 0 or null for false values
            return !!options.tap;
        }
        /**
         * Returns true if a double tap events have been registered
         * @return Boolean
         * @inner
         */
        function hasDoubleTap() {
            //Enure we dont return 0 or null for false values
            return !!options.doubleTap;
        }
        /**
         * Returns true if any long tap events have been registered
         * @return Boolean
         * @inner
         */
        function hasLongTap() {
            //Enure we dont return 0 or null for false values
            return !!options.longTap;
        }
        /**
         * Returns true if we could be in the process of a double tap (one tap has occurred, we are listening for double taps, and the threshold hasn't past.
         * @return Boolean
         * @inner
         */
        function validateDoubleTap() {
            if (null == doubleTapStartTime) return !1;
            var now = getTimeStamp();
            return hasDoubleTap() && now - doubleTapStartTime <= options.doubleTapThreshold;
        }
        /**
         * Returns true if we could be in the process of a double tap (one tap has occurred, we are listening for double taps, and the threshold hasn't past.
         * @return Boolean
         * @inner
         */
        function inDoubleTap() {
            return validateDoubleTap();
        }
        /**
         * Returns true if we have a valid tap
         * @return Boolean
         * @inner
         */
        function validateTap() {
            return !(1 !== fingerCount && SUPPORTS_TOUCH || !isNaN(distance) && 0 !== distance);
        }
        /**
         * Returns true if we have a valid long tap
         * @return Boolean
         * @inner
         */
        function validateLongTap() {
            //slight threshold on moving finger
            return duration > options.longTapThreshold && DOUBLE_TAP_THRESHOLD > distance;
        }
        /**
         * Returns true if we are detecting taps and have one
         * @return Boolean
         * @inner
         */
        function didTap() {
            //Enure we dont return 0 or null for false values
            return !(!validateTap() || !hasTap());
        }
        /**
         * Returns true if we are detecting double taps and have one
         * @return Boolean
         * @inner
         */
        function didDoubleTap() {
            //Enure we dont return 0 or null for false values
            return !(!validateDoubleTap() || !hasDoubleTap());
        }
        /**
         * Returns true if we are detecting long taps and have one
         * @return Boolean
         * @inner
         */
        function didLongTap() {
            //Enure we dont return 0 or null for false values
            return !(!validateLongTap() || !hasLongTap());
        }
        // MULTI FINGER TOUCH
        /**
         * Starts tracking the time between 2 finger releases, and keeps track of how many fingers we initially had up
         * @inner
         */
        function startMultiFingerRelease() {
            previousTouchEndTime = getTimeStamp(), previousTouchFingerCount = event.touches.length + 1;
        }
        /**
         * Cancels the tracking of time between 2 finger releases, and resets counters
         * @inner
         */
        function cancelMultiFingerRelease() {
            previousTouchEndTime = 0, previousTouchFingerCount = 0;
        }
        /**
         * Checks if we are in the threshold between 2 fingers being released
         * @return Boolean
         * @inner
         */
        function inMultiFingerRelease() {
            var withinThreshold = !1;
            if (previousTouchEndTime) {
                var diff = getTimeStamp() - previousTouchEndTime;
                diff <= options.fingerReleaseThreshold && (withinThreshold = !0);
            }
            return withinThreshold;
        }
        /**
         * gets a data flag to indicate that a touch is in progress
         * @return Boolean
         * @inner
         */
        function getTouchInProgress() {
            //strict equality to ensure only true and false are returned
            return !($element.data(PLUGIN_NS + "_intouch") !== !0);
        }
        /**
         * Sets a data flag to indicate that a touch is in progress
         * @param {boolean} val The value to set the property to
         * @inner
         */
        function setTouchInProgress(val) {
            //Add or remove event listeners depending on touch status
            val === !0 ? ($element.bind(MOVE_EV, touchMove), $element.bind(END_EV, touchEnd), 
            //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
            LEAVE_EV && $element.bind(LEAVE_EV, touchLeave)) : ($element.unbind(MOVE_EV, touchMove, !1), 
            $element.unbind(END_EV, touchEnd, !1), //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
            LEAVE_EV && $element.unbind(LEAVE_EV, touchLeave, !1)), //strict equality to ensure only true and false can update the value
            $element.data(PLUGIN_NS + "_intouch", val === !0);
        }
        /**
         * Creates the finger data for the touch/finger in the event object.
         * @param {int} index The index in the array to store the finger data (usually the order the fingers were pressed)
         * @param {object} evt The event object containing finger data
         * @return finger data object
         * @inner
         */
        function createFingerData(index, evt) {
            var id = void 0 !== evt.identifier ? evt.identifier : 0;
            return fingerData[index].identifier = id, fingerData[index].start.x = fingerData[index].end.x = evt.pageX || evt.clientX, 
            fingerData[index].start.y = fingerData[index].end.y = evt.pageY || evt.clientY, 
            fingerData[index];
        }
        /**
         * Updates the finger data for a particular event object
         * @param {object} evt The event object containing the touch/finger data to upadte
         * @return a finger data object.
         * @inner
         */
        function updateFingerData(evt) {
            var id = void 0 !== evt.identifier ? evt.identifier : 0, f = getFingerData(id);
            return f.end.x = evt.pageX || evt.clientX, f.end.y = evt.pageY || evt.clientY, f;
        }
        /**
         * Returns a finger data object by its event ID.
         * Each touch event has an identifier property, which is used
         * to track repeat touches
         * @param {int} id The unique id of the finger in the sequence of touch events.
         * @return a finger data object.
         * @inner
         */
        function getFingerData(id) {
            for (var i = 0; i < fingerData.length; i++) if (fingerData[i].identifier == id) return fingerData[i];
        }
        /**
         * Creats all the finger onjects and returns an array of finger data
         * @return Array of finger objects
         * @inner
         */
        function createAllFingerData() {
            for (var fingerData = [], i = 0; 5 >= i; i++) fingerData.push({
                start: {
                    x: 0,
                    y: 0
                },
                end: {
                    x: 0,
                    y: 0
                },
                identifier: 0
            });
            return fingerData;
        }
        /**
         * Sets the maximum distance swiped in the given direction.
         * If the new value is lower than the current value, the max value is not changed.
         * @param {string}  direction The direction of the swipe
         * @param {int}  distance The distance of the swipe
         * @inner
         */
        function setMaxDistance(direction, distance) {
            distance = Math.max(distance, getMaxDistance(direction)), maximumsMap[direction].distance = distance;
        }
        /**
         * gets the maximum distance swiped in the given direction.
         * @param {string}  direction The direction of the swipe
         * @return int  The distance of the swipe
         * @inner
         */
        function getMaxDistance(direction) {
            return maximumsMap[direction] ? maximumsMap[direction].distance : void 0;
        }
        /**
         * Creats a map of directions to maximum swiped values.
         * @return Object A dictionary of maximum values, indexed by direction.
         * @inner
         */
        function createMaximumsData() {
            var maxData = {};
            return maxData[LEFT] = createMaximumVO(LEFT), maxData[RIGHT] = createMaximumVO(RIGHT), 
            maxData[UP] = createMaximumVO(UP), maxData[DOWN] = createMaximumVO(DOWN), maxData;
        }
        /**
         * Creates a map maximum swiped values for a given swipe direction
         * @param {string} The direction that these values will be associated with
         * @return Object Maximum values
         * @inner
         */
        function createMaximumVO(dir) {
            return {
                direction: dir,
                distance: 0
            };
        }
        //
        // MATHS / UTILS
        //
        /**
         * Calculate the duration of the swipe
         * @return int
         * @inner
         */
        function calculateDuration() {
            return endTime - startTime;
        }
        /**
         * Calculate the distance between 2 touches (pinch)
         * @param {point} startPoint A point object containing x and y co-ordinates
         * @param {point} endPoint A point object containing x and y co-ordinates
         * @return int;
         * @inner
         */
        function calculateTouchesDistance(startPoint, endPoint) {
            var diffX = Math.abs(startPoint.x - endPoint.x), diffY = Math.abs(startPoint.y - endPoint.y);
            return Math.round(Math.sqrt(diffX * diffX + diffY * diffY));
        }
        /**
         * Calculate the zoom factor between the start and end distances
         * @param {int} startDistance Distance (between 2 fingers) the user started pinching at
         * @param {int} endDistance Distance (between 2 fingers) the user ended pinching at
         * @return float The zoom value from 0 to 1.
         * @inner
         */
        function calculatePinchZoom(startDistance, endDistance) {
            var percent = endDistance / startDistance * 1;
            return percent.toFixed(2);
        }
        /**
         * Returns the pinch direction, either IN or OUT for the given points
         * @return string Either {@link $.fn.swipe.directions.IN} or {@link $.fn.swipe.directions.OUT}
         * @see $.fn.swipe.directions
         * @inner
         */
        function calculatePinchDirection() {
            return 1 > pinchZoom ? OUT : IN;
        }
        /**
         * Calculate the length / distance of the swipe
         * @param {point} startPoint A point object containing x and y co-ordinates
         * @param {point} endPoint A point object containing x and y co-ordinates
         * @return int
         * @inner
         */
        function calculateDistance(startPoint, endPoint) {
            return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
        }
        /**
         * Calculate the angle of the swipe
         * @param {point} startPoint A point object containing x and y co-ordinates
         * @param {point} endPoint A point object containing x and y co-ordinates
         * @return int
         * @inner
         */
        function calculateAngle(startPoint, endPoint) {
            var x = startPoint.x - endPoint.x, y = endPoint.y - startPoint.y, r = Math.atan2(y, x), angle = Math.round(180 * r / Math.PI);
            //degrees
            //ensure value is positive
            return 0 > angle && (angle = 360 - Math.abs(angle)), angle;
        }
        /**
         * Calculate the direction of the swipe
         * This will also call calculateAngle to get the latest angle of swipe
         * @param {point} startPoint A point object containing x and y co-ordinates
         * @param {point} endPoint A point object containing x and y co-ordinates
         * @return string Either {@link $.fn.swipe.directions.LEFT} / {@link $.fn.swipe.directions.RIGHT} / {@link $.fn.swipe.directions.DOWN} / {@link $.fn.swipe.directions.UP}
         * @see $.fn.swipe.directions
         * @inner
         */
        function calculateDirection(startPoint, endPoint) {
            var angle = calculateAngle(startPoint, endPoint);
            return 45 >= angle && angle >= 0 ? LEFT : 360 >= angle && angle >= 315 ? LEFT : angle >= 135 && 225 >= angle ? RIGHT : angle > 45 && 135 > angle ? DOWN : UP;
        }
        /**
         * Returns a MS time stamp of the current time
         * @return int
         * @inner
         */
        function getTimeStamp() {
            var now = new Date();
            return now.getTime();
        }
        /**
         * Returns a bounds object with left, right, top and bottom properties for the element specified.
         * @param {DomNode} The DOM node to get the bounds for.
         */
        function getbounds(el) {
            el = $(el);
            var offset = el.offset(), bounds = {
                left: offset.left,
                right: offset.left + el.outerWidth(),
                top: offset.top,
                bottom: offset.top + el.outerHeight()
            };
            return bounds;
        }
        /**
         * Checks if the point object is in the bounds object.
         * @param {object} point A point object.
         * @param {int} point.x The x value of the point.
         * @param {int} point.y The x value of the point.
         * @param {object} bounds The bounds object to test
         * @param {int} bounds.left The leftmost value
         * @param {int} bounds.right The righttmost value
         * @param {int} bounds.top The topmost value
         * @param {int} bounds.bottom The bottommost value
         */
        function isInBounds(point, bounds) {
            return point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom;
        }
        var useTouchEvents = SUPPORTS_TOUCH || !options.fallbackToMouseEvents, START_EV = useTouchEvents ? "touchstart" : "mousedown", MOVE_EV = useTouchEvents ? "touchmove" : "mousemove", END_EV = useTouchEvents ? "touchend" : "mouseup", LEAVE_EV = useTouchEvents ? null : "mouseleave", //we manually detect leave on touch devices, so null event here
        CANCEL_EV = "touchcancel", distance = 0, direction = null, duration = 0, startTouchesDistance = 0, endTouchesDistance = 0, pinchZoom = 1, pinchDistance = 0, pinchDirection = 0, maximumsMap = null, $element = $(element), phase = "start", fingerCount = 0, fingerData = null, startTime = 0, endTime = 0, previousTouchEndTime = 0, previousTouchFingerCount = 0, doubleTapStartTime = 0, singleTapTimeout = null;
        // Add gestures to all swipable areas if supported
        try {
            $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel);
        } catch (e) {
            $.error("events not supported " + START_EV + "," + CANCEL_EV + " on jQuery.swipe");
        }
        //
        //Public methods
        //
        /**
         * re-enables the swipe plugin with the previous configuration
         * @function
         * @name $.fn.swipe#enable
         * @return {DOMNode} The Dom element that was registered with TouchSwipe
         * @example $("#element").swipe("enable");
         */
        this.enable = function() {
            return $element.bind(START_EV, touchStart), $element.bind(CANCEL_EV, touchCancel), 
            $element;
        }, /**
         * disables the swipe plugin
         * @function
         * @name $.fn.swipe#disable
         * @return {DOMNode} The Dom element that is now registered with TouchSwipe
         * @example $("#element").swipe("disable");
         */
        this.disable = function() {
            return removeListeners(), $element;
        }, /**
         * Destroy the swipe plugin completely. To use any swipe methods, you must re initialise the plugin.
         * @function
         * @name $.fn.swipe#destroy
         * @return {DOMNode} The Dom element that was registered with TouchSwipe
         * @example $("#element").swipe("destroy");
         */
        this.destroy = function() {
            return removeListeners(), $element.data(PLUGIN_NS, null), $element;
        }, /**
         * Allows run time updating of the swipe configuration options.
         * @function
         * @name $.fn.swipe#option
         * @param {String} property The option property to get or set
         * @param {Object} [value] The value to set the property to
         * @return {Object} If only a property name is passed, then that property value is returned.
         * @example $("#element").swipe("option", "threshold"); // return the threshold
         * @example $("#element").swipe("option", "threshold", 100); // set the threshold after init
         * @see $.fn.swipe.defaults
         *
         */
        this.option = function(property, value) {
            if (void 0 !== options[property]) {
                if (void 0 === value) return options[property];
                options[property] = value;
            } else $.error("Option " + property + " does not exist on jQuery.swipe.options");
            return null;
        };
    }
    //Constants
    var LEFT = "left", RIGHT = "right", UP = "up", DOWN = "down", IN = "in", OUT = "out", NONE = "none", AUTO = "auto", SWIPE = "swipe", PINCH = "pinch", TAP = "tap", DOUBLE_TAP = "doubletap", LONG_TAP = "longtap", HORIZONTAL = "horizontal", VERTICAL = "vertical", ALL_FINGERS = "all", DOUBLE_TAP_THRESHOLD = 10, PHASE_START = "start", PHASE_MOVE = "move", PHASE_END = "end", PHASE_CANCEL = "cancel", SUPPORTS_TOUCH = "ontouchstart" in window, PLUGIN_NS = "TouchSwipe", defaults = {
        fingers: 1,
        threshold: 75,
        cancelThreshold: null,
        pinchThreshold: 20,
        maxTimeThreshold: null,
        fingerReleaseThreshold: 250,
        longTapThreshold: 500,
        doubleTapThreshold: 200,
        swipe: null,
        swipeLeft: null,
        swipeRight: null,
        swipeUp: null,
        swipeDown: null,
        swipeStatus: null,
        pinchIn: null,
        pinchOut: null,
        pinchStatus: null,
        click: null,
        //Deprecated since 1.6.2
        tap: null,
        doubleTap: null,
        longTap: null,
        triggerOnTouchEnd: !0,
        triggerOnTouchLeave: !1,
        allowPageScroll: "auto",
        fallbackToMouseEvents: !0,
        excludedElements: "label, button, input, select, textarea, a, .noSwipe"
    };
    /**
     * Applies TouchSwipe behaviour to one or more jQuery objects.
     * The TouchSwipe plugin can be instantiated via this method, or methods within
     * TouchSwipe can be executed via this method as per jQuery plugin architecture.
     * @see TouchSwipe
     * @class
     * @param {Mixed} method If the current DOMNode is a TouchSwipe object, and <code>method</code> is a TouchSwipe method, then
     * the <code>method</code> is executed, and any following arguments are passed to the TouchSwipe method.
     * If <code>method</code> is an object, then the TouchSwipe class is instantiated on the current DOMNode, passing the
     * configuration properties defined in the object. See TouchSwipe
     *
     */
    $.fn.swipe = function(method) {
        var $this = $(this), plugin = $this.data(PLUGIN_NS);
        //Check if we are already instantiated and trying to execute a method
        if (plugin && "string" == typeof method) {
            if (plugin[method]) return plugin[method].apply(this, Array.prototype.slice.call(arguments, 1));
            $.error("Method " + method + " does not exist on jQuery.swipe");
        } else if (!(plugin || "object" != typeof method && method)) return init.apply(this, arguments);
        return $this;
    }, //Expose our defaults so a user could override the plugin defaults
    $.fn.swipe.defaults = defaults, /**
     * The phases that a touch event goes through.  The <code>phase</code> is passed to the event handlers.
     * These properties are read only, attempting to change them will not alter the values passed to the event handlers.
     * @namespace
     * @readonly
     * @property {string} PHASE_START Constant indicating the start phase of the touch event. Value is <code>"start"</code>.
     * @property {string} PHASE_MOVE Constant indicating the move phase of the touch event. Value is <code>"move"</code>.
     * @property {string} PHASE_END Constant indicating the end phase of the touch event. Value is <code>"end"</code>.
     * @property {string} PHASE_CANCEL Constant indicating the cancel phase of the touch event. Value is <code>"cancel"</code>.
     */
    $.fn.swipe.phases = {
        PHASE_START: PHASE_START,
        PHASE_MOVE: PHASE_MOVE,
        PHASE_END: PHASE_END,
        PHASE_CANCEL: PHASE_CANCEL
    }, /**
     * The direction constants that are passed to the event handlers.
     * These properties are read only, attempting to change them will not alter the values passed to the event handlers.
     * @namespace
     * @readonly
     * @property {string} LEFT Constant indicating the left direction. Value is <code>"left"</code>.
     * @property {string} RIGHT Constant indicating the right direction. Value is <code>"right"</code>.
     * @property {string} UP Constant indicating the up direction. Value is <code>"up"</code>.
     * @property {string} DOWN Constant indicating the down direction. Value is <code>"cancel"</code>.
     * @property {string} IN Constant indicating the in direction. Value is <code>"in"</code>.
     * @property {string} OUT Constant indicating the out direction. Value is <code>"out"</code>.
     */
    $.fn.swipe.directions = {
        LEFT: LEFT,
        RIGHT: RIGHT,
        UP: UP,
        DOWN: DOWN,
        IN: IN,
        OUT: OUT
    }, /**
     * The page scroll constants that can be used to set the value of <code>allowPageScroll</code> option
     * These properties are read only
     * @namespace
     * @readonly
     * @see $.fn.swipe.defaults#allowPageScroll
     * @property {string} NONE Constant indicating no page scrolling is allowed. Value is <code>"none"</code>.
     * @property {string} HORIZONTAL Constant indicating horizontal page scrolling is allowed. Value is <code>"horizontal"</code>.
     * @property {string} VERTICAL Constant indicating vertical page scrolling is allowed. Value is <code>"vertical"</code>.
     * @property {string} AUTO Constant indicating either horizontal or vertical will be allowed, depending on the swipe handlers registered. Value is <code>"auto"</code>.
     */
    $.fn.swipe.pageScroll = {
        NONE: NONE,
        HORIZONTAL: HORIZONTAL,
        VERTICAL: VERTICAL,
        AUTO: AUTO
    }, /**
     * Constants representing the number of fingers used in a swipe.  These are used to set both the value of <code>fingers</code> in the
     * options object, as well as the value of the <code>fingers</code> event property.
     * These properties are read only, attempting to change them will not alter the values passed to the event handlers.
     * @namespace
     * @readonly
     * @see $.fn.swipe.defaults#fingers
     * @property {string} ONE Constant indicating 1 finger is to be detected / was detected. Value is <code>1</code>.
     * @property {string} TWO Constant indicating 2 fingers are to be detected / were detected. Value is <code>1</code>.
     * @property {string} THREE Constant indicating 3 finger are to be detected / were detected. Value is <code>1</code>.
     * @property {string} ALL Constant indicating any combination of finger are to be detected.  Value is <code>"all"</code>.
     */
    $.fn.swipe.fingers = {
        ONE: 1,
        TWO: 2,
        THREE: 3,
        ALL: ALL_FINGERS
    };
}), /**
 * Really Simple Color Picker in jQuery
 *
 * Licensed under the MIT (MIT-LICENSE.txt) licenses.
 *
 * Copyright (c) 2008-2012
 * Lakshan Perera (www.laktek.com) & Daniel Lacy (daniellacy.com)
 *
 * Modified by James Ford to include auto-repositioning of the palette panel
 * when overflowing the page edges.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
function($) {
    "use strict";
    /**
     * Create a couple private variables.
     **/
    var selectorOwner, activePalette, lastColor, cItterate = 0, templates = {
        control: $('<div class="colorPicker-picker">&nbsp;</div>'),
        palette: $('<div id="colorPicker_palette" class="colorPicker-palette" />'),
        swatch: $('<div class="colorPicker-swatch">&nbsp;</div>'),
        hexLabel: $('<label for="colorPicker_hex">Hex</label>'),
        hexField: $('<input type="text" id="colorPicker_hex" />')
    }, transparent = "transparent";
    /**
     * Create our colorPicker function
     **/
    $.fn.colorPicker = function(options) {
        return this.each(function() {
            // Setup time. Clone new elements from our templates, set some IDs, make shortcuts, jazzercise.
            var swatch, element = $(this), opts = $.extend({}, $.fn.colorPicker.defaults, options), defaultColor = $.fn.colorPicker.toHex(element.val().length > 0 ? element.val() : opts.pickerDefault), newControl = templates.control.clone(), newPalette = templates.palette.clone().attr("id", "colorPicker_palette-" + cItterate), newHexLabel = templates.hexLabel.clone(), newHexField = templates.hexField.clone(), paletteId = newPalette[0].id;
            /**
             * Build a color palette.
             **/
            $.each(opts.colors, function(i) {
                swatch = templates.swatch.clone(), opts.colors[i] === transparent ? (swatch.addClass(transparent).text("X"), 
                $.fn.colorPicker.bindPalette(newHexField, swatch, transparent)) : (swatch.css("background-color", "#" + this), 
                $.fn.colorPicker.bindPalette(newHexField, swatch)), swatch.appendTo(newPalette);
            }), newHexLabel.attr("for", "colorPicker_hex-" + cItterate), newHexField.attr({
                id: "colorPicker_hex-" + cItterate,
                value: defaultColor
            }), newHexField.bind("keydown", function(event) {
                if (13 === event.keyCode) {
                    var hexColor = $.fn.colorPicker.toHex($(this).val());
                    $.fn.colorPicker.changeColor(hexColor ? hexColor : element.val());
                }
                27 === event.keyCode && $.fn.colorPicker.hidePalette();
            }), newHexField.bind("keyup", function(event) {
                var hexColor = $.fn.colorPicker.toHex($(event.target).val());
                $.fn.colorPicker.previewColor(hexColor ? hexColor : element.val());
            }), $('<div class="colorPicker_hexWrap" />').append(newHexLabel).appendTo(newPalette), 
            newPalette.find(".colorPicker_hexWrap").append(newHexField), $("body").append(newPalette), 
            newPalette.hide(), /**
             * Build replacement interface for original color input.
             **/
            newControl.css("background-color", defaultColor), newControl.bind("click", function() {
                $(this).toggleClass("active"), $.fn.colorPicker.togglePalette($("#" + paletteId), $(this));
            }), options && options.onColorChange ? newControl.data("onColorChange", options.onColorChange) : newControl.data("onColorChange", function() {}), 
            element.after(newControl), element.bind("change", function() {
                element.next(".colorPicker-picker").css("background-color", $.fn.colorPicker.toHex($(this).val()));
            }), // Hide the original input.
            element.val(defaultColor).hide(), cItterate++;
        });
    }, /**
     * Extend colorPicker with... all our functionality.
     **/
    $.extend(!0, $.fn.colorPicker, {
        /**
         * Return a Hex color, convert an RGB value and return Hex, or return false.
         *
         * Inspired by http://code.google.com/p/jquery-color-utils
         **/
        toHex: function(color) {
            // If we have a standard or shorthand Hex color, return that value.
            if (color.match(/[0-9A-F]{6}|[0-9A-F]{3}$/i)) return "#" === color.charAt(0) ? color : "#" + color;
            if (!color.match(/^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/)) return !1;
            var c = [ parseInt(RegExp.$1, 10), parseInt(RegExp.$2, 10), parseInt(RegExp.$3, 10) ], pad = function(str) {
                if (str.length < 2) for (var i = 0, len = 2 - str.length; len > i; i++) str = "0" + str;
                return str;
            };
            if (3 === c.length) {
                var r = pad(c[0].toString(16)), g = pad(c[1].toString(16)), b = pad(c[2].toString(16));
                return "#" + r + g + b;
            }
        },
        /**
         * Check whether user clicked on the selector or owner.
         **/
        checkMouse: function(event) {
            var selector = activePalette, selectorParent = $(event.target).parents("#" + selector.attr("id")).length;
            event.target === $(selector)[0] || event.target === selectorOwner[0] || selectorParent > 0 || $.fn.colorPicker.hidePalette();
        },
        /**
         * Hide the color palette modal.
         **/
        hidePalette: function() {
            $(document).unbind("mousedown", $.fn.colorPicker.checkMouse), $(".colorPicker-picker").removeClass("active"), 
            $(".colorPicker-palette").hide();
        },
        /**
         * Show the color palette modal.
         **/
        showPalette: function(palette) {
            var hexColor = selectorOwner.prev("input").val(), offset = selectorOwner.offset(), pHeight = palette.height(), pWidth = palette.width(), targetTop = offset.top + selectorOwner.outerHeight() + 4, targetLeft = offset.left - 4;
            targetTop + pHeight > $(window).height() && (targetTop = offset.top - pHeight - 10), 
            targetLeft + pWidth > $(window).width() && (targetLeft = offset.left + selectorOwner.outerWidth() - pWidth), 
            palette.css({
                top: targetTop,
                left: targetLeft
            }), $("#color_value").val(hexColor), palette.show(), $(document).bind("mousedown", $.fn.colorPicker.checkMouse), 
            $(palette).find(".colorPicker-picker").addClass("active");
        },
        /**
         * Toggle visibility of the colorPicker palette.
         **/
        togglePalette: function(palette, origin) {
            // selectorOwner is the clicked .colorPicker-picker.
            origin && (selectorOwner = origin), activePalette = palette, activePalette.is(":visible") ? $.fn.colorPicker.hidePalette() : $.fn.colorPicker.showPalette(palette);
        },
        /**
         * Update the input with a newly selected color.
         **/
        changeColor: function(value) {
            selectorOwner.css("background-color", value), selectorOwner.prev("input").val(value).change(), 
            $.fn.colorPicker.hidePalette(), selectorOwner.data("onColorChange").call(selectorOwner, $(selectorOwner).prev("input").attr("id"), value);
        },
        /**
         * Preview the input with a newly selected color.
         **/
        previewColor: function(value) {
            selectorOwner.css("background-color", value);
        },
        /**
         * Bind events to the color palette swatches.
         */
        bindPalette: function(paletteInput, element, color) {
            color = color ? color : $.fn.colorPicker.toHex(element.css("background-color")), 
            element.bind({
                click: function() {
                    lastColor = color, $.fn.colorPicker.changeColor(color);
                },
                mouseover: function() {
                    lastColor = paletteInput.val(), $(this).css("border-color", "#598FEF"), paletteInput.val(color), 
                    $.fn.colorPicker.previewColor(color);
                },
                mouseout: function() {
                    $(this).css("border-color", "#000"), paletteInput.val(selectorOwner.css("background-color")), 
                    paletteInput.val(lastColor), $.fn.colorPicker.previewColor(lastColor);
                }
            });
        }
    }), /**
     * Default colorPicker options.
     *
     * These are publibly available for global modification using a setting such as:
     *
     * $.fn.colorPicker.defaults.colors = ['151337', '111111']
     *
     * They can also be applied on a per-bound element basis like so:
     *
     * $('#element1').colorPicker({pickerDefault: 'efefef', transparency: true});
     * $('#element2').colorPicker({pickerDefault: '333333', colors: ['333333', '111111']});
     *
     **/
    $.fn.colorPicker.defaults = {
        // colorPicker default selected color.
        pickerDefault: "FFFFFF",
        // Default color set.
        colors: [ "000000", "993300", "333300", "000080", "333399", "333333", "800000", "FF6600", "808000", "008000", "008080", "0000FF", "666699", "808080", "FF0000", "FF9900", "99CC00", "339966", "33CCCC", "3366FF", "800080", "999999", "FF00FF", "FFCC00", "FFFF00", "00FF00", "00FFFF", "00CCFF", "993366", "C0C0C0", "FF99CC", "FFCC99", "FFFF99", "CCFFFF", "99CCFF", "FFFFFF" ],
        // If we want to simply add more colors to the default set, use addColors.
        addColors: []
    };
}(jQuery), /* ===========================================================
 * bootstrap-tooltip.js v2.0.3
 * http://twitter.github.com/bootstrap/javascript.html#tooltips
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================== */
/**
 * @fileoverview
 * @suppress {checkVars|uselessCode}
 */
!function($) {
    "use strict";
    // jshint ;_;
    /* TOOLTIP PUBLIC CLASS DEFINITION
     * =============================== */
    var Tooltip = function(element, options) {
        this.init("tooltip", element, options);
    };
    Tooltip.prototype = {
        constructor: Tooltip,
        init: function(type, element, options) {
            var eventIn, eventOut;
            this.type = type, this.$element = $(element), this.options = this.getOptions(options), 
            this.enabled = !0, "manual" != this.options.trigger && (eventIn = "hover" == this.options.trigger ? "mouseenter" : "focus", 
            eventOut = "hover" == this.options.trigger ? "mouseleave" : "blur", this.$element.on(eventIn, this.options.selector, $.proxy(this.enter, this)), 
            this.$element.on(eventOut, this.options.selector, $.proxy(this.leave, this))), this.options.selector ? this._options = $.extend({}, this.options, {
                trigger: "manual",
                selector: ""
            }) : this.fixTitle();
        },
        getOptions: function(options) {
            return options = $.extend({}, $.fn[this.type].defaults, options, this.$element.data()), 
            options.delay && "number" == typeof options.delay && (options.delay = {
                show: options.delay,
                hide: options.delay
            }), options;
        },
        enter: function(e) {
            var self = $(e.currentTarget)[this.type](this._options).data(this.type);
            return self.options.delay && self.options.delay.show ? (clearTimeout(this.timeout), 
            self.hoverState = "in", void (this.timeout = setTimeout(function() {
                "in" == self.hoverState && self.show();
            }, self.options.delay.show))) : self.show();
        },
        leave: function(e) {
            var self = $(e.currentTarget)[this.type](this._options).data(this.type);
            return self.options.delay && self.options.delay.hide ? (clearTimeout(this.timeout), 
            self.hoverState = "out", void (this.timeout = setTimeout(function() {
                "out" == self.hoverState && self.hide();
            }, self.options.delay.hide))) : self.hide();
        },
        show: function() {
            var $tip, inside, pos, actualWidth, actualHeight, placement, tp;
            if (this.hasContent() && this.enabled) {
                switch ($tip = this.tip(), this.setContent(), this.options.animation && $tip.addClass("fade"), 
                placement = "function" == typeof this.options.placement ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement, 
                inside = /in/.test(placement), $tip.remove().css({
                    top: 0,
                    left: 0,
                    display: "block"
                }).appendTo(inside ? this.$element : document.body), pos = this.getPosition(inside), 
                actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight, inside ? placement.split(" ")[1] : placement) {
                  case "bottom":
                    tp = {
                        top: pos.top + pos.height,
                        left: pos.left + pos.width / 2 - actualWidth / 2
                    };
                    break;

                  case "top":
                    tp = {
                        top: pos.top - actualHeight,
                        left: pos.left + pos.width / 2 - actualWidth / 2
                    };
                    break;

                  case "left":
                    tp = {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left - actualWidth
                    };
                    break;

                  case "right":
                    tp = {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left + pos.width
                    };
                }
                $tip.css(tp).addClass(placement).addClass("in");
            }
        },
        isHTML: function(text) {
            // html string detection logic adapted from jQuery
            return "string" != typeof text || "<" === text.charAt(0) && ">" === text.charAt(text.length - 1) && text.length >= 3 || /^(?:[^<]*<[\w\W]+>[^>]*$)/.exec(text);
        },
        setContent: function() {
            var $tip = this.tip(), title = this.getTitle();
            $tip.find(".tooltip-inner")[this.isHTML(title) ? "html" : "text"](title), $tip.removeClass("fade in top bottom left right");
        },
        hide: function() {
            function removeWithAnimation() {
                var timeout = setTimeout(function() {
                    $tip.off($.support.transition.end).remove();
                }, 500);
                $tip.one($.support.transition.end, function() {
                    clearTimeout(timeout), $tip.remove();
                });
            }
            var $tip = this.tip();
            $tip.removeClass("in"), $.support.transition && this.$tip.hasClass("fade") ? removeWithAnimation() : $tip.remove();
        },
        fixTitle: function() {
            var $e = this.$element;
            ($e.attr("title") || "string" != typeof $e.attr("data-original-title")) && $e.attr("data-original-title", $e.attr("title") || "").removeAttr("title");
        },
        hasContent: function() {
            return this.getTitle();
        },
        getPosition: function(inside) {
            return $.extend({}, inside ? {
                top: 0,
                left: 0
            } : this.$element.offset(), {
                width: this.$element[0].offsetWidth,
                height: this.$element[0].offsetHeight
            });
        },
        getTitle: function() {
            var title, $e = this.$element, o = this.options;
            return title = $e.attr("data-original-title") || ("function" == typeof o.title ? o.title.call($e[0]) : o.title);
        },
        tip: function() {
            return this.$tip = this.$tip || $(this.options.template);
        },
        validate: function() {
            this.$element[0].parentNode || (this.hide(), this.$element = null, this.options = null);
        },
        enable: function() {
            this.enabled = !0;
        },
        disable: function() {
            this.enabled = !1;
        },
        toggleEnabled: function() {
            this.enabled = !this.enabled;
        },
        toggle: function() {
            this[this.tip().hasClass("in") ? "hide" : "show"]();
        }
    }, /* TOOLTIP PLUGIN DEFINITION
     * ========================= */
    $.fn.tooltip = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("tooltip"), options = "object" == typeof option && option;
            data || $this.data("tooltip", data = new Tooltip(this, options)), "string" == typeof option && data[option]();
        });
    }, $.fn.tooltip.Constructor = Tooltip, $.fn.tooltip.defaults = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover",
        title: "",
        delay: 0
    };
}(window.jQuery), /* ===========================================================
 * bootstrap-popover.js v2.0.3
 * http://twitter.github.com/bootstrap/javascript.html#popovers
 * ===========================================================
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =========================================================== */
/**
 * @fileoverview
 * @suppress {checkVars|uselessCode}
 */
!function($) {
    "use strict";
    // jshint ;_;
    /* POPOVER PUBLIC CLASS DEFINITION
     * =============================== */
    var Popover = function(element, options) {
        this.init("atPopover", element, options);
    };
    /* NOTE: POPOVER EXTENDS BOOTSTRAP-TOOLTIP.js
     ========================================== */
    Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype, {
        constructor: Popover,
        setContent: function() {
            var $tip = this.tip(), title = this.getTitle(), content = this.getContent();
            $tip.find(".at-popover-title")[this.isHTML(title) ? "html" : "text"](title), $tip.find(".at-popover-content > *")[this.isHTML(content) ? "html" : "text"](content), 
            $tip.removeClass("fade top bottom left right in");
        },
        hasContent: function() {
            return this.getTitle() || this.getContent();
        },
        getContent: function() {
            var content, $e = this.$element, o = this.options;
            return content = $e.attr("data-content") || ("function" == typeof o.content ? o.content.call($e[0]) : o.content);
        },
        tip: function() {
            return this.$tip || (this.$tip = $(this.options.template)), this.$tip;
        }
    }), /* POPOVER PLUGIN DEFINITION
     * ======================= */
    $.fn.atPopover = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("at-popover"), options = "object" == typeof option && option;
            data || $this.data("at-popover", data = new Popover(this, options)), "string" == typeof option && data[option]();
        });
    }, $.fn.atPopover.Constructor = Popover, $.fn.atPopover.defaults = $.extend({}, $.fn.tooltip.defaults, {
        placement: "right",
        content: "",
        template: '<div class="at-popover"><div class="arrow"></div><div class="at-popover-inner"><h3 class="at-popover-title"></h3><div class="at-popover-content"><p></p></div></div></div>'
    });
}(window.jQuery), /*!
 * jQuery UI Button @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/button/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
function($) {
    var lastActive, startXPos, startYPos, clickDragged, baseClasses = "ui-button ui-widget ui-state-default ui-corner-all", stateClasses = "ui-state-hover ui-state-active ", typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only", formResetHandler = function() {
        var buttons = $(this).find(":ui-button");
        setTimeout(function() {
            buttons.button("refresh");
        }, 1);
    }, radioGroup = function(radio) {
        var name = radio.name, form = radio.form, radios = $([]);
        return name && (name = name.replace(/'/g, "\\'"), radios = form ? $(form).find("[name='" + name + "']") : $("[name='" + name + "']", radio.ownerDocument).filter(function() {
            return !this.form;
        })), radios;
    };
    $.widget("ui.button", {
        version: "@VERSION",
        defaultElement: "<button>",
        options: {
            disabled: null,
            text: !0,
            label: null,
            icons: {
                primary: null,
                secondary: null
            }
        },
        _create: function() {
            this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, formResetHandler), 
            "boolean" != typeof this.options.disabled ? this.options.disabled = !!this.element.prop("disabled") : this.element.prop("disabled", this.options.disabled), 
            this._determineButtonType(), this.hasTitle = !!this.buttonElement.attr("title");
            var that = this, options = this.options, toggleButton = "checkbox" === this.type || "radio" === this.type, activeClass = toggleButton ? "" : "ui-state-active", focusClass = "ui-state-focus";
            null === options.label && (options.label = "input" === this.type ? this.buttonElement.val() : this.buttonElement.html()), 
            this._hoverable(this.buttonElement), this.buttonElement.addClass(baseClasses).attr("role", "button").bind("mouseenter" + this.eventNamespace, function() {
                options.disabled || this === lastActive && $(this).addClass("ui-state-active");
            }).bind("mouseleave" + this.eventNamespace, function() {
                options.disabled || $(this).removeClass(activeClass);
            }).bind("click" + this.eventNamespace, function(event) {
                options.disabled && (event.preventDefault(), event.stopImmediatePropagation());
            }), this.element.bind("focus" + this.eventNamespace, function() {
                // no need to check disabled, focus won't be triggered anyway
                that.buttonElement.addClass(focusClass);
            }).bind("blur" + this.eventNamespace, function() {
                that.buttonElement.removeClass(focusClass);
            }), toggleButton && (this.element.bind("change" + this.eventNamespace, function() {
                clickDragged || that.refresh();
            }), // if mouse moves between mousedown and mouseup (drag) set clickDragged flag
            // prevents issue where button state changes but checkbox/radio checked state
            // does not in Firefox (see ticket #6970)
            this.buttonElement.bind("mousedown" + this.eventNamespace, function(event) {
                options.disabled || (clickDragged = !1, startXPos = event.pageX, startYPos = event.pageY);
            }).bind("mouseup" + this.eventNamespace, function(event) {
                options.disabled || (startXPos !== event.pageX || startYPos !== event.pageY) && (clickDragged = !0);
            })), "checkbox" === this.type ? this.buttonElement.bind("click" + this.eventNamespace, function() {
                return options.disabled || clickDragged ? !1 : void 0;
            }) : "radio" === this.type ? this.buttonElement.bind("click" + this.eventNamespace, function() {
                if (options.disabled || clickDragged) return !1;
                $(this).addClass("ui-state-active"), that.buttonElement.attr("aria-pressed", "true");
                var radio = that.element[0];
                radioGroup(radio).not(radio).map(function() {
                    return $(this).button("widget")[0];
                }).removeClass("ui-state-active").attr("aria-pressed", "false");
            }) : (this.buttonElement.bind("mousedown" + this.eventNamespace, function() {
                return options.disabled ? !1 : ($(this).addClass("ui-state-active"), lastActive = this, 
                void that.document.one("mouseup", function() {
                    lastActive = null;
                }));
            }).bind("mouseup" + this.eventNamespace, function() {
                return options.disabled ? !1 : void $(this).removeClass("ui-state-active");
            }).bind("keydown" + this.eventNamespace, function(event) {
                return options.disabled ? !1 : void ((event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) && $(this).addClass("ui-state-active"));
            }).bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
                $(this).removeClass("ui-state-active");
            }), this.buttonElement.is("a") && this.buttonElement.keyup(function(event) {
                event.keyCode === $.ui.keyCode.SPACE && // TODO pass through original event correctly (just as 2nd argument doesn't work)
                $(this).click();
            })), this._setOption("disabled", options.disabled), this._resetButton();
        },
        _determineButtonType: function() {
            var ancestor, labelSelector, checked;
            this.type = this.element.is("[type=checkbox]") ? "checkbox" : this.element.is("[type=radio]") ? "radio" : this.element.is("input") ? "input" : "button", 
            "checkbox" === this.type || "radio" === this.type ? (// we don't search against the document in case the element
            // is disconnected from the DOM
            ancestor = this.element.parents().last(), labelSelector = "label[for='" + this.element.attr("id") + "']", 
            this.buttonElement = ancestor.find(labelSelector), this.buttonElement.length || (ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings(), 
            this.buttonElement = ancestor.filter(labelSelector), this.buttonElement.length || (this.buttonElement = ancestor.find(labelSelector))), 
            this.element.addClass("ui-helper-hidden-accessible"), checked = this.element.is(":checked"), 
            checked && this.buttonElement.addClass("ui-state-active"), this.buttonElement.prop("aria-pressed", checked)) : this.buttonElement = this.element;
        },
        widget: function() {
            return this.buttonElement;
        },
        _destroy: function() {
            this.element.removeClass("ui-helper-hidden-accessible"), this.buttonElement.removeClass(baseClasses + " " + stateClasses + " " + typeClasses).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()), 
            this.hasTitle || this.buttonElement.removeAttr("title");
        },
        _setOption: function(key, value) {
            return this._super(key, value), "disabled" === key ? (this.widget().toggleClass("ui-state-disabled", !!value), 
            void this.element.prop("disabled", !!value)) : void this._resetButton();
        },
        refresh: function() {
            //See #8237 & #8828
            var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");
            isDisabled !== this.options.disabled && this._setOption("disabled", isDisabled), 
            "radio" === this.type ? radioGroup(this.element[0]).each(function() {
                $(this).is(":checked") ? $(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true") : $(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false");
            }) : "checkbox" === this.type && (this.element.is(":checked") ? this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true") : this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false"));
        },
        _resetButton: function() {
            if ("input" === this.type) return void (this.options.label && this.element.val(this.options.label));
            var buttonElement = this.buttonElement.removeClass(typeClasses), buttonText = $("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(buttonElement.empty()).text(), icons = this.options.icons, multipleIcons = icons.primary && icons.secondary, buttonClasses = [];
            icons.primary || icons.secondary ? (this.options.text && buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : icons.primary ? "-primary" : "-secondary")), 
            icons.primary && buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>"), 
            icons.secondary && buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>"), 
            this.options.text || (buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only"), 
            this.hasTitle || buttonElement.attr("title", $.trim(buttonText)))) : buttonClasses.push("ui-button-text-only"), 
            buttonElement.addClass(buttonClasses.join(" "));
        }
    }), $.widget("ui.buttonset", {
        version: "@VERSION",
        options: {
            items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
        },
        _create: function() {
            this.element.addClass("ui-buttonset");
        },
        _init: function() {
            this.refresh();
        },
        _setOption: function(key, value) {
            "disabled" === key && this.buttons.button("option", key, value), this._super(key, value);
        },
        refresh: function() {
            var rtl = "rtl" === this.element.css("direction");
            this.buttons = this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function() {
                return $(this).button("widget")[0];
            }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(rtl ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(rtl ? "ui-corner-left" : "ui-corner-right").end().end();
        },
        _destroy: function() {
            this.element.removeClass("ui-buttonset"), this.buttons.map(function() {
                return $(this).button("widget")[0];
            }).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
        }
    });
}(jQuery), /*!
 * jQuery UI Dialog @VERSION
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/dialog/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
function($) {
    var sizeRelatedOptions = {
        buttons: !0,
        height: !0,
        maxHeight: !0,
        maxWidth: !0,
        minHeight: !0,
        minWidth: !0,
        width: !0
    }, resizableRelatedOptions = {
        maxHeight: !0,
        maxWidth: !0,
        minHeight: !0,
        minWidth: !0
    };
    $.widget("ui.dialog", {
        version: "@VERSION",
        options: {
            appendTo: "body",
            autoOpen: !0,
            buttons: [],
            closeOnEscape: !0,
            closeText: "close",
            dialogClass: "",
            draggable: !0,
            hide: null,
            height: "auto",
            maxHeight: null,
            maxWidth: null,
            minHeight: 150,
            minWidth: 150,
            modal: !1,
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",
                // Ensure the titlebar is always visible
                using: function(pos) {
                    var topOffset = $(this).css(pos).offset().top;
                    0 > topOffset && $(this).css("top", pos.top - topOffset);
                }
            },
            resizable: !0,
            show: null,
            title: null,
            width: 300,
            // callbacks
            beforeClose: null,
            close: null,
            drag: null,
            dragStart: null,
            dragStop: null,
            focus: null,
            open: null,
            resize: null,
            resizeStart: null,
            resizeStop: null
        },
        _create: function() {
            this.originalCss = {
                display: this.element[0].style.display,
                width: this.element[0].style.width,
                minHeight: this.element[0].style.minHeight,
                maxHeight: this.element[0].style.maxHeight,
                height: this.element[0].style.height
            }, this.originalPosition = {
                parent: this.element.parent(),
                index: this.element.parent().children().index(this.element)
            }, this.originalTitle = this.element.attr("title"), this.options.title = this.options.title || this.originalTitle, 
            this._createWrapper(), this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog), 
            this._createTitlebar(), this._createButtonPane(), this.options.draggable && $.fn.draggable && this._makeDraggable(), 
            this.options.resizable && $.fn.resizable && this._makeResizable(), this._isOpen = !1;
        },
        _init: function() {
            this.options.autoOpen && this.open();
        },
        _appendTo: function() {
            var element = this.options.appendTo;
            return element && (element.jquery || element.nodeType) ? $(element) : this.document.find(element || "body").eq(0);
        },
        _destroy: function() {
            var next, originalPosition = this.originalPosition;
            this._destroyOverlay(), this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach(), 
            this.uiDialog.stop(!0, !0).remove(), this.originalTitle && this.element.attr("title", this.originalTitle), 
            next = originalPosition.parent.children().eq(originalPosition.index), // Don't try to place the dialog next to itself (#8613)
            next.length && next[0] !== this.element[0] ? next.before(this.element) : originalPosition.parent.append(this.element);
        },
        widget: function() {
            return this.uiDialog;
        },
        disable: $.noop,
        enable: $.noop,
        close: function(event) {
            var that = this;
            this._isOpen && this._trigger("beforeClose", event) !== !1 && (this._isOpen = !1, 
            this._destroyOverlay(), this.opener.filter(":focusable").focus().length || // Hiding a focused element doesn't trigger blur in WebKit
            // so in case we have nothing to focus on, explicitly blur the active element
            // https://bugs.webkit.org/show_bug.cgi?id=47182
            $(this.document[0].activeElement).blur(), this._hide(this.uiDialog, this.options.hide, function() {
                that._trigger("close", event);
            }));
        },
        isOpen: function() {
            return this._isOpen;
        },
        moveToTop: function() {
            this._moveToTop();
        },
        _moveToTop: function(event, silent) {
            var moved = !!this.uiDialog.nextAll(":visible").insertBefore(this.uiDialog).length;
            return moved && !silent && this._trigger("focus", event), moved;
        },
        open: function() {
            var that = this;
            return this._isOpen ? void (this._moveToTop() && this._focusTabbable()) : (this._isOpen = !0, 
            this.opener = $(this.document[0].activeElement), this._size(), this._position(), 
            this._createOverlay(), this._moveToTop(null, !0), this._show(this.uiDialog, this.options.show, function() {
                that._focusTabbable(), that._trigger("focus");
            }), void this._trigger("open"));
        },
        _focusTabbable: function() {
            // Set focus to the first match:
            // 1. First element inside the dialog matching [autofocus]
            // 2. Tabbable element inside the content element
            // 3. Tabbable element inside the buttonpane
            // 4. The close button
            // 5. The dialog itself
            var hasFocus = this.element.find("[autofocus]");
            hasFocus.length || (hasFocus = this.element.find(":tabbable")), hasFocus.length || (hasFocus = this.uiDialogButtonPane.find(":tabbable")), 
            hasFocus.length || (hasFocus = this.uiDialogTitlebarClose.filter(":tabbable")), 
            hasFocus.length || (hasFocus = this.uiDialog), hasFocus.eq(0).focus();
        },
        _keepFocus: function(event) {
            function checkFocus() {
                var activeElement = this.document[0].activeElement, isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
                isActive || this._focusTabbable();
            }
            event.preventDefault(), checkFocus.call(this), // support: IE
            // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
            // so we check again later
            this._delay(checkFocus);
        },
        _createWrapper: function() {
            this.uiDialog = $("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " + this.options.dialogClass).hide().attr({
                // Setting tabIndex makes the div focusable
                tabIndex: -1,
                role: "dialog"
            }).appendTo(this._appendTo()), this._on(this.uiDialog, {
                keydown: function(event) {
                    if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) return event.preventDefault(), 
                    void this.close(event);
                    // prevent tabbing out of dialogs
                    if (event.keyCode === $.ui.keyCode.TAB) {
                        var tabbables = this.uiDialog.find(":tabbable"), first = tabbables.filter(":first"), last = tabbables.filter(":last");
                        event.target !== last[0] && event.target !== this.uiDialog[0] || event.shiftKey ? event.target !== first[0] && event.target !== this.uiDialog[0] || !event.shiftKey || (last.focus(1), 
                        event.preventDefault()) : (first.focus(1), event.preventDefault());
                    }
                },
                mousedown: function(event) {
                    this._moveToTop(event) && this._focusTabbable();
                }
            }), // We assume that any existing aria-describedby attribute means
            // that the dialog content is marked up properly
            // otherwise we brute force the content as the description
            this.element.find("[aria-describedby]").length || this.uiDialog.attr({
                "aria-describedby": this.element.uniqueId().attr("id")
            });
        },
        _createTitlebar: function() {
            var uiDialogTitle;
            this.uiDialogTitlebar = $("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog), 
            this._on(this.uiDialogTitlebar, {
                mousedown: function(event) {
                    // Don't prevent click on close button (#8838)
                    // Focusing a dialog that is partially scrolled out of view
                    // causes the browser to scroll it into view, preventing the click event
                    $(event.target).closest(".ui-dialog-titlebar-close") || // Dialog isn't getting focus when dragging (#8063)
                    this.uiDialog.focus();
                }
            }), this.uiDialogTitlebarClose = $("<button></button>").button({
                label: this.options.closeText,
                icons: {
                    primary: "ui-icon-closethick"
                },
                text: !1
            }).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar), this._on(this.uiDialogTitlebarClose, {
                click: function(event) {
                    event.preventDefault(), this.close(event);
                }
            }), uiDialogTitle = $("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar), 
            this._title(uiDialogTitle), this.uiDialog.attr({
                "aria-labelledby": uiDialogTitle.attr("id")
            });
        },
        _title: function(title) {
            this.options.title || title.html("&#160;"), title.text(this.options.title);
        },
        _createButtonPane: function() {
            this.uiDialogButtonPane = $("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"), 
            this.uiButtonSet = $("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane), 
            this._createButtons();
        },
        _createButtons: function() {
            var that = this, buttons = this.options.buttons;
            // if we already have a button pane, remove it
            return this.uiDialogButtonPane.remove(), this.uiButtonSet.empty(), $.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length ? void this.uiDialog.removeClass("ui-dialog-buttons") : ($.each(buttons, function(name, props) {
                var click, buttonOptions;
                props = $.isFunction(props) ? {
                    click: props,
                    text: name
                } : props, // Default to a non-submitting button
                props = $.extend({
                    type: "button"
                }, props), // Change the context for the click callback to be the main element
                click = props.click, props.click = function() {
                    click.apply(that.element[0], arguments);
                }, buttonOptions = {
                    icons: props.icons,
                    text: props.showText
                }, delete props.icons, delete props.showText, $("<button></button>", props).button(buttonOptions).appendTo(that.uiButtonSet);
            }), this.uiDialog.addClass("ui-dialog-buttons"), void this.uiDialogButtonPane.appendTo(this.uiDialog));
        },
        _makeDraggable: function() {
            function filteredUi(ui) {
                return {
                    position: ui.position,
                    offset: ui.offset
                };
            }
            var that = this, options = this.options;
            this.uiDialog.draggable({
                cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
                handle: ".ui-dialog-titlebar",
                containment: "document",
                start: function(event, ui) {
                    $(this).addClass("ui-dialog-dragging"), that._blockFrames(), that._trigger("dragStart", event, filteredUi(ui));
                },
                drag: function(event, ui) {
                    that._trigger("drag", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    options.position = [ ui.position.left - that.document.scrollLeft(), ui.position.top - that.document.scrollTop() ], 
                    $(this).removeClass("ui-dialog-dragging"), that._unblockFrames(), that._trigger("dragStop", event, filteredUi(ui));
                }
            });
        },
        _makeResizable: function() {
            function filteredUi(ui) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size
                };
            }
            var that = this, options = this.options, handles = options.resizable, // .ui-resizable has position: relative defined in the stylesheet
            // but dialogs have to use absolute or fixed positioning
            position = this.uiDialog.css("position"), resizeHandles = "string" == typeof handles ? handles : "n,e,s,w,se,sw,ne,nw";
            this.uiDialog.resizable({
                cancel: ".ui-dialog-content",
                containment: "document",
                alsoResize: this.element,
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function(event, ui) {
                    $(this).addClass("ui-dialog-resizing"), that._blockFrames(), that._trigger("resizeStart", event, filteredUi(ui));
                },
                resize: function(event, ui) {
                    that._trigger("resize", event, filteredUi(ui));
                },
                stop: function(event, ui) {
                    options.height = $(this).height(), options.width = $(this).width(), $(this).removeClass("ui-dialog-resizing"), 
                    that._unblockFrames(), that._trigger("resizeStop", event, filteredUi(ui));
                }
            }).css("position", position);
        },
        _minHeight: function() {
            var options = this.options;
            return "auto" === options.height ? options.minHeight : Math.min(options.minHeight, options.height);
        },
        _position: function() {
            // Need to show the dialog to get the actual offset in the position plugin
            var isVisible = this.uiDialog.is(":visible");
            isVisible || this.uiDialog.show(), this.uiDialog.position(this.options.position), 
            isVisible || this.uiDialog.hide();
        },
        _setOptions: function(options) {
            var that = this, resize = !1, resizableOptions = {};
            $.each(options, function(key, value) {
                that._setOption(key, value), key in sizeRelatedOptions && (resize = !0), key in resizableRelatedOptions && (resizableOptions[key] = value);
            }), resize && (this._size(), this._position()), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", resizableOptions);
        },
        _setOption: function(key, value) {
            /*jshint maxcomplexity:15*/
            var isDraggable, isResizable, uiDialog = this.uiDialog;
            "dialogClass" === key && uiDialog.removeClass(this.options.dialogClass).addClass(value), 
            "disabled" !== key && (this._super(key, value), "appendTo" === key && this.uiDialog.appendTo(this._appendTo()), 
            "buttons" === key && this._createButtons(), "closeText" === key && this.uiDialogTitlebarClose.button({
                // Ensure that we always pass a string
                label: "" + value
            }), "draggable" === key && (isDraggable = uiDialog.is(":data(ui-draggable)"), isDraggable && !value && uiDialog.draggable("destroy"), 
            !isDraggable && value && this._makeDraggable()), "position" === key && this._position(), 
            "resizable" === key && (// currently resizable, becoming non-resizable
            isResizable = uiDialog.is(":data(ui-resizable)"), isResizable && !value && uiDialog.resizable("destroy"), 
            // currently resizable, changing handles
            isResizable && "string" == typeof value && uiDialog.resizable("option", "handles", value), 
            // currently non-resizable, becoming resizable
            isResizable || value === !1 || this._makeResizable()), "title" === key && this._title(this.uiDialogTitlebar.find(".ui-dialog-title")));
        },
        _size: function() {
            // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
            // divs will both have width and height set, so we need to reset them
            var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
            // Reset content sizing
            this.element.show().css({
                width: "auto",
                minHeight: 0,
                maxHeight: "none",
                height: 0
            }), options.minWidth > options.width && (options.width = options.minWidth), // reset wrapper sizing
            // determine the height of all the non-content elements
            nonContentHeight = this.uiDialog.css({
                height: "auto",
                width: options.width
            }).outerHeight(), minContentHeight = Math.max(0, options.minHeight - nonContentHeight), 
            maxContentHeight = "number" == typeof options.maxHeight ? Math.max(0, options.maxHeight - nonContentHeight) : "none", 
            "auto" === options.height ? this.element.css({
                minHeight: minContentHeight,
                maxHeight: maxContentHeight,
                height: "auto"
            }) : this.element.height(Math.max(0, options.height - nonContentHeight)), this.uiDialog.is(":data(ui-resizable)") && this.uiDialog.resizable("option", "minHeight", this._minHeight());
        },
        _blockFrames: function() {
            this.iframeBlocks = this.document.find("iframe").map(function() {
                var iframe = $(this);
                return $("<div>").css({
                    position: "absolute",
                    width: iframe.outerWidth(),
                    height: iframe.outerHeight()
                }).appendTo(iframe.parent()).offset(iframe.offset())[0];
            });
        },
        _unblockFrames: function() {
            this.iframeBlocks && (this.iframeBlocks.remove(), delete this.iframeBlocks);
        },
        _allowInteraction: function(event) {
            return $(event.target).closest(".ui-dialog").length ? !0 : !!$(event.target).closest(".ui-datepicker").length;
        },
        _createOverlay: function() {
            if (this.options.modal) {
                var that = this, widgetFullName = this.widgetFullName;
                $.ui.dialog.overlayInstances || // Prevent use of anchors and inputs.
                // We use a delay in case the overlay is created from an
                // event that we're going to be cancelling. (#2804)
                this._delay(function() {
                    // Handle .dialog().dialog("close") (#4065)
                    $.ui.dialog.overlayInstances && this.document.bind("focusin.dialog", function(event) {
                        that._allowInteraction(event) || (event.preventDefault(), $(".ui-dialog:visible:last .ui-dialog-content").data(widgetFullName)._focusTabbable());
                    });
                }), this.overlay = $("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo()), 
                this._on(this.overlay, {
                    mousedown: "_keepFocus"
                }), $.ui.dialog.overlayInstances++;
            }
        },
        _destroyOverlay: function() {
            this.options.modal && this.overlay && ($.ui.dialog.overlayInstances--, $.ui.dialog.overlayInstances || this.document.unbind("focusin.dialog"), 
            this.overlay.remove(), this.overlay = null);
        }
    }), $.ui.dialog.overlayInstances = 0;
}(jQuery), // jQuery.XDomainRequest.js
// Author: Jason Moon - @JSONMOON
// IE8+
function($) {
    if (!$.support.cors && $.ajaxTransport && window.XDomainRequest) {
        var httpRegEx = /^https?:\/\//i, getOrPostRegEx = /^get|post$/i, sameSchemeRegEx = new RegExp("^" + location.protocol, "i"), htmlRegEx = /text\/html/i, jsonRegEx = /\/json/i, xmlRegEx = /\/xml/i;
        // ajaxTransport exists in jQuery 1.5+
        $.ajaxTransport("* text html xml json", function(options, userOptions) {
            // XDomainRequests must be: asynchronous, GET or POST methods, HTTP or HTTPS protocol, and same scheme as calling page
            if (options.crossDomain && options.async && getOrPostRegEx.test(options.type) && httpRegEx.test(options.url) && sameSchemeRegEx.test(options.url)) {
                var xdr = null, userType = (userOptions.dataType || "").toLowerCase();
                return {
                    send: function(headers, complete) {
                        xdr = new XDomainRequest(), /^\d+$/.test(userOptions.timeout) && (xdr.timeout = userOptions.timeout), 
                        xdr.ontimeout = function() {
                            complete(500, "timeout");
                        }, xdr.onload = function() {
                            var allResponseHeaders = "Content-Length: " + xdr.responseText.length + "\r\nContent-Type: " + xdr.contentType, status = {
                                code: 200,
                                message: "success"
                            }, responses = {
                                text: xdr.responseText
                            };
                            try {
                                if ("html" === userType || htmlRegEx.test(xdr.contentType)) responses.html = xdr.responseText; else if ("json" === userType || "text" !== userType && jsonRegEx.test(xdr.contentType)) try {
                                    responses.json = $.parseJSON(xdr.responseText);
                                } catch (e) {
                                    status.code = 500, status.message = "parseerror";
                                } else if ("xml" === userType || "text" !== userType && xmlRegEx.test(xdr.contentType)) {
                                    var doc = new ActiveXObject("Microsoft.XMLDOM");
                                    doc.async = !1;
                                    try {
                                        doc.loadXML(xdr.responseText);
                                    } catch (e) {
                                        doc = void 0;
                                    }
                                    if (!doc || !doc.documentElement || doc.getElementsByTagName("parsererror").length) throw status.code = 500, 
                                    status.message = "parseerror", "Invalid XML: " + xdr.responseText;
                                    responses.xml = doc;
                                }
                            } catch (parseMessage) {
                                throw parseMessage;
                            } finally {
                                complete(status.code, status.message, responses, allResponseHeaders);
                            }
                        }, // set an empty handler for 'onprogress' so requests don't get aborted
                        xdr.onprogress = function() {}, xdr.onerror = function() {
                            complete(500, "error", {
                                text: xdr.responseText
                            });
                        };
                        var postData = "";
                        userOptions.data && (postData = "string" === $.type(userOptions.data) ? userOptions.data : $.param(userOptions.data)), 
                        xdr.open(options.type, options.url), xdr.send(postData);
                    },
                    abort: function() {
                        xdr && xdr.abort();
                    }
                };
            }
        });
    }
}(jQuery), /**
 * Android requires exceptions.
 *
 * @type boolean
 */
FastClick.prototype.deviceIsAndroid = navigator.userAgent.indexOf("Android") > 0, 
/**
 * iOS requires exceptions.
 *
 * @type boolean
 */
FastClick.prototype.deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent), /**
 * iOS 4 requires an exception for select elements.
 *
 * @type boolean
 */
FastClick.prototype.deviceIsIOS4 = FastClick.prototype.deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent), 
/**
 * iOS 6.0(+?) requires the target element to be manually derived
 *
 * @type boolean
 */
FastClick.prototype.deviceIsIOSWithBadTarget = FastClick.prototype.deviceIsIOS && /OS ([6-9]|\d{2})_\d/.test(navigator.userAgent), 
/**
 * Determine whether a given element requires a native click.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element needs a native click
 */
FastClick.prototype.needsClick = function(target) {
    "use strict";
    switch (target.nodeName.toLowerCase()) {
      // Don't send a synthetic click to disabled inputs (issue #62)
        case "button":
      case "select":
      case "textarea":
        if (target.disabled) return !0;
        break;

      case "input":
        // File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
        if (this.deviceIsIOS && "file" === target.type || target.disabled) return !0;
        break;

      case "label":
      case "video":
        return !0;
    }
    return /\bneedsclick\b/.test(target.className);
}, /**
 * Determine whether a given element requires a call to focus to simulate click into element.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
 */
FastClick.prototype.needsFocus = function(target) {
    "use strict";
    switch (target.nodeName.toLowerCase()) {
      case "textarea":
        return !0;

      case "select":
        return !this.deviceIsAndroid;

      case "input":
        switch (target.type) {
          case "button":
          case "checkbox":
          case "file":
          case "image":
          case "radio":
          case "submit":
            return !1;
        }
        // No point in attempting to focus disabled inputs
        return !target.disabled && !target.readOnly;

      default:
        return /\bneedsfocus\b/.test(target.className);
    }
}, /**
 * Send a click event to the specified element.
 *
 * @param {EventTarget|Element} targetElement
 * @param {Event} event
 */
FastClick.prototype.sendClick = function(targetElement, event) {
    "use strict";
    var clickEvent, touch;
    // On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
    document.activeElement && document.activeElement !== targetElement && document.activeElement.blur(), 
    touch = event.changedTouches[0], // Synthesise a click event, with an extra attribute so it can be tracked
    clickEvent = document.createEvent("MouseEvents"), clickEvent.initMouseEvent(this.determineEventType(targetElement), !0, !0, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, !1, !1, !1, !1, 0, null), 
    clickEvent.forwardedTouchEvent = !0, targetElement.dispatchEvent(clickEvent);
}, FastClick.prototype.determineEventType = function(targetElement) {
    "use strict";
    //Issue #159: Android Chrome Select Box does not open with a synthetic click event
    //Issue #159: Android Chrome Select Box does not open with a synthetic click event
    return this.deviceIsAndroid && "select" === targetElement.tagName.toLowerCase() ? "mousedown" : "click";
}, /**
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.focus = function(targetElement) {
    "use strict";
    var length;
    // Issue #160: on iOS 7, some input elements (e.g. date datetime) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
    this.deviceIsIOS && targetElement.setSelectionRange && 0 !== targetElement.type.indexOf("date") && "time" !== targetElement.type ? (length = targetElement.value.length, 
    targetElement.setSelectionRange(length, length)) : targetElement.focus();
}, /**
 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
 *
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.updateScrollParent = function(targetElement) {
    "use strict";
    var scrollParent, parentElement;
    // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
    // target element was moved to another parent.
    if (scrollParent = targetElement.fastClickScrollParent, !scrollParent || !scrollParent.contains(targetElement)) {
        parentElement = targetElement;
        do {
            if (parentElement.scrollHeight > parentElement.offsetHeight) {
                scrollParent = parentElement, targetElement.fastClickScrollParent = parentElement;
                break;
            }
            parentElement = parentElement.parentElement;
        } while (parentElement);
    }
    // Always update the scroll top tracker if possible.
    scrollParent && (scrollParent.fastClickLastScrollTop = scrollParent.scrollTop);
}, /**
 * @param {EventTarget} targetElement
 * @returns {Element|EventTarget}
 */
FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
    "use strict";
    // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
    // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
    return eventTarget.nodeType === Node.TEXT_NODE ? eventTarget.parentNode : eventTarget;
}, /**
 * On touch start, record the position and scroll offset.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchStart = function(event) {
    "use strict";
    var targetElement, touch, selection;
    // Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
    if (event.targetTouches.length > 1) return !0;
    if (targetElement = this.getTargetElementFromEventTarget(event.target), touch = event.targetTouches[0], 
    this.deviceIsIOS) {
        if (// Only trusted events will deselect text on iOS (issue #49)
        selection = window.getSelection(), selection.rangeCount && !selection.isCollapsed) return !0;
        if (!this.deviceIsIOS4) {
            // Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
            // when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
            // with the same identifier as the touch event that previously triggered the click that triggered the alert.
            // Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
            // immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
            if (touch.identifier === this.lastTouchIdentifier) return event.preventDefault(), 
            !1;
            this.lastTouchIdentifier = touch.identifier, // If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
            // 1) the user does a fling scroll on the scrollable layer
            // 2) the user stops the fling scroll with another tap
            // then the event.target of the last 'touchend' event will be the element that was under the user's finger
            // when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
            // is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
            this.updateScrollParent(targetElement);
        }
    }
    // Prevent phantom clicks on fast double-tap (issue #36)
    return this.trackingClick = !0, this.trackingClickStart = event.timeStamp, this.targetElement = targetElement, 
    this.touchStartX = touch.pageX, this.touchStartY = touch.pageY, event.timeStamp - this.lastClickTime < 200 && event.preventDefault(), 
    !0;
}, /**
 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.touchHasMoved = function(event) {
    "use strict";
    var touch = event.changedTouches[0], boundary = this.touchBoundary;
    return Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary ? !0 : !1;
}, /**
 * Update the last position.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchMove = function(event) {
    "use strict";
    // If the touch has moved, cancel the click tracking
    return this.trackingClick ? ((this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) && (this.trackingClick = !1, 
    this.targetElement = null), !0) : !0;
}, /**
 * Attempt to find the labelled control for the given label element.
 *
 * @param {EventTarget|HTMLLabelElement} labelElement
 * @returns {Element|null}
 */
FastClick.prototype.findControl = function(labelElement) {
    "use strict";
    // Fast path for newer browsers supporting the HTML5 control attribute
    // Fast path for newer browsers supporting the HTML5 control attribute
    // All browsers under test that support touch events also support the HTML5 htmlFor attribute
    return void 0 !== labelElement.control ? labelElement.control : labelElement.htmlFor ? document.getElementById(labelElement.htmlFor) : labelElement.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea");
}, /**
 * On touch end, determine whether to send a click event at once.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchEnd = function(event) {
    "use strict";
    var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;
    if (!this.trackingClick) return !0;
    // Prevent phantom clicks on fast double-tap (issue #36)
    if (event.timeStamp - this.lastClickTime < 200) return this.cancelNextClick = !0, 
    !0;
    if (// Reset to prevent wrong click cancel on input (issue #156).
    this.cancelNextClick = !1, this.lastClickTime = event.timeStamp, trackingClickStart = this.trackingClickStart, 
    this.trackingClick = !1, this.trackingClickStart = 0, // On some iOS devices, the targetElement supplied with the event is invalid if the layer
    // is performing a transition or scroll, and has to be re-detected manually. Note that
    // for this to function correctly, it must be called *after* the event target is checked!
    // See issue #57; also filed as rdar://13048589 .
    this.deviceIsIOSWithBadTarget && (touch = event.changedTouches[0], // In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
    targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement, 
    targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent), 
    targetTagName = targetElement.tagName.toLowerCase(), "label" === targetTagName) {
        if (forElement = this.findControl(targetElement)) {
            if (this.focus(targetElement), this.deviceIsAndroid) return !1;
            targetElement = forElement;
        }
    } else if (this.needsFocus(targetElement)) // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
    // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
    // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
    // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
    // Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
    return event.timeStamp - trackingClickStart > 100 || this.deviceIsIOS && window.top !== window && "input" === targetTagName ? (this.targetElement = null, 
    !1) : (this.focus(targetElement), this.deviceIsIOS4 && "select" === targetTagName || (this.targetElement = null, 
    event.preventDefault()), !1);
    // Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
    // and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
    // Prevent the actual click from going though - unless the target node is marked as requiring
    // real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
    return this.deviceIsIOS && !this.deviceIsIOS4 && (scrollParent = targetElement.fastClickScrollParent, 
    scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) ? !0 : (this.needsClick(targetElement) || (event.preventDefault(), 
    this.sendClick(targetElement, event)), !1);
}, /**
 * On touch cancel, stop tracking the click.
 *
 * @returns {void}
 */
FastClick.prototype.onTouchCancel = function() {
    "use strict";
    this.trackingClick = !1, this.targetElement = null;
}, /**
 * Determine mouse events which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onMouse = function(event) {
    "use strict";
    // If a target element was never set (because a touch event was never fired) allow the event
    // If a target element was never set (because a touch event was never fired) allow the event
    // Programmatically generated events targeting a specific element should be permitted
    // Prevent any user-added listeners declared on FastClick element from being fired.
    // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
    // Cancel the event
    return this.targetElement ? event.forwardedTouchEvent ? !0 : event.cancelable && (!this.needsClick(this.targetElement) || this.cancelNextClick) ? (event.stopImmediatePropagation ? event.stopImmediatePropagation() : event.propagationStopped = !0, 
    event.stopPropagation(), event.preventDefault(), !1) : !0 : !0;
}, /**
 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
 * an actual click which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onClick = function(event) {
    "use strict";
    var permitted;
    // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
    // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
    // Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
    // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
    return this.trackingClick ? (this.targetElement = null, this.trackingClick = !1, 
    !0) : "submit" === event.target.type && 0 === event.detail ? !0 : (permitted = this.onMouse(event), 
    permitted || (this.targetElement = null), permitted);
}, /**
 * Remove all FastClick's event listeners.
 *
 * @returns {void}
 */
FastClick.prototype.destroy = function() {
    "use strict";
    var layer = this.layer;
    this.deviceIsAndroid && (layer.removeEventListener("mouseover", this.onMouse, !0), 
    layer.removeEventListener("mousedown", this.onMouse, !0), layer.removeEventListener("mouseup", this.onMouse, !0)), 
    layer.removeEventListener("click", this.onClick, !0), layer.removeEventListener("touchstart", this.onTouchStart, !1), 
    layer.removeEventListener("touchmove", this.onTouchMove, !1), layer.removeEventListener("touchend", this.onTouchEnd, !1), 
    layer.removeEventListener("touchcancel", this.onTouchCancel, !1);
}, /**
 * Check whether FastClick is needed.
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.notNeeded = function(layer) {
    "use strict";
    var metaViewport, chromeVersion;
    // Devices that don't support touch don't need FastClick
    if ("undefined" == typeof window.ontouchstart) return !0;
    if (// Chrome version - zero for other browsers
    chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [ , 0 ])[1]) {
        if (!FastClick.prototype.deviceIsAndroid) return !0;
        if (metaViewport = document.querySelector("meta[name=viewport]")) {
            // Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
            if (-1 !== metaViewport.content.indexOf("user-scalable=no")) return !0;
            // Chrome 32 and above with width=device-width or less don't need FastClick
            if (chromeVersion > 31 && window.innerWidth <= window.screen.width) return !0;
        }
    }
    // IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
    // IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
    return "none" === layer.style.msTouchAction ? !0 : !1;
}, /**
 * Factory method for creating a FastClick object
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.attach = function(layer) {
    "use strict";
    return new FastClick(layer);
}, "undefined" != typeof define && define.amd ? // AMD. Register as an anonymous module.
define(function() {
    "use strict";
    return FastClick;
}) : "undefined" != typeof module && module.exports ? (module.exports = FastClick.attach, 
module.exports.FastClick = FastClick) : window.FastClick = FastClick, function(factory) {
    "function" == typeof module ? module.exports = factory(this.jQuery || require("jquery")) : this.NProgress = factory(this.jQuery);
}(function($) {
    /**
   * Helpers
   */
    function clamp(n, min, max) {
        return min > n ? min : n > max ? max : n;
    }
    /**
   * (Internal) converts a percentage (`0..1`) to a bar translateX
   * percentage (`-100%..0%`).
   */
    function toBarPerc(n) {
        return 100 * (-1 + n);
    }
    /**
   * (Internal) returns the correct CSS for changing the bar's
   * position given an n percentage, and speed and ease from Settings
   */
    function barPositionCSS(n, speed, ease) {
        var barCSS;
        return barCSS = "translate3d" === Settings.positionUsing ? {
            transform: "translate3d(" + toBarPerc(n) + "%,0,0)"
        } : "translate" === Settings.positionUsing ? {
            transform: "translate(" + toBarPerc(n) + "%,0)"
        } : {
            "margin-left": toBarPerc(n) + "%"
        }, barCSS.transition = "all " + speed + "ms " + ease, barCSS;
    }
    var NProgress = {};
    NProgress.version = "0.1.2";
    var Settings = NProgress.settings = {
        minimum: .08,
        easing: "ease",
        positionUsing: "",
        speed: 200,
        trickle: !0,
        trickleRate: .02,
        trickleSpeed: 800,
        showSpinner: !0,
        template: '<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>',
        containerElement: void 0
    };
    /**
   * Updates configuration.
   *
   *     NProgress.configure({
   *       minimum: 0.1
   *     });
   */
    /**
   * Last number.
   */
    /**
   * Sets the progress bar status, where `n` is a number from `0.0` to `1.0`.
   *
   *     NProgress.set(0.4);
   *     NProgress.set(1.0);
   */
    /**
   * Shows the progress bar.
   * This is the same as setting the status to 0%, except that it doesn't go backwards.
   *
   *     NProgress.start();
   *
   */
    /**
   * Hides the progress bar.
   * This is the *sort of* the same as setting the status to 100%, with the
   * difference being `done()` makes some placebo effect of some realistic motion.
   *
   *     NProgress.done();
   *
   * If `true` is passed, it will show the progress bar even if its hidden.
   *
   *     NProgress.done(true);
   */
    /**
   * Increments by a random amount.
   */
    /**
   * (Internal) renders the progress bar markup based on the `template`
   * setting.
   */
    /**
   * Removes the element. Opposite of render().
   */
    /**
   * Checks if the progress bar is rendered.
   */
    /**
   * Determine which positioning CSS rule to use.
   */
    return NProgress.configure = function(options) {
        return $.extend(Settings, options), this;
    }, NProgress.status = null, NProgress.set = function(n) {
        var started = NProgress.isStarted();
        n = clamp(n, Settings.minimum, 1), NProgress.status = 1 === n ? null : n;
        var $progress = NProgress.render(!started), $bar = $progress.find('[role="bar"]'), speed = Settings.speed, ease = Settings.easing;
        /* Repaint */
        return $progress[0].offsetWidth, $progress.queue(function(next) {
            // Set positionUsing if it hasn't already been set
            "" === Settings.positionUsing && (Settings.positionUsing = NProgress.getPositioningCSS()), 
            // Add transition
            $bar.css(barPositionCSS(n, speed, ease)), 1 === n ? (// Fade out
            $progress.css({
                transition: "none",
                opacity: 1
            }), $progress[0].offsetWidth, /* Repaint */
            setTimeout(function() {
                $progress.css({
                    transition: "all " + speed + "ms linear",
                    opacity: 0
                }), setTimeout(function() {
                    NProgress.remove(), next();
                }, speed);
            }, speed)) : setTimeout(next, speed);
        }), this;
    }, NProgress.isStarted = function() {
        return "number" == typeof NProgress.status;
    }, NProgress.start = function() {
        NProgress.status || NProgress.set(0);
        var work = function() {
            setTimeout(function() {
                NProgress.status && (NProgress.trickle(), work());
            }, Settings.trickleSpeed);
        };
        return Settings.trickle && work(), this;
    }, NProgress.done = function(force) {
        return force || NProgress.status ? NProgress.inc(.3 + .5 * Math.random()).set(1) : this;
    }, NProgress.inc = function(amount) {
        var n = NProgress.status;
        return n ? ("number" != typeof amount && (amount = (1 - n) * clamp(Math.random() * n, .1, .95)), 
        n = clamp(n + amount, 0, .994), NProgress.set(n)) : NProgress.start();
    }, NProgress.trickle = function() {
        return NProgress.inc(Math.random() * Settings.trickleRate);
    }, NProgress.render = function(fromStart) {
        if (NProgress.isRendered()) return $("#nprogress");
        $("html").addClass("nprogress-busy");
        var $el = $("<div id='nprogress'>").html(Settings.template), perc = fromStart ? "-100" : toBarPerc(NProgress.status || 0);
        return $el.find('[role="bar"]').css({
            transition: "all 0 linear",
            transform: "translate3d(" + perc + "%,0,0)"
        }), Settings.showSpinner || $el.find('[role="spinner"]').remove(), $el.appendTo(Settings.containerElement || document.body), 
        $el;
    }, NProgress.remove = function() {
        $("html").removeClass("nprogress-busy"), $("#nprogress").remove();
    }, NProgress.isRendered = function() {
        return $("#nprogress").length > 0;
    }, NProgress.getPositioningCSS = function() {
        // Sniff on document.body.style
        var bodyStyle = document.body.style, vendorPrefix = "WebkitTransform" in bodyStyle ? "Webkit" : "MozTransform" in bodyStyle ? "Moz" : "msTransform" in bodyStyle ? "ms" : "OTransform" in bodyStyle ? "O" : "";
        return vendorPrefix + "Perspective" in bodyStyle ? "translate3d" : vendorPrefix + "Transform" in bodyStyle ? "translate" : "margin";
    }, NProgress;
});

/**
 * ScrollFix v0.1
 * http://www.joelambert.co.uk
 *
 * Copyright 2011, Joe Lambert.
 * Free to use under the MIT license.
 * http://www.opensource.org/licenses/mit-license.php
 */
var ScrollFix = function(elem) {
    // Variables to track inputs
    var startY, startTopScroll;
    elem = elem || document.querySelector(elem), // If there is no element, then do nothing	
    elem && // Handle the start of interactions
    elem.addEventListener("touchstart", function(event) {
        startY = event.touches[0].pageY, startTopScroll = elem.scrollTop, 0 >= startTopScroll && (elem.scrollTop = 1), 
        startTopScroll + elem.offsetHeight >= elem.scrollHeight && (elem.scrollTop = elem.scrollHeight - elem.offsetHeight - 1);
    }, !1);
}, ActiveText = function(options) {
    "use strict";
    function init() {
        api.ready = !0, // calling this here is necessary to allow for the disabling of the left edge.
        $(api).trigger(ActiveText.Events.REFRESH);
    }
    function attachExtensions() {
        if (api.extensions = [], options && options.extensions && $.isArray(options.extensions)) for (var i = 0, l = options.extensions.length; l > i; i++) "object" == typeof options.extensions[i] && api.extensions.push(options.extensions[i]);
        ActiveText.Analytics && api.extensions.push(new ActiveText.Analytics());
    }
    function attachClassDependencies() {
        api.behaviours = new ActiveText.Behaviours(api), api.navigation = new ActiveText.Navigation.Controller(api), 
        api.model = new ActiveText.Navigation.Model(api), api.utils = new ActiveText.Utils(api), 
        api.data = new ActiveText.Data(api), api.settings = new ActiveText.Settings(api), 
        api.loader = new ActiveText.Loader(api), api.view = new ActiveText.View(api, options), 
        api.theme = new ActiveText.Theme(api, options), api.constants = ActiveText.Constants, 
        api.version = ActiveText.version, attachExtensions();
    }
    function initExtensions() {
        if (api.extensions && $.isArray(api.extensions)) for (var i = 0, l = api.extensions.length; l > i; i++) if ("function" == typeof api.extensions[i].init) {
            var extensionOptions;
            options && options.options && (extensionOptions = options.options[i]), api.extensions[i].init(api, extensionOptions);
        }
    }
    function initClassDependencies() {
        if (api.model.init(), api.settings.init(), api.data.init(), api.loader.init(), api.view.init(), 
        initExtensions(), void 0 !== FastClick && options && options.containerElement) {
            var layer = options.containerElement.get(0);
            void 0 !== layer && FastClick.attach(layer);
        }
        new ActiveText.Style().init();
    }
    function teardown() {
        $(api).off(ActiveText.Events.RESOURCES_LOADED, init), $(api).off(ActiveText.Events.RESOURCES_ERROR, init), 
        $(options.containerElement).off("remove", teardown), api.ready = !1, api = void 0;
    }
    var api = {
        init: init,
        ready: !1,
        options: options,
        behaviours: void 0,
        navigation: void 0,
        model: void 0,
        utils: void 0,
        data: void 0,
        loader: void 0,
        view: void 0,
        theme: void 0,
        constants: void 0,
        version: void 0,
        extensions: void 0
    };
    // auto-init when the resources are loaded
    return attachClassDependencies(), initClassDependencies(), $(api).on(ActiveText.Events.RESOURCES_LOADED, init), 
    $(api).on(ActiveText.Events.RESOURCES_ERROR, init), options && options.containerElement && $(options.containerElement).on("remove", teardown), 
    $(api).trigger(ActiveText.Commands.INIT_WHITEBOARD), api;
};

/* global ActiveText */
ActiveText.namespace = function(str, root) {
    "use strict";
    str || (str = "");
    var chunks = str.split(".");
    root || (root = window), $.browser.msie && parseInt($.browser.version, 10) < 9 && (window.hasOwnProperty = function(obj) {
        return this[obj] ? !0 : !1;
    });
    for (var current = root, i = 0; i < chunks.length; i++) current.hasOwnProperty(chunks[i]) || (current[chunks[i]] = {}), 
    current = current[chunks[i]];
    return current;
}, /* global ActiveText*/
/**
 * @class Constants
 * @memberOf ActiveText
 * @type {{BLANK_PAGE_CONTENT: string, USE_LOCAL_CACHE: boolean}}
 */
ActiveText.Constants = {
    /**
     * @const
     * @type {string}
     */
    BLANK_PAGE_CONTENT: "<html><head></head><body>&nbsp;</body></html>",
    /**
     * @const
     * @type {boolean}
     */
    USE_LOCAL_CACHE: !0 && !$.browser.msie && !/phantom/i.test(navigator.userAgent) && "file:" !== window.location.protocol
}, /* global ActiveText */
ActiveText.version = function() {
    "use strict";
    return {
        string: "v1.85.8:0",
        major: "1",
        minor: "85",
        hotfix: "8",
        build: "0"
    };
}(), /* global ActiveText, namespace */
/**
 * @class Settings
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{init: init, getFirstPageIsLeft: getFirstPageIsLeft, setFirstPageIsLeft: setFirstPageIsLeft, getNumberingOffset: getNumberingOffset, setNumberingOffset: setNumberingOffset}}
 * @constructor
 */
ActiveText.Settings = function(activeTextInstance) {
    "use strict";
    function init() {
        setFirstPageIsLeft(activeTextInstance && activeTextInstance.options ? void 0 === activeTextInstance.options.firstPageIsLeft ? activeTextInstance.options.numberingOffset % 2 === 0 : activeTextInstance.options.firstPageIsLeft === !0 : !1);
        var parsedNumber;
        activeTextInstance && activeTextInstance.options && (parsedNumber = parseInt(activeTextInstance.options.numberingOffset, 10)), 
        setNumberingOffset(parsedNumber);
    }
    function setFirstPageIsLeft(value) {
        firstPageIsLeft = Boolean(value), $(activeTextInstance).trigger(ActiveText.Settings.Events.UPDATED, {
            key: "firstPageIsLeft",
            value: firstPageIsLeft
        });
    }
    function setNumberingOffset(value) {
        numberingOffset = parseInt(value, 10), numberingOffset = isNaN(numberingOffset) ? 1 : numberingOffset, 
        $(activeTextInstance).trigger(ActiveText.Settings.Events.UPDATED, {
            key: "numberingOffset",
            value: numberingOffset
        });
    }
    /**
     * @type {boolean}
     */
    var firstPageIsLeft = !1, numberingOffset = 1;
    return {
        init: init,
        getFirstPageIsLeft: function() {
            return firstPageIsLeft;
        },
        setFirstPageIsLeft: setFirstPageIsLeft,
        getNumberingOffset: function() {
            return numberingOffset;
        },
        setNumberingOffset: setNumberingOffset
    };
}, /* global ActiveText, namespace */
/**
 * @class Events
 * @memberOf ActiveText.Settings
 * @type {{LOADED: string, LOAD_ERROR: string, UPDATED: string}}
 * @const
 */
ActiveText.Settings.Events = {
    LOADED: "activetext.settings.loaded",
    LOAD_ERROR: "activetext.settings.loaderror",
    UPDATED: "activetext.settings.updated"
}, /* global ActiveText, ActiveText, Modernizr */
/**
 * @class Style
 * @memberOf ActiveText
 * @returns {{init: embedCSSStyles}}
 * @constructor
 */
ActiveText.Style = function() {
    "use strict";
    function embedCSSStyles() {
        var isOldVersionOfMSIE = $.browser.msie && parseInt($.browser.version, 10) < 10, displayVal = isOldVersionOfMSIE ? "none" : "block", ctpHover = Modernizr.rgba ? "background:rgba(255,255,0,0.4);fill:rgba(255,255,0,0.4);" : "border:1px solid yellow;", targetAreaDefaultHover = Modernizr.rgba ? "background:rgba(237,0,140,0.4);fill:rgba(237,0,140,0.6);border:3px solid rgb(237,0,140) !important;stroke-width:4px;stroke:rgb(237,0,140);" : "border:3px solid rgb(237,0,140);", targetAreaDefaultActive = Modernizr.rgba ? "background:rgba(237,0,140,0.1);fill:rgba(237,0,140,0.2);border:3px solid rgb(237,0,140) !important;stroke-width:4px;stroke:rgb(237,0,140);" : "border:3px solid rgb(237,0,140);";
        targetAreaDefaultHover = Modernizr.touch ? "" : targetAreaDefaultHover;
        var cssStr = ".view-loader-overlay{display:" + displayVal + ";top:0;left:0;width:100%;height:100%;background:white;z-index:1000;position:absolute;-webkit-transition:opacity 0.5s linear;-moz-transition:opacity 0.5s linear;transition:opacity 0.5s linear;pointer-events:none;}* {-webkit-box-sizing: border-box;-moz-box-sizing: border-box;box-sizing: border-box;}.character-selected {" + targetAreaDefaultActive + "}.ctp:hover {" + ctpHover + "}.charSelect polygon:hover,.charSelect img:hover {" + targetAreaDefaultHover + '}.activetext [aria-hidden="true"] { visibility: hidden; }';
        ActiveText.CSSUtils.embedCSS(cssStr, "activetext-main");
    }
    return {
        init: embedCSSStyles
    };
}, /* global ActiveText */
/**
 * @class Data
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{init: init, getFlatListOfNavigation: getFlatListOfNavigation, getNavigationStructure: getNavigationStructure, getMetaData: getMetaData}}
 * @constructor
 */
ActiveText.Data = function(activeTextInstance) {
    "use strict";
    function init() {
        $(activeTextInstance).on(ActiveText.Events.BOOK_STRUCTURE_LOADED, storeProductPagesAPIResponse), 
        $(activeTextInstance).on(ActiveText.Events.NAVMAP_LOADED, storeNavMapAPIResponse), 
        $(activeTextInstance).on(ActiveText.Events.OPF_META_LOADED, storeOPFMetaDataAPIResponse), 
        activeTextInstance.options && activeTextInstance.options.containerElement && $(activeTextInstance.options.containerElement).on("remove", teardown);
    }
    function teardown() {
        $(activeTextInstance).off(ActiveText.Events.BOOK_STRUCTURE_LOADED, storeProductPagesAPIResponse), 
        $(activeTextInstance).off(ActiveText.Events.NAVMAP_LOADED, storeNavMapAPIResponse), 
        $(activeTextInstance).off(ActiveText.Events.OPF_META_LOADED, storeOPFMetaDataAPIResponse), 
        $(activeTextInstance.options.containerElement).off("remove", teardown), flatListCache = void 0, 
        nestedListCache = void 0, rawNavMapCache = void 0, rawNavMapCache = void 0, OPFMetaData = void 0;
    }
    function isValidAPIResponse(response) {
        return !(!response || !response.length);
    }
    // todo: Bad name
    function recursiveParseItem(item, rtn) {
        var newElement = {};
        if (newElement.title = item.title, newElement.src = ActiveText.DataUtils.correctURLPath(activeTextInstance, item.html_location), 
        newElement.id = item.id, newElement.number = item.number, rtn.push(newElement), 
        void 0 !== item.children && $.isArray(item.children) && item.children.length > 0) {
            for (var subnav = [], i = 0, len = item.children.length; len > i; i++) recursiveParseItem(item.children[i], subnav);
            rtn.push(subnav);
        }
    }
    // todo: Bad name
    function parseAPIResponse(response) {
        var rtn = [];
        if (response && isValidAPIResponse(response)) for (var i = 0; i < response.length; i++) {
            var item = response[i];
            recursiveParseItem(item, rtn);
        }
        return rtn;
    }
    function getFlatListOfNavigation() {
        var rtn;
        return (void 0 === flatListCache || 0 === flatListCache.length) && (flatListCache = parseAPIResponse(rawFlatPagesCache)), 
        rtn = flatListCache;
    }
    function storeProductPagesAPIResponse(event, data) {
        rawFlatPagesCache = data, $(activeTextInstance).trigger(ActiveText.Events.RESOURCES_LOADED, rawFlatPagesCache);
    }
    function storeNavMapAPIResponse(event, data) {
        rawNavMapCache = data;
    }
    function storeOPFMetaDataAPIResponse(event, data) {
        OPFMetaData = data;
    }
    function getNavigationStructure() {
        var rtn;
        return (void 0 === nestedListCache || 0 === nestedListCache.length) && (nestedListCache = parseAPIResponse(rawNavMapCache)), 
        rtn = nestedListCache;
    }
    function getMetaData() {
        var rtn;
        return (null !== OPFMetaData || void 0 !== OPFMetaData) && (rtn = OPFMetaData), 
        rtn;
    }
    var flatListCache, nestedListCache, rawNavMapCache, rawFlatPagesCache, OPFMetaData;
    return {
        init: init,
        getFlatListOfNavigation: getFlatListOfNavigation,
        getNavigationStructure: getNavigationStructure,
        getMetaData: getMetaData
    };
}, /* global ActiveText */
/**
 * @class Events
 * @memberOf ActiveText
 * @type {{REFRESH: string, BOOK_STRUCTURE_LOADED: string, CONTAINER_XML_LOADED: string, OPF_DATA_LOADED: string, OPF_META_LOADED: string, NAVMAP_LOADED: string, RESOURCES_LOADED: string, RESOURCES_ERROR: string, RESIZE: string, CHANGE_SCALING_MODE: string, ANIMATE_PAGE: string, ANIMATE_PAGE_START: string, ANIMATE_PAGE_END: string, FRAME_CREATED: string, FRAME_CONTENT_LOADED: string, FRAME_CONTENT_ERROR: string, LOADED_OVERLAY_DATA: string, OVERLAY_DATA_FAIL: string, VIEW_MODE_CHANGED: string, LOADED_NOTES_FOR_INDEX: string, AUDIO_HIGHLIGHT_PAUSED: string}}
 */
ActiveText.Events = {
    REFRESH: "refresh.activetext.events",
    BOOK_STRUCTURE_LOADED: "bookstructureloaded.activetext.events",
    CONTAINER_XML_LOADED: "containerxmlloaded.activetext.events",
    OPF_DATA_LOADED: "opfdataloaded.activetext.events",
    OPF_META_LOADED: "opfmetaloaded.activetext.events",
    NAVMAP_LOADED: "navmaploaded.activetext.events",
    RESOURCES_LOADED: "resourcesloaded.activetext.events",
    RESOURCES_ERROR: "resourceserror.activetext.events",
    RESIZE: "resize_at.activetext.events",
    CHANGE_SCALING_MODE: "changeScalingMode.activetext.events",
    ANIMATE_PAGE: "animatepageturn.activetext.events",
    ANIMATE_PAGE_START: "animatepagestart.activetext.events",
    ANIMATE_PAGE_END: "animatepageend.activetext.events",
    FRAME_CREATED: "framecreated.activetext.events",
    FRAME_CONTENT_LOADED: "framecontentloaded.activetext.events",
    FRAME_CONTENT_ERROR: "framecontenterror.activetext.events",
    LOADED_OVERLAY_DATA: "loadedoverlaydata.activetext.events",
    OVERLAY_DATA_FAIL: "overlaydatafail.activetext.events",
    VIEW_MODE_CHANGED: "viewmodechange.activetext.events",
    LOADED_NOTES_FOR_INDEX: "haveNotesDataForIndex",
    AUDIO_HIGHLIGHT_PAUSED: "audiohighlightpaused",
    UI_ELEMENT_CLICKED: "uielementclicked",
    UI_ELEMENT_LOADED: "uielementloaded"
}, /* global ActiveText */
/**
 * @class Commands
 * @memberOf ActiveText
 * @type {{GO_TO_PAGE: string, LOAD_PAGES_AT_INDEX: string, LOAD_PAGE_BY_INDEX: string, LOAD_RESOURCE_FOR_CURRENT_INDEX: string, SWITCH_TO_DPS_VIEW: string, SWITCH_TO_SPS_VIEW: string, SWITCH_TO_SPS_FTW_VIEW: string, SWITCH_TO_ZOOM_MODE: string, LOAD_RESOURCES: string, INIT_WHITEBOARD: string, DISPLAY_ERROR: string, ENABLE_PAGE_DRAGGING: string, SHOW_LOADER: string, HIDE_LOADER: string}}
 */
ActiveText.Commands = {
    GO_TO_PAGE: "goToPage.activetext.commands",
    LOAD_PAGES_AT_INDEX: "loadPagesAtIndex.activetext.commands",
    LOAD_PAGE_BY_INDEX: "loadPageByIndex.activetext.commands",
    LOAD_RESOURCE_FOR_CURRENT_INDEX: "loadResourcesForCurrentIndex.activetext.commands",
    SWITCH_TO_DPS_VIEW: "switchToDPSView.activetext.commands",
    SWITCH_TO_SPS_VIEW: "switchToSinglePageView.activetext.commands",
    SWITCH_TO_SPS_FTW_VIEW: "switchToSinglePageFitToWidthView.activetext.commands",
    SWITCH_TO_ZOOM_MODE: "switchToZoomMode.activetext.commands",
    LOAD_RESOURCES: "loadresources.activetext.commands",
    INIT_WHITEBOARD: "initwhiteboard.activetext.commands",
    DISPLAY_ERROR: "displayError.activetext.commands",
    ENABLE_PAGE_DRAGGING: "enablePageDragging.activetext.commands",
    DISABLE_PAGE_DRAGGING: "disablePageDragging.activetext.commands",
    SHOW_LOADER: "activetext.showloader",
    HIDE_LOADER: "activetext.hideloader"
}, /* global ActiveText, ActiveText, fastdom */
/**
 * @class Loader
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{init: init, getDataProvider: getDataProvider, hasLoadedAllResourcesForDisplayedPages: hasLoadedAllResourcesForDisplayedPages, hasLoadedAllResourcesForPage: hasLoadedAllResourcesForPage, loadNextDPS: loadNextDPS, loadPrevDPS: loadPrevDPS, addItemToQueue: addItemToQueue, removeItemFromQueue: removeItemFromQueue}}
 * @constructor
 */
ActiveText.Loader = function(activeTextInstance) {
    "use strict";
    function init() {
        var preloader = new ActiveText.ContentPreloader(activeTextInstance);
        preloader.init(), activeQueue = [], deferredQueue = [], $.support.cors = !0;
        var signalBus = $(activeTextInstance);
        signalBus.on(ActiveText.Commands.LOAD_PAGES_AT_INDEX, loadPagesAtIndex), signalBus.on(ActiveText.Commands.LOAD_RESOURCES, loadResourcesFromProviders), 
        signalBus.on(ActiveText.Commands.LOAD_PAGE_BY_INDEX, loadPageByIndex);
    }
    function loadResourcesFromProviders() {
        var dataProvider = getDataProvider();
        dataProvider && dataProvider.getSpineData();
    }
    function getDataProvider() {
        return activeTextInstance && !internalDataProvider && (activeTextInstance.options && "function" == typeof window[activeTextInstance.options.dataProvider] ? internalDataProvider = new window[activeTextInstance.options.dataProvider](activeTextInstance) : activeTextInstance.options && "function" == typeof activeTextInstance.options.dataProvider ? internalDataProvider = new activeTextInstance.options.dataProvider(activeTextInstance) : ActiveText && ActiveText.DataProvider && "function" == typeof ActiveText.DataProvider ? internalDataProvider = new ActiveText.DataProvider(activeTextInstance) : $(activeTextInstance).trigger(ActiveText.Commands.DISPLAY_ERROR, "DataProvider is not defined.")), 
        internalDataProvider;
    }
    function hasCachedVersionOfContentForURL(url) {
        return void 0 !== loaderCache[url];
    }
    //    function removeLoaderFromTargetFrame(index) {
    //        $(activeTextInstance).trigger(ActiveText.Events.FRAME_CONTENT_LOADED, {
    //            index: index
    //        });
    //    }
    /**
     * @param target
     * @returns {boolean}
     */
    function contentContainersHaveNotBeenGeneratedForPage(target) {
        return 0 === $(target).children("div.iframe").length;
    }
    function insertContent(target, index, sourceURL) {
        //        removeLoaderFromTargetFrame(index);
        var response = loaderCache[sourceURL];
        if (contentContainersHaveNotBeenGeneratedForPage(target)) {
            var iframeContainerElement = ActiveText.ViewFactory.createPageContentsWithURL(activeTextInstance, sourceURL, index);
            target.find(".spinner").remove(), iframeContainerElement.prependTo(target), $(activeTextInstance).trigger(ActiveText.Events.RESIZE);
        }
        $(activeTextInstance).trigger(ActiveText.Commands.LOAD_RESOURCE_FOR_CURRENT_INDEX, {
            data: response,
            baseURL: sourceURL
        }), $(activeTextInstance).trigger(ActiveText.Events.FRAME_CONTENT_LOADED, {
            index: index
        });
    }
    function parsePageDimensions(data) {
        var metadataTag = data.match(/<meta name=['|']viewport['|'] content=['|'](.*)['|'][ ]?[\/]?>/i);
        if (metadataTag && metadataTag[1]) {
            for (var pageSettings = {}, keyPairs = metadataTag[1].split(","), i = 0; i < keyPairs.length; i++) {
                var trimmedKeyPair = keyPairs[i].replace(/^\s+|\s+$/g, ""), keyPair = trimmedKeyPair.split("=");
                pageSettings[keyPair[0]] = parseInt(keyPair[1], 10);
            }
            pageSettings.aspectRatio = pageSettings.width / pageSettings.height, activeTextInstance.view.model.setPageDimensions(pageSettings);
        } else {
            var matcher = data.match(/<div id='stop-overflow' style='width:(.*?)px; height:(.*?)px; overflow: hidden;'>/i);
            if (matcher) {
                var width = matcher[1], height = matcher[2];
                activeTextInstance.view.model.setPageDimensions({
                    width: width,
                    height: height,
                    aspectRatio: width / height
                });
            }
        }
    }
    function extractDimensionsWithoutAffectingHTML(data) {
        if (data.replace) {
            var correctedResponse = ActiveText.LoaderUtils.correctPointsToPixels(data);
            parsePageDimensions(correctedResponse);
        }
    }
    function loadPageContents(sourceURL, targetFrame, index) {
        function parsePageContentsAndInsert(data) {
            extractDimensionsWithoutAffectingHTML(data), loaderCache[sourceURL] = data, insertContent(targetFrame, index, sourceURL);
        }
        function displayLoadErrorForPage(xmlHttpRequest) {
            if (0 !== xmlHttpRequest.readyState && 0 !== xmlHttpRequest.status) /**
                 * If you see this error, you should REALLY go check whether your server is configured to allow
                 * CORS requests. http://bionicspirit.com/blog/2011/03/24/cross-domain-requests.html
                 *
                 * Seriously, go do it now.
                 */
            $(activeTextInstance).trigger(ActiveText.Events.FRAME_CONTENT_ERROR, {
                index: index
            }); else switch (window.location.protocol) {
              case "http:":
              case "https:":
                //remote file over http or https
                -1 === sourceURL.indexOf("cachebuster") ? setTimeout(function() {
                    getContentForFrame(sourceURL + "?cachebuster=" + Math.random(), targetFrame, index);
                }, 100) : $(activeTextInstance).trigger(ActiveText.Events.FRAME_CONTENT_ERROR, {
                    index: index
                });
                break;

              case "file:":
                //local file
                insertContent(targetFrame, index, sourceURL);
            }
        }
        switch (window.location.protocol) {
          case "http:":
          case "https:":
            //remote file over http or https
            $.browser.msie ? insertContent(targetFrame, index, sourceURL) : $.ajax({
                type: "GET",
                url: sourceURL,
                contentType: "text/plain",
                crossDomain: !0,
                success: parsePageContentsAndInsert,
                error: displayLoadErrorForPage
            });
            break;

          case "file:":
            //local file
            insertContent(targetFrame, index, sourceURL);
        }
    }
    function getContentForFrame(sourceURL, targetFrame, index) {
        if (hasCachedVersionOfContentForURL(sourceURL)) insertContent(targetFrame, index, sourceURL), 
        $(activeTextInstance).trigger(ActiveText.Events.FRAME_CONTENT_LOADED, {
            index: index
        }); else if (ActiveText.LoaderUtils.sourceURLIsValid(sourceURL)) loadPageContents(sourceURL, targetFrame, index); else {
            if (targetFrame) {
                var iframeContainerElement = $('<div class="iframe"></div>').css({
                    position: "absolute",
                    background: "white"
                });
                iframeContainerElement.prependTo(targetFrame), targetFrame.find(".spinner").remove();
            }
            $(activeTextInstance).trigger(ActiveText.Events.FRAME_CONTENT_LOADED, {
                index: index
            });
        }
    }
    function loadPagesAtIndex(event, startIndex) {
        if (ActiveText.ViewUtils.isSinglePageView(activeTextInstance)) $(activeTextInstance).trigger(ActiveText.Commands.LOAD_PAGE_BY_INDEX, {
            index: startIndex
        }); else {
            var leftPageIndex = ActiveText.NavigationUtils.calculateLeftmostPageIndexFromIndex(activeTextInstance, startIndex);
            $(activeTextInstance).trigger(ActiveText.Commands.LOAD_PAGE_BY_INDEX, {
                index: leftPageIndex
            }), $(activeTextInstance).trigger(ActiveText.Commands.LOAD_PAGE_BY_INDEX, {
                index: leftPageIndex + 1
            });
        }
    }
    function loadPageByIndex(event, data) {
        var index = data.index, targetFrame = ActiveText.ViewUtils.getFrameForPageByIndex(activeTextInstance, index), sourceURL = activeTextInstance.utils.getSourcePathForIndex(index);
        getContentForFrame(sourceURL, targetFrame, index);
    }
    function hasLoadedAllResourcesForDisplayedPages(index) {
        var isLeftPage = ActiveText.NavigationUtils.isLeftPage(activeTextInstance, index), leftPage = isLeftPage ? index : index - 1, rightPage = isLeftPage ? index + 1 : index;
        return $.when(hasLoadedAllResourcesForPage(leftPage), hasLoadedAllResourcesForPage(rightPage));
    }
    function hasLoadedAllResourcesForPage(index) {
        for (var currentItem, deferred = $.Deferred(), rtn = !0, i = 0, l = activeQueue.length; l > i; i++) currentItem = activeQueue[i], 
        currentItem.index === index && (rtn = !1);
        return deferredQueue[index] = deferred, rtn ? setTimeout(function() {
            deferred.resolve(index);
        }, 0) : deferredQueue[index] && deferredQueue[index].resolve(index), deferred;
    }
    function loadNextDPS() {
        var currentIndex = activeTextInstance.model.getCurrentIndex();
        $(activeTextInstance).trigger(ActiveText.Commands.LOAD_PAGES_AT_INDEX, [ currentIndex + 2 ]);
    }
    function loadPrevDPS() {
        var currentIndex = activeTextInstance.model.getCurrentIndex();
        $(activeTextInstance).trigger(ActiveText.Commands.LOAD_PAGES_AT_INDEX, [ currentIndex - 2 ]);
    }
    function addItemToQueue(item) {
        activeQueue.push(item);
    }
    function removeItemFromQueue(item) {
        for (var i = 0, l = activeQueue.length; l > i; i++) activeQueue[i].index === item.index && activeQueue.slice(i, 1);
        deferredQueue[item.index] && deferredQueue[item.index].resolve(item.index);
    }
    /**
     * @type {object}
     */
    var internalDataProvider, activeQueue, deferredQueue, loaderCache = {};
    return {
        init: init,
        getDataProvider: getDataProvider,
        hasLoadedAllResourcesForDisplayedPages: hasLoadedAllResourcesForDisplayedPages,
        hasLoadedAllResourcesForPage: hasLoadedAllResourcesForPage,
        loadNextDPS: loadNextDPS,
        loadPrevDPS: loadPrevDPS,
        addItemToQueue: addItemToQueue,
        removeItemFromQueue: removeItemFromQueue
    };
}, /* global ActiveText */
/**
 * @class ContentPreloader
 * @memberOf ActiveText
 * @returns {{init: init}}
 * @constructor
 */
ActiveText.ContentPreloader = function(activeTextInstance) {
    "use strict";
    function init() {
        function teardown() {
            $(activeTextInstance.options.containerElement).off("remove", teardown), signalBus.off(ActiveText.Commands.LOAD_RESOURCE_FOR_CURRENT_INDEX, parseAndPreloadContent);
        }
        var signalBus = $(activeTextInstance);
        signalBus.on(ActiveText.Commands.LOAD_RESOURCE_FOR_CURRENT_INDEX, parseAndPreloadContent), 
        activeTextInstance.options && activeTextInstance.options.containerElement && $(activeTextInstance.options.containerElement).on("remove", teardown);
    }
    function parseAndPreloadContent(event, obj) {
        if (obj && document.images) {
            var rawData = obj.data, baseURL = obj.baseURL;
            if (rawData) {
                var results = /<img.+?src=["|'](.+?)["|'].+?\/?>/gi.exec(rawData);
                if (results) {
                    var message = results[1], preloadObj = new Image(), pathAsArray = baseURL.split("/");
                    pathAsArray.pop();
                    var path = pathAsArray.join("/");
                    preloadObj.src = path + "/" + message;
                }
            }
        }
    }
    return {
        init: init
    };
}, /* global ActiveText */
ActiveText.Navigation = ActiveText.Navigation || {}, /**
 * @class Model
 * @memberOf ActiveText.Navigation
 * @param activeTextInstance {ActiveText}
 * @type {{init: init, getCurrentPageNumber: getCurrentPageNumber, setCurrentIndex: setCurrentIndex, getCurrentIndex: getCurrentIndex}}
 * @constructor
 */
ActiveText.Navigation.Model = function(activeTextInstance) {
    "use strict";
    function getCurrentIndex() {
        return currentIndex;
    }
    function setCurrentIndex(value) {
        return currentIndex = parseInt(value, 10);
    }
    function parseDefaults() {
        var defaults = activeTextInstance && activeTextInstance.options && activeTextInstance.options.defaults ? activeTextInstance.options.defaults : defaultValues;
        for (var prop in defaultValues) void 0 === defaults[prop] && (defaults[prop] = defaultValues[prop]);
    }
    function init() {
        $(activeTextInstance).one(ActiveText.Events.RESOURCES_LOADED, initialiseCurrentIndexValueFromOptions);
    }
    function initialiseCurrentIndexValueFromOptions() {
        var initialPageIndex, utils = activeTextInstance.utils;
        initialPageIndex = activeTextInstance.options.initialPageId ? utils.getPageNumberFromId(activeTextInstance.options.initialPageId) : activeTextInstance.options.initialPageNumber ? ActiveText.NavigationUtils.pageNumberToPageIndex(activeTextInstance, activeTextInstance.options.initialPageNumber) : ActiveText.NavigationUtils.getMinimumValidPageIndex(activeTextInstance), 
        activeTextInstance.navigation.gotoPage(ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, initialPageIndex), !0);
    }
    function getCurrentPageNumber() {
        return activeTextInstance && activeTextInstance.utils ? ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, currentIndex) : currentIndex;
    }
    /**
     * @type {number}
     */
    var currentIndex = 0, defaultValues = {};
    return parseDefaults(), {
        init: init,
        getCurrentPageNumber: getCurrentPageNumber,
        setCurrentIndex: setCurrentIndex,
        getCurrentIndex: getCurrentIndex
    };
}, /* global ActiveText */
/**
 * @class Utils
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @type {{isFullWindowScalingMode: isFullWindowScalingMode, getPageNumberFromId: getPageNumberFromId, getReaderDPSWidth: getReaderDPSWidth, updatePageClassNameFor: updatePageClassNameFor, getSourcePathForIndex: getSourcePathForIndex}}
 * @constructor
 */
ActiveText.Utils = function(activeTextInstance) {
    "use strict";
    function isFullWindowScalingMode() {
        return activeTextInstance && activeTextInstance.options && activeTextInstance.options.defaults && activeTextInstance.options.defaults.wmode ? "fullscreen" === activeTextInstance.options.defaults.wmode : !1;
    }
    function closeWidgetTrigger() {
        parent.window.$(".ui-dialog-titlebar-close").trigger("click");
    }
    function getPageNumberFromId(id) {
        for (var rtn, allPages = activeTextInstance.data.getFlatListOfNavigation(), i = 0; i < allPages.length; i++) if (parseInt(allPages[i].id, 10) === parseInt(id, 10)) {
            rtn = i;
            break;
        }
        return rtn;
    }
    function getReaderDPSWidth() {
        return ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance).dpswidth;
    }
    function updatePageClassNameFor(index) {
        return Boolean(1 === Math.abs(index % 2)) === !activeTextInstance.settings.getFirstPageIsLeft() ? "leftPage" : "rightPage";
    }
    function getSourcePathForIndex(index) {
        var rtn, pages = activeTextInstance.data.getFlatListOfNavigation();
        try {
            rtn = pages[index].src;
        } catch (e) {
            rtn = "about:blank";
        }
        return rtn;
    }
    return {
        isFullWindowScalingMode: isFullWindowScalingMode,
        getPageNumberFromId: getPageNumberFromId,
        getReaderDPSWidth: getReaderDPSWidth,
        updatePageClassNameFor: updatePageClassNameFor,
        getSourcePathForIndex: getSourcePathForIndex,
        closeWidgetTrigger: closeWidgetTrigger
    };
}, /* global ActiveText */
ActiveText.namespace("ActiveText.SkinUtils"), ActiveText.SkinUtils = function() {
    "use strict";
    function getPathToResources(activeTextInstance) {
        var rtn = "/";
        if (activeTextInstance && activeTextInstance.options && "string" == typeof activeTextInstance.options.resourcesPath) rtn = activeTextInstance.options.resourcesPath; else switch (window.location.protocol) {
          case "http:":
          case "https:":
            //remote file over http or https
            rtn = "/static/";
            break;

          case "file:":
            //local file
            rtn = "";
        }
        return rtn;
    }
    function getPathToGlobalResource() {
        var rtn = "/";
        switch (window.location.protocol) {
          case "http:":
          case "https:":
            //remote file over http or https
            rtn = window.location.protocol + "//activetext-storage.s3.amazonaws.com/lib/";
            break;

          case "file:":
            rtn = "";
        }
        return rtn;
    }
    return {
        getPathToResources: getPathToResources,
        getPathToGlobalResource: getPathToGlobalResource
    };
}(), /* global ActiveText */
ActiveText.ResizeUtils = function(ActiveText) {
    "use strict";
    function getProportionalResizeBehaviour(activeTextInstance, layerKey) {
        return function() {
            //changed l=view.model.getDisplayedPages() to l=2 as we always need to scale both pages to avoid hotspot creep
            for (var overlayWrapperElement, model = activeTextInstance.model, currentIndex = (activeTextInstance.view, 
            model.getCurrentIndex()), scale = ActiveText.ViewUtils.getScaleValue(activeTextInstance), dpsDimensions = ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance), magnificationValue = activeTextInstance.view.model.getMagnificationValue(), svgWidth = dpsDimensions.dpswidth / 2, svgHeight = dpsDimensions.height, i = 0, l = 2; l > i; i++) overlayWrapperElement = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, currentIndex + i, layerKey), 
            overlayWrapperElement && (overlayWrapperElement.width(svgWidth * scale).height(svgHeight * scale), 
            ActiveText.ViewUtils.scaleHTMLElement(activeTextInstance, overlayWrapperElement, 1 / scale * magnificationValue));
        };
    }
    function getNonProportionalResizeBehaviour(activeTextInstance, layerKey) {
        return function() {
            //changed l=view.model.getDisplayedPages() to l=2 as we always need to scale both pages to avoid hotspot creep
            for (var overlayWrapperElement, model = (activeTextInstance.view, activeTextInstance.model), currentIndex = model.getCurrentIndex(), dpsDimensions = ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance), svgWidth = dpsDimensions.dpswidth / 2, svgHeight = dpsDimensions.height, i = 0, l = 2; l > i; i++) overlayWrapperElement = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, currentIndex + i, layerKey), 
            overlayWrapperElement && overlayWrapperElement.width(svgWidth).height(svgHeight);
        };
    }
    return {
        getProportionalResizeBehaviour: getProportionalResizeBehaviour,
        getNonProportionalResizeBehaviour: getNonProportionalResizeBehaviour
    };
}(ActiveText), /* global ActiveText */
/**
 * @class BrowserUtils
 * @memberOf ActiveText
 * @type {{isOldVersionOfInternetExplorer: boolean, isMobileDevice: boolean}}
 */
ActiveText.BrowserUtils = function() {
    "use strict";
    function isOldVersionOfInternetExplorer() {
        return $.browser.msie && parseInt($.browser.version, 10) < 9;
    }
    function IEVersion() {
        var version = !1;
        return $.browser.msie && (version = parseInt($.browser.version, 10)), version;
    }
    function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(window.navigator.userAgent);
    }
    function iOSversion() {
        var ver = !1;
        if (/iP(hone|od|ad)/.test(navigator.platform)) {
            var v = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
            ver = [ parseInt(v[1], 10), parseInt(v[2], 10), parseInt(v[3] || 0, 10) ];
        }
        return ver;
    }
    return {
        isOldVersionOfInternetExplorer: isOldVersionOfInternetExplorer(),
        isMobileDevice: isMobileDevice(),
        IEVersion: IEVersion(),
        iOSversion: iOSversion()
    };
}(), /* global ActiveText */
/**
 * @class ExtensionUtils
 * @memberOf ActiveText
 * @returns {{getExtensionByKey:function, getAudioPlayback:function}}
 */
ActiveText.ExtensionUtils = function() {
    "use strict";
    function getExtensionByKey(activeTextInstance, key) {
        var rtn, extension;
        if (activeTextInstance && activeTextInstance.extensions && $.isArray(activeTextInstance.extensions)) for (var i = 0, l = activeTextInstance.extensions.length; l > i; i++) extension = activeTextInstance.extensions[i], 
        extension.key === key && (rtn = extension);
        return rtn;
    }
    /**
     * @param {ActiveText} activeTextInstance
     * @returns {ActiveText.AudioPlayback}
     */
    function getAudioPlayback(activeTextInstance) {
        var rtn = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "audioplayback");
        return rtn || (rtn = new ActiveText.AudioPlayback(), rtn.init(activeTextInstance), 
        activeTextInstance.extensions || (activeTextInstance.extensions = []), activeTextInstance.extensions.push(rtn)), 
        rtn;
    }
    return {
        getExtensionByKey: getExtensionByKey,
        getAudioPlayback: getAudioPlayback
    };
}(), /* global ActiveText */
ActiveText.namespace("ActiveText.NavigationUtils"), ActiveText.NavigationUtils = function() {
    "use strict";
    function getMinimumValidPageIndex(activeTextInstance) {
        return ActiveText.ViewUtils.isSinglePageView(activeTextInstance) ? 0 : activeTextInstance.settings.getFirstPageIsLeft() ? 0 : -1;
    }
    function getMaximumValidPageIndex(activeTextInstance) {
        var pages = activeTextInstance.data.getFlatListOfNavigation();
        return pages.length - 1;
    }
    function pageIndexToPageNumber(activeTextInstance, index) {
        return activeTextInstance.settings.getNumberingOffset() + parseInt(index, 10);
    }
    function pageNumberToPageIndex(activeTextInstance, number) {
        return parseInt(number, 10) - activeTextInstance.settings.getNumberingOffset();
    }
    function isValidPageIndex(activeTextInstance, index) {
        var minimumValidIndex = getMinimumValidPageIndex(activeTextInstance), maximumValidIndex = getMaximumValidPageIndex(activeTextInstance), indexIsLessThanTheMinimum = minimumValidIndex > index, indexIsGreaterThanTheMaximum = index > maximumValidIndex;
        return !(indexIsLessThanTheMinimum || indexIsGreaterThanTheMaximum);
    }
    function getNearestValidPageIndexFromIndex(activeTextInstance, index) {
        var currentIndex = activeTextInstance.model.getCurrentIndex(), minimumValidIndex = getMinimumValidPageIndex(activeTextInstance), maximumValidIndex = getMaximumValidPageIndex(activeTextInstance), parsedIndex = parseInt(index, 10);
        return isNaN(parsedIndex) ? currentIndex : isValidPageIndex(activeTextInstance, parsedIndex) ? parsedIndex : index > maximumValidIndex ? getMaximumValidPageIndex(activeTextInstance) : minimumValidIndex > index ? getMinimumValidPageIndex(activeTextInstance) : currentIndex;
    }
    function calculateLeftmostPageIndexFromIndex(activeTextInstance, index) {
        return index = getNearestValidPageIndexFromIndex(activeTextInstance, index), isLeftPageIndex(activeTextInstance, index) ? index : index - 1;
    }
    function getSiblingPageNumberForPageNumber(activeTextInstance, pageNumber) {
        var index = pageNumberToPageIndex(activeTextInstance, pageNumber);
        return isLeftPageIndex(activeTextInstance, index) ? pageNumber + 1 : pageNumber - 1;
    }
    /**
     * @param index {number}
     * @return {Boolean}
     */
    function isLeftPageIndex(activeTextInstance, index) {
        return activeTextInstance.settings.getFirstPageIsLeft() ? index % 2 === 0 : 1 === Math.abs(index % 2);
    }
    return {
        isLeftPage: isLeftPageIndex,
        isValidPageIndex: isValidPageIndex,
        getMinimumValidPageIndex: getMinimumValidPageIndex,
        getMaximumValidPageIndex: getMaximumValidPageIndex,
        pageIndexToPageNumber: pageIndexToPageNumber,
        pageNumberToPageIndex: pageNumberToPageIndex,
        calculateLeftmostPageIndexFromIndex: calculateLeftmostPageIndexFromIndex,
        getNearestValidPageFromIndex: getNearestValidPageIndexFromIndex,
        getSiblingPageNumberForPage: getSiblingPageNumberForPageNumber
    };
}(), /* global ActiveText */
ActiveText.LoaderUtils = function() {
    "use strict";
    function correctPointsToPixels(input) {
        return input.replace(/([0-9]+)pt/g, function(match, group0) {
            return Math.round(96 * parseInt(group0, 10) / 72) + "px";
        });
    }
    function sourceURLIsValid(sourceURL) {
        return -1 === sourceURL.indexOf("about:blank");
    }
    return {
        correctPointsToPixels: correctPointsToPixels,
        sourceURLIsValid: sourceURLIsValid
    };
}(), /* global ActiveText */
ActiveText.namespace("ActiveText.FormattingUtils"), ActiveText.FormattingUtils = function(ActiveText) {
    "use strict";
    function formatPageLabel(activeTextInstance, singlePageFormat, multiPageFormat, pageNumber) {
        var label, minPageNumber = ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, ActiveText.NavigationUtils.getMinimumValidPageIndex(activeTextInstance)), maxPageNumber = ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, ActiveText.NavigationUtils.getMaximumValidPageIndex(activeTextInstance)), firstPageIsLeft = activeTextInstance.settings.getFirstPageIsLeft(), isSinglePageView = ActiveText.ViewUtils.isSinglePageView(activeTextInstance), pageIsLeft = ActiveText.NavigationUtils.isLeftPage(activeTextInstance, ActiveText.NavigationUtils.pageNumberToPageIndex(activeTextInstance, pageNumber)), onlyOnePageIsShowing = isSinglePageView || pageNumber === maxPageNumber && pageIsLeft || pageNumber === minPageNumber && !firstPageIsLeft;
        return label = onlyOnePageIsShowing ? formatSinglePageLabel(activeTextInstance, singlePageFormat, pageNumber) : formatMultiPageLabel(activeTextInstance, multiPageFormat, pageNumber);
    }
    function formatSinglePageLabel(activeTextInstance, singlePageFormat, pageNumber) {
        var label;
        if (-1 !== singlePageFormat.indexOf("%%title%%")) {
            var ebookStructure = activeTextInstance.data.getFlatListOfNavigation(), pageIndex = ActiveText.NavigationUtils.pageNumberToPageIndex(activeTextInstance, pageNumber), validIndex = pageIndex >= 0 ? pageIndex : 0, item = ebookStructure[validIndex];
            label = item ? singlePageFormat.replace("%%title%%", item.title) : singlePageFormat.replace("%%title%%", "");
        } else {
            var firstPageIsLeft = activeTextInstance.settings.getFirstPageIsLeft(), isSinglePageView = ActiveText.ViewUtils.isSinglePageView(activeTextInstance), minPageNumber = ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, ActiveText.NavigationUtils.getMinimumValidPageIndex(activeTextInstance)), maxPageNumber = ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, ActiveText.NavigationUtils.getMaximumValidPageIndex(activeTextInstance));
            pageNumber !== minPageNumber || firstPageIsLeft || isSinglePageView || (pageNumber += 1), 
            label = singlePageFormat.replace("%%1", pageNumber).replace("%%2", maxPageNumber);
        }
        return label;
    }
    function formatMultiPageLabel(activeTextInstance, multiPageFormat, pageNumber) {
        var label;
        if (-1 !== multiPageFormat.indexOf("%%title%%")) {
            var ebookStructure = activeTextInstance.data.getFlatListOfNavigation(), pageIndex = ActiveText.NavigationUtils.pageNumberToPageIndex(activeTextInstance, pageNumber), validIndex = pageIndex >= 0 ? pageIndex : 0, item = ebookStructure[validIndex], itemSibling = ebookStructure[validIndex + 1];
            label = item && itemSibling ? multiPageFormat.replace("%%title%%", item.title).replace("%%title2%%", itemSibling.title) : multiPageFormat.replace("%%title%%", "").replace("%%title2%%", "");
        } else {
            var maxPageNumber = ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, ActiveText.NavigationUtils.getMaximumValidPageIndex(activeTextInstance));
            label = multiPageFormat.replace("%%1", pageNumber).replace("%%2", pageNumber + 1).replace("%%3", maxPageNumber);
        }
        return label;
    }
    return {
        formatPageLabel: formatPageLabel,
        formatSinglePageLabel: formatSinglePageLabel,
        formatMultiPageLabel: formatMultiPageLabel
    };
}(ActiveText), /* global ActiveText, Modernizr */
ActiveText.ViewUtils = function() {
    "use strict";
    function isDoublePageView(activeTextInstance) {
        return Boolean(2 === activeTextInstance.view.model.getDisplayedPages());
    }
    function isSinglePageView(activeTextInstance) {
        return Boolean(1 === activeTextInstance.view.model.getDisplayedPages());
    }
    function isFitToHeightView(activeTextInstance) {
        return "fth" === activeTextInstance.view.model.getScaleMode();
    }
    function isFitToWidthView(activeTextInstance) {
        return "ftw" === activeTextInstance.view.model.getScaleMode();
    }
    function isCardMode(activeTextInstance) {
        return activeTextInstance.view.model.returnCardMode();
    }
    function setOpacityValue(element, value) {
        function setOpacityValueForIE(element, value) {
            if ($.browser.msie) {
                var version = parseInt($.browser.version, 10);
                element.css(7 >= version ? {
                    filter: "alpha(opacity=" + value + ")"
                } : {
                    MsFilter: '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + value + ')"'
                });
            }
        }
        element.css({
            opacity: value
        }), setOpacityValueForIE(element, value);
    }
    function getUnscaledDPSTargetDimensions(activeTextInstance) {
        var pageAspectRatio, pageDimensions = activeTextInstance.view.model.getPageDimensions();
        pageAspectRatio = pageDimensions.height / (pageDimensions.width * activeTextInstance.view.model.getDisplayedPages());
        var readerTargetWidth, readerTargetHeight, isPageLandscape = 1 >= pageAspectRatio, availableDimensions = fetchAvailableDimensions(activeTextInstance), availableWidth = availableDimensions.width, availableHeight = availableDimensions.height, chosenAspect = pageAspectRatio, resizedPageHeight = availableWidth * chosenAspect, resizedPageWidth = availableHeight / chosenAspect, viewportIsShorterThanAvailHeight = resizedPageHeight > availableHeight, viewportIsShorterThanScaledHeight = resizedPageHeight > availableHeight, scaledOnWidth = !1;
        if ("ftw" === activeTextInstance.view.model.getScaleMode() ? (readerTargetHeight = Math.floor(resizedPageHeight), 
        readerTargetWidth = Math.floor(availableWidth), scaledOnWidth = !0) : isPageLandscape ? viewportIsShorterThanAvailHeight ? (readerTargetHeight = Math.floor(availableHeight), 
        readerTargetWidth = Math.floor(resizedPageWidth)) : (readerTargetHeight = Math.floor(resizedPageHeight), 
        readerTargetWidth = Math.floor(availableWidth), scaledOnWidth = !0) : viewportIsShorterThanAvailHeight ? (readerTargetHeight = Math.floor(availableHeight), 
        readerTargetWidth = Math.floor(resizedPageWidth)) : viewportIsShorterThanScaledHeight ? (readerTargetHeight = Math.floor(availableHeight), 
        readerTargetWidth = Math.floor(resizedPageWidth)) : (readerTargetHeight = Math.floor(resizedPageHeight), 
        readerTargetWidth = Math.floor(availableWidth), scaledOnWidth = !0), !scaledOnWidth) {
            var magnificationValue = activeTextInstance.view.model.getMagnificationValue(), widthReduction = 1 * magnificationValue;
            readerTargetWidth += widthReduction;
        }
        var edgeButtonsWidth = 0, edgeFactory = activeTextInstance.view.getEdgeFactory();
        !activeTextInstance.behaviours.allowOverlappingButtons() && edgeFactory && "number" == typeof edgeFactory.minimumWidth && (edgeButtonsWidth = 2 * edgeFactory.minimumWidth), 
        (scaledOnWidth || edgeButtonsWidth > availableWidth - readerTargetWidth) && (readerTargetWidth = availableWidth - edgeButtonsWidth, 
        readerTargetHeight = (availableWidth - edgeButtonsWidth) * chosenAspect);
        var isSinglePage = isSinglePageView(activeTextInstance) ? 1 : 0;
        return {
            width: readerTargetWidth,
            height: readerTargetHeight,
            dpswidth: readerTargetWidth + readerTargetWidth * isSinglePage,
            dpsheight: readerTargetHeight,
            availWidth: availableWidth,
            availHeight: availableHeight
        };
    }
    function getScaleValue(activeTextInstance) {
        var pageDimensions = activeTextInstance.view.model.getPageDimensions(), dimensions = getUnscaledDPSTargetDimensions(activeTextInstance), vFit = pageDimensions.width / (dimensions.width + 1), hFit = pageDimensions.height / (dimensions.height + 1), rtn = hFit > vFit ? hFit : vFit;
        return rtn;
    }
    function getVisiblePages(activeTextInstance) {
        for (var pagesToCheck = [], currentIndex = activeTextInstance.model.getCurrentIndex(), i = 0, l = activeTextInstance.view.model.getDisplayedPages(); l > i; i++) pagesToCheck.push(currentIndex + i);
        return pagesToCheck;
    }
    function hasExistingFrameForPage(activeTextInstance, index) {
        return void 0 !== activeTextInstance.view.getIFrames()[index];
    }
    function doNotHaveExistingFrameForPage(activeTextInstance, index) {
        return !hasExistingFrameForPage(activeTextInstance, index);
    }
    function indexLessThanMin(index) {
        return index > -1;
    }
    function indexIsNotGreaterThanMax(activeTextInstance, index) {
        return index <= ActiveText.NavigationUtils.getMaximumValidPageIndex(activeTextInstance);
    }
    function isValidPageIndex(activeTextInstance, index) {
        return indexLessThanMin(index) && indexIsNotGreaterThanMax(activeTextInstance, index);
    }
    function getFrameForPageByIndex(activeTextInstance, index) {
        return isValidPageIndex(activeTextInstance, index) && doNotHaveExistingFrameForPage(activeTextInstance, index) && ActiveText.ViewFactory.createFrameForPage(activeTextInstance, index), 
        activeTextInstance.view.getIFrames()[index];
    }
    function isTheRightHandPage(activeTextInstance, pageNumber) {
        if (void 0 === pageNumber) {
            var currentIndex = activeTextInstance.model.getCurrentIndex();
            pageNumber = ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, currentIndex);
        }
        var pageIndex = ActiveText.NavigationUtils.pageNumberToPageIndex(activeTextInstance, pageNumber);
        return "rightPage" === activeTextInstance.utils.updatePageClassNameFor(pageIndex);
    }
    function getCurrentReader(activeTextInstance) {
        var model = activeTextInstance.model, currentIndex = model.getCurrentIndex(), frameForCurrentPage = getFrameForPageByIndex(activeTextInstance, currentIndex);
        return frameForCurrentPage ? frameForCurrentPage.parent() : void 0;
    }
    function getReaderForPage(activeTextInstance, pageIndex) {
        var frameForPage = getFrameForPageByIndex(activeTextInstance, pageIndex);
        return frameForPage ? frameForPage.parent() : void 0;
    }
    function getPrevReader(activeTextInstance) {
        var model = activeTextInstance.model, prevIndex = model.getCurrentIndex() - 2;
        if (prevIndex >= ActiveText.NavigationUtils.getMinimumValidPageIndex(activeTextInstance)) {
            var frameForPreviousPage = getFrameForPageByIndex(activeTextInstance, prevIndex);
            return frameForPreviousPage ? frameForPreviousPage.parent() : void 0;
        }
    }
    function getNextReader(activeTextInstance) {
        var model = activeTextInstance.model, nextIndex = model.getCurrentIndex() + 2, frameForNextPage = getFrameForPageByIndex(activeTextInstance, nextIndex);
        return frameForNextPage ? frameForNextPage.parent() : void 0;
    }
    function isLeftPage(activeTextInstance, inputFrameIndex) {
        return "leftPage" === activeTextInstance.utils.updatePageClassNameFor(inputFrameIndex);
    }
    function pagesArePartOfTheSameDPS(activeTextInstance, fromPage, toPage) {
        var fromIndex = fromPage, toIndex = toPage;
        isLeftPage(activeTextInstance, fromIndex) || (fromIndex -= 1), isLeftPage(activeTextInstance, toIndex) || (toIndex -= 1);
        var rtn = Boolean(toIndex === fromIndex);
        return rtn;
    }
    function getDPSByFrameIndex(activeTextInstance, index) {
        var rtn, currentPage = getFrameForPageByIndex(activeTextInstance, index);
        return currentPage && (rtn = currentPage.parent()), rtn;
    }
    function scaleHTMLElement(activeTextInstance, element, scale) {
        if (scale = Math.ceil(1e3 * scale) / 1e3, Modernizr.csstransforms) // jQuery 1.8 auto-prepends vendor prefixes, so this still works!
        element.css({
            transform: "scale(" + scale + ")",
            transformOriginX: 0,
            transformOriginY: 0,
            transformOrigin: "0 0"
        }); else {
            var filterValue = "progid:DXImageTransform.Microsoft.Matrix(M11=" + scale + ", M12=0.000000, M21=0.000000, M22=" + scale + ", sizingMethod='auto expand')", scaleCss = {
                filter: filterValue,
                "-ms-filter": '"' + filterValue + '"'
            };
            element.css(scaleCss);
        }
    }
    function getContainerCoordinates(activeTextInstance) {
        var containerCoordinates;
        return containerCoordinates = void 0 !== activeTextInstance.options.containerCoordinates ? activeTextInstance.options.containerCoordinates : {
            top: 0,
            left: 0,
            bottom: 0,
            right: 0
        };
    }
    function fetchAvailableDimensions(activeTextInstance) {
        var availableWidth, availableHeight, containerCoordinates = getContainerCoordinates(activeTextInstance), verticalSpacing = containerCoordinates.top + containerCoordinates.bottom, horizontalSpacing = containerCoordinates.left + containerCoordinates.right, isFullWindowScalingMode = activeTextInstance.utils.isFullWindowScalingMode();
        return isFullWindowScalingMode ? (availableWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, 
        availableHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight) : (availableHeight = getParentHeight(activeTextInstance), 
        availableWidth = getParentWidth(activeTextInstance)), availableHeight -= verticalSpacing, 
        availableWidth -= horizontalSpacing, {
            width: availableWidth,
            height: availableHeight
        };
    }
    function invalidateSizeCaches() {
        // todo: Use lodash for this.
        cachedContainerHeight = void 0, cachedContainerWidth = void 0, cachedParentHeight = void 0, 
        cachedParentWidth = void 0;
    }
    function updateAllClassNamesAndResizePages(activeTextInstance) {
        for (var allPages = $(activeTextInstance.options.containerElement).find("div.dps-container").find(".leftPage, .rightPage"), startIndex = ActiveText.NavigationUtils.getMinimumValidPageIndex(activeTextInstance), len = allPages.length - 1 - startIndex, i = startIndex; len > i; i++) getFrameForPageByIndex(activeTextInstance, i);
    }
    function getParentHeight(activeTextInstance) {
        return cachedParentHeight && activeTextInstance.utils.isFullWindowScalingMode() || (cachedParentHeight = $(activeTextInstance.options.containerElement).height()), 
        cachedParentHeight;
    }
    function getParentWidth(activeTextInstance) {
        return cachedParentWidth && activeTextInstance.utils.isFullWindowScalingMode() || (cachedParentWidth = $(activeTextInstance.options.containerElement).width()), 
        cachedParentWidth;
    }
    var cachedContainerHeight, cachedParentHeight, cachedContainerWidth, cachedParentWidth;
    return {
        getNextReader: getNextReader,
        getPrevReader: getPrevReader,
        getCurrentReader: getCurrentReader,
        getReaderForPage: getReaderForPage,
        getFrameForPageByIndex: getFrameForPageByIndex,
        isTheRightHandPage: isTheRightHandPage,
        getDPSByFrameIndex: getDPSByFrameIndex,
        pagesArePartOfTheSameDPS: pagesArePartOfTheSameDPS,
        isLeftPage: isLeftPage,
        scaleHTMLElement: scaleHTMLElement,
        updateAllClassNamesAndResizePages: updateAllClassNamesAndResizePages,
        invalidateSizeCaches: invalidateSizeCaches,
        getContainerCoordinates: getContainerCoordinates,
        isDoublePageView: isDoublePageView,
        isSinglePageView: isSinglePageView,
        isFitToHeightView: isFitToHeightView,
        isFitToWidthView: isFitToWidthView,
        setOpacityValue: setOpacityValue,
        getUnscaledDPSTargetDimensions: getUnscaledDPSTargetDimensions,
        getScaleValue: getScaleValue,
        getVisiblePages: getVisiblePages,
        isCardMode: isCardMode
    };
}(), /* global ActiveText */
ActiveText.namespace("ActiveText.ColourUtils"), ActiveText.ColourUtils = function() {
    "use strict";
    function convertHexToRGB(hex, opacity) {
        var rgbColours, rgbValue;
        if ("string" != typeof hex || !/#?[0-9A-Fa-f]{6}|[0-9A-Fa-f]{3}/.test(hex)) return !1;
        if (hex = hex.replace("#", ""), 6 === hex.length) rgbColours = hex.match(/(.{2})/g); else {
            if (3 !== hex.length) return !1;
            rgbColours = hex.match(/(.{1})/g);
        }
        for (var i = 3; i--; ) rgbValue = rgbColours[i], 1 === rgbValue.length && (rgbValue += rgbValue), 
        rgbColours[i] = parseInt(rgbValue, 16);
        return "undefined" == typeof opacity ? "rgb(" + rgbColours.join(", ") + ")" : "rgba(" + rgbColours.join(", ") + ", " + opacity + ")";
    }
    function convertRGBToHex(rgb) {
        function hex(x) {
            return ("0" + parseInt(x, 10).toString(16)).slice(-2).toUpperCase();
        }
        var rgbArray = rgb.toString().match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
        return rgbArray && $.isArray(rgbArray) && rgbArray.length > 3 ? "#" + hex(rgbArray[1]) + hex(rgbArray[2]) + hex(rgbArray[3]) : !1;
    }
    return {
        convertHexToRGB: convertHexToRGB,
        convertRGBToHex: convertRGBToHex
    };
}();

var convertHexToRGB = function() {
    "use strict";
    return function(hex, opacity) {
        for (var rgb = hex.replace("#", "").match(/(.{2})/g), i = 3; i--; ) rgb[i] = parseInt(rgb[i], 16);
        return "undefined" == typeof opacity ? "rgb(" + rgb.join(", ") + ")" : "rgba(" + rgb.join(", ") + ", " + opacity + ")";
    };
}();

/* global ActiveText */
/**
 * @class CSSUtils
 * @type CSSUtils
 * @memberOf ActiveText
 * @return {embedCSS:function}
 *
 * Manages CSS Style tag declarations - adds them to the head of the page, and if provided a key, ensures that there
 * is only ever one declaration of a style with the same key, overriding previous contents if necessary.
 */
ActiveText.CSSUtils = function() {
    "use strict";
    /**
     * @param {string} cssString
     * @param {string} [key]
     */
    function embedCSS(cssString, key) {
        if (void 0 !== cssCache[key] && (cssCache[key].parentNode.removeChild(cssCache[key]), 
        cssCache[key] = void 0), void 0 === key || void 0 === cssCache[key]) {
            var styleElement = document.createElement("style");
            styleElement.type = "text/css", styleElement.styleSheet ? styleElement.styleSheet.cssText = cssString : styleElement.appendChild(document.createTextNode(cssString)), 
            document.getElementsByTagName("head")[0].appendChild(styleElement), void 0 !== key && (styleElement.setAttribute("data-css-reference", key), 
            cssCache[key.toString()] = styleElement);
        }
    }
    var cssCache = {};
    return {
        embedCSS: embedCSS
    };
}(), /* global ActiveText */
ActiveText.namespace("ActiveText.DataUtils"), ActiveText.DataUtils = function() {
    "use strict";
    function parseURI(query) {
        if (query) {
            var hasSemicolons = -1 !== query.indexOf(";");
            //        var hasAmpersands = query.indexOf("&") !== -1;
            hasSemicolons && (query = query.split("&").join("|amp|").split(";").join("&"));
            var querySplit = query.split("?");
            query = querySplit.pop();
            for (var e, re = /([^&=]+)=?([^&]*)/g, params = {}; e = re.exec(query); ) {
                var k = e[1], v = e[2];
                v = v.split("|amp|").join("&"), "[]" === k.substring(k.length - 2) ? (k = k.substring(0, k.length - 2), 
                (params[k] || (params[k] = [])).push(v)) : params[k] = v;
            }
            return params;
        }
        return {};
    }
    function prependPathToAssets(activeTextInstance, input) {
        var pathToAssets = activeTextInstance.loader.getDataProvider().getPathToPages();
        return void 0 !== pathToAssets ? pathToAssets + input : input;
    }
    function correctURLPath(activeTextInstance, input) {
        var rtn = prependPathToAssets(activeTextInstance, input);
        return rtn = rtn.split("//").join("/").split("http:/").join("http://").split("https:/").join("https://");
    }
    return {
        parseURI: parseURI,
        correctURLPath: correctURLPath
    };
}(), /* global ActiveText */
/**
 * @class CloseDialog
 * @memberOf ActiveText
 */
ActiveText.CloseDialog = function() {
    "use strict";
    $(".ui-dialog").find(".ui-dialog-titlebar-close").trigger("click");
}, /* global ActiveText */
/**
 * @class Theme
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{getBackgroundColor: getBackgroundColor, getForegroundColor: getForegroundColor, getDisabledColor: getDisabledColor, getControlsBackgroundColor: getControlsBackgroundColor, getControlsForegroundColor: getControlsForegroundColor, getControlsAltForegroundColor: getControlsAltForegroundColor, getControlsForegroundHoverColor: getControlsForegroundHoverColor, getControlsAltForegroundHoverColor: getControlsAltForegroundHoverColor, getPageBackgroundColor: getPageBackgroundColor, getControlsOutlineColor: getControlsOutlineColor, getTextColor: getTextColor, getPopupBackgroundColor: getPopupBackgroundColor, getWidgetBackgroundColour: getWidgetBackgroundColour, getWidgetBorderColour: getWidgetBorderColour, getWidgetCloseBackgroundColour: getWidgetCloseBackgroundColour, getWidgetCloseBorderColour: getWidgetCloseBorderColour, getWidgetCloseHoverColour: getWidgetCloseHoverColour, getWidgetTitleColour: getWidgetTitleColour}}
 * @constructor
 */
ActiveText.Theme = function(activeTextInstance) {
    "use strict";
    /**
     * @param color {string}
     * @return {Boolean}
     */
    function isHex(color) {
        return -1 !== color.indexOf("#");
    }
    /**
     * @param color {string}
     * @param opacity {Number=}
     * @return {string}
     */
    function fixColour(color, opacity) {
        var rtn = color, supportsRGBA = $("html").hasClass("rgba");
        return isHex(color) && supportsRGBA && (rtn = ActiveText.ColourUtils.convertHexToRGB(color, opacity)), 
        rtn;
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getPageBackgroundColor(opacity) {
        var color = parseColor("pageBackgroundColor", DEFAULT_BACKGROUND_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getBackgroundColor(opacity) {
        var color = parseColor("backgroundColor", DEFAULT_WHITEBOARD_BACKGROUND_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getForegroundColor(opacity) {
        var color = parseColor("color", DEFAULT_EDGE_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param keyword {string}
     * @param defaultValue {string}
     * @return {string}
     */
    function parseColor(keyword, defaultValue) {
        var targetColor = defaultValue;
        return activeTextInstance && activeTextInstance.options && activeTextInstance.options.scheme && activeTextInstance.options.scheme[keyword] && (targetColor = activeTextInstance.options.scheme[keyword]), 
        targetColor;
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getDisabledColor(opacity) {
        var color = parseColor("disabledColor", DEFAULT_DISABLED_EDGE_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getControlsBackgroundColor(opacity) {
        var color = parseColor("controlBackgroundColor", DEFAULT_BAR_BACKGROUND_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getPopupBackgroundColor(opacity) {
        var color = parseColor("popupBackgroundColor", DEFAULT_ICON_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getControlsOutlineColor(opacity) {
        var color = parseColor("controlOutlineColor", DEFAULT_BAR_BACKGROUND_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getTextColor(opacity) {
        var color = parseColor("textColor", DEFAULT_BAR_BACKGROUND_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getControlsForegroundColor(opacity) {
        var color = parseColor("controlColor", DEFAULT_ICON_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getControlsAltForegroundColor(opacity) {
        var color = parseColor("altControlColor", DEFAULT_ICON_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getControlsForegroundHoverColor(opacity) {
        var color = parseColor("controlHoverColor", DEFAULT_ICON_COLOUR_HOVER_SIMPLE);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getControlsAltForegroundHoverColor(opacity) {
        var color = parseColor("altControlHoverColor", DEFAULT_ICON_COLOUR_HOVER_SIMPLE);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getWidgetBackgroundColour(opacity) {
        var color = parseColor("widgetBackgroundColour", DEFAULT_WIDGET_BACKGROUND_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getWidgetBorderColour(opacity) {
        var color = parseColor("widgetBorderColour", DEFAULT_WIDGET_BORDER_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getWidgetCloseBackgroundColour(opacity) {
        var color = parseColor("widgetCloseBackgroundColour", DEFAULT_WIDGET_CLOSE_BACKGROUND_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getWidgetCloseBorderColour(opacity) {
        var color = parseColor("widgetCloseBorderColour", DEFAULT_WIDGET_CLOSE_BORDER_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getWidgetCloseHoverColour(opacity) {
        var color = parseColor("widgetCloseHoverColour", DEFAULT_WIDGET_CLOSE_HOVER_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @param opacity {Number=}
     * @return {string}
     */
    function getWidgetTitleColour(opacity) {
        var color = parseColor("widgetTitleColour", DEFAULT_WIDGET_TITLE_COLOUR);
        return fixColour(color, opacity);
    }
    /**
     * @const
     * @type {string}
     */
    var DEFAULT_BACKGROUND_COLOUR = "#ffffff", DEFAULT_DISABLED_EDGE_COLOUR = "#e5e5e5", DEFAULT_EDGE_COLOUR = "#2699cf", DEFAULT_ICON_COLOUR = "#ffffff", DEFAULT_BAR_BACKGROUND_COLOUR = "#000000", DEFAULT_WHITEBOARD_BACKGROUND_COLOUR = "#eeeeee", DEFAULT_ICON_COLOUR_HOVER_SIMPLE = "#2699cf", DEFAULT_WIDGET_BACKGROUND_COLOUR = "#ffffff", DEFAULT_WIDGET_BORDER_COLOUR = "#363636", DEFAULT_WIDGET_CLOSE_BACKGROUND_COLOUR = "#ffffff", DEFAULT_WIDGET_CLOSE_BORDER_COLOUR = "#000000", DEFAULT_WIDGET_CLOSE_HOVER_COLOUR = "#cf3616", DEFAULT_WIDGET_TITLE_COLOUR = "#000000";
    return {
        getBackgroundColor: getBackgroundColor,
        getForegroundColor: getForegroundColor,
        getDisabledColor: getDisabledColor,
        getControlsBackgroundColor: getControlsBackgroundColor,
        getControlsForegroundColor: getControlsForegroundColor,
        getControlsAltForegroundColor: getControlsAltForegroundColor,
        getControlsForegroundHoverColor: getControlsForegroundHoverColor,
        getControlsAltForegroundHoverColor: getControlsAltForegroundHoverColor,
        getPageBackgroundColor: getPageBackgroundColor,
        getControlsOutlineColor: getControlsOutlineColor,
        getTextColor: getTextColor,
        getPopupBackgroundColor: getPopupBackgroundColor,
        getWidgetBackgroundColour: getWidgetBackgroundColour,
        getWidgetBorderColour: getWidgetBorderColour,
        getWidgetCloseBackgroundColour: getWidgetCloseBackgroundColour,
        getWidgetCloseBorderColour: getWidgetCloseBorderColour,
        getWidgetCloseHoverColour: getWidgetCloseHoverColour,
        getWidgetTitleColour: getWidgetTitleColour
    };
}, /* global ActiveText, requestAnimationFrame */
ActiveText.Animators = ActiveText.Animators || {}, /**
 * @class Animators
 * @memberOf ActiveText.Animators
 * @param activeTextInstance {ActiveText}
 * @returns {{register: register, fixPagePositions: fixPagePositions}}
 * @constructor
 */
ActiveText.Animators.SlideAnimation = function(activeTextInstance) {
    "use strict";
    function register() {
        utils = new ActiveText.Animators.SlideAnimation.Utils(activeTextInstance);
        var signalBus = $(activeTextInstance);
        signalBus.on(ActiveText.Commands.GO_TO_PAGE, animatePageSlide), signalBus.one(ActiveText.Commands.INIT_WHITEBOARD, safeStartup), 
        activeTextInstance.options && activeTextInstance.options.containerElement && $(activeTextInstance.options.containerElement).on("remove", teardown);
    }
    function teardown() {
        $(activeTextInstance.options.containerElement).off("remove", teardown), $(activeTextInstance).off(ActiveText.Commands.GO_TO_PAGE, animatePageSlide);
    }
    function safeStartup() {
        animateContainer = $("<div class='animate-container' style='position:relative'></div>"), 
        whiteboard = activeTextInstance.view.getContainer(), animateContainer.appendTo(whiteboard);
    }
    /**
     * @param options
     */
    function stopCurrentAnimations(options) {
        var oldPage = ActiveText.ViewUtils.getDPSByFrameIndex(activeTextInstance, options.fromPage), newPage = ActiveText.ViewUtils.getDPSByFrameIndex(activeTextInstance, options.toPage);
        oldPage && oldPage.stop(!0, !1), newPage && newPage.stop(!0, !1);
    }
    function hideLoaderWhenContentLoaded() {
        $(activeTextInstance).trigger(ActiveText.Commands.HIDE_LOADER);
    }
    /**
     * Sends out an event which notifies other classes that they need to load the resources
     * for the current index (the value of which will already have been changed)
     *
     * @private
     */
    function beginLoadingNewContent(options) {
        $(activeTextInstance).trigger(ActiveText.Commands.LOAD_PAGES_AT_INDEX, [ options.toPage ]), 
        $(activeTextInstance).off(ActiveText.Events.FRAME_CONTENT_LOADED, hideLoaderWhenContentLoaded).on(ActiveText.Events.FRAME_CONTENT_LOADED, hideLoaderWhenContentLoaded);
    }
    /**
     * @param options
     */
    function destroyUnusedFrames() {
        function removeContentsOfNonVisiblePages() {
            activeTextInstance.view.getAllReaders().not(visiblePages).hide().find(".leftPage, .rightPage").empty();
        }
        var currentReader = ActiveText.ViewUtils.getCurrentReader(activeTextInstance), nextReader = ActiveText.ViewUtils.getNextReader(activeTextInstance), prevReader = ActiveText.ViewUtils.getPrevReader(activeTextInstance), visiblePages = $(nextReader).add(currentReader).add(prevReader);
        visiblePages.css({
            display: "block"
        }), requestAnimationFrame(removeContentsOfNonVisiblePages);
    }
    /**
     * @param options
     */
    function moveFramesToInitialPositions(options) {
        var readerDPSWidth = activeTextInstance.utils.getReaderDPSWidth(), initialPositions = utils.calculateInitialAnimationPositions(readerDPSWidth, options.fromPage, options.toPage), finalPositions = utils.calculateFinalAnimationPositions(readerDPSWidth, options.fromPage, options.toPage), fromReader = ActiveText.ViewUtils.getReaderForPage(activeTextInstance, options.fromPage), currentReader = ActiveText.ViewUtils.getCurrentReader(activeTextInstance), nextReader = ActiveText.ViewUtils.getNextReader(activeTextInstance), prevReader = ActiveText.ViewUtils.getPrevReader(activeTextInstance), currentIndex = activeTextInstance.model.getCurrentIndex();
        options.fromPage < currentIndex - 2 && (prevReader = fromReader), options.fromPage > currentIndex + 2 && (nextReader = fromReader);
        var leftPos, isSinglePageView = ActiveText.ViewUtils.isSinglePageView(activeTextInstance), isTheRightHandPage = !ActiveText.NavigationUtils.isLeftPage(activeTextInstance, options.toPage);
        currentReader && (leftPos = finalPositions.current.left, isSinglePageView && isTheRightHandPage && (//                leftPos += readerDPSWidth;
        leftPos = 0), currentReader.css("left", leftPos).show()), nextReader && (leftPos = finalPositions.next.left, 
        isSinglePageView && isTheRightHandPage && (//                leftPos += readerDPSWidth;
        leftPos = 0), nextReader.css("left", leftPos).show()), prevReader && (leftPos = finalPositions.previous.left, 
        isSinglePageView && isTheRightHandPage && (//                leftPos += readerDPSWidth;
        leftPos = 0), prevReader.css("left", leftPos).show());
        var allElements = $(currentReader).add(nextReader).add(prevReader);
        allElements.css({
            display: "block"
        });
        var currentChildren = animateContainer.children();
        if (currentChildren.not(allElements).appendTo(whiteboard), allElements.not(currentChildren).appendTo(animateContainer), 
        animateContainer.stop(!0, !1), 0 === options.duration) animateContainer.animate(finalPositions.current, {
            duration: 0
        }); else {
            var existingValue = animateContainer.css("left");
            initialPositions.current.left += parseInt(existingValue, 10), animateContainer.animate(initialPositions.current, {
                duration: 0
            });
        }
        isAnimating = !1;
    }
    /**
     * @param options
     */
    function moveFramesToFinalPositions(options, immediate) {
        function moveElements() {
            animateContainer && (animateContainer.stop(!0, !1), animateContainer.animate(finalPositions.current, {
                duration: 0
            }), isAnimating = !1, //                if(activeTextInstance.behaviours.shouldAllowOverlappingContent())
            //                {
            //                    containerParent.css({
            //                        overflow: 'visible'
            //                    });
            //                }
            //                else
            //                {
            ActiveText.ViewUtils.isFitToWidthView(activeTextInstance) || containerParent.css({
                overflow: "hidden"
            }));
        }
        var nextReader = ActiveText.ViewUtils.getNextReader(activeTextInstance), prevReader = ActiveText.ViewUtils.getPrevReader(activeTextInstance), containerParent = activeTextInstance.view.getContainer().parent(), readerDPSWidth = activeTextInstance.utils.getReaderDPSWidth(), finalPositions = utils.calculateFinalAnimationPositions(readerDPSWidth, options.fromPage, options.toPage);
        nextReader && nextReader.hide(), prevReader && prevReader.hide(), immediate ? moveElements() : requestAnimationFrame(moveElements);
    }
    /**
     * @param options
     */
    function runAnimations(options) {
        function onAnimationComplete() {
            isAnimating = !1, $(activeTextInstance).trigger(ActiveText.Events.ANIMATE_PAGE_END), 
            moveFramesToFinalPositions(options), $(activeTextInstance).trigger(ActiveText.Events.RESIZE);
        }
        var finalPositions = utils.calculateFinalAnimationPositions(activeTextInstance.utils.getReaderDPSWidth(), options.fromPage, options.toPage), animationSpeed = "number" == typeof options.duration ? options.duration : DEFAULT_ANIMATION_SPEED;
        animateContainer.stop(!0, !0).animate(finalPositions.current, {
            duration: animationSpeed,
            easing: "easeOutExpo",
            complete: onAnimationComplete,
            queue: !1
        }), isAnimating = !0;
    }
    function animatePageSlide(e, options) {
        function stopAnimations() {
            stopCurrentAnimations(options), beginLoadingNewContent(options), destroyUnusedFrames(options), 
            moveFramesToInitialPositions(options), utils.shouldAnimateBetweenPages(options) ? requestAnimationFrame(startAnimating) : moveFramesToFinalPositions(options);
        }
        function startAnimating() {
            $(activeTextInstance).trigger(ActiveText.Events.ANIMATE_PAGE_START), runAnimations(options);
        }
        activeTextInstance.view.getContainer().parent().css({
            overflow: "hidden"
        }), requestAnimationFrame(stopAnimations), $(activeTextInstance).trigger(ActiveText.Commands.SHOW_LOADER);
    }
    function fixPagePositions() {
        if (!isAnimating) {
            var currentIndex = activeTextInstance.model.getCurrentIndex();
            moveFramesToFinalPositions({
                toPage: currentIndex,
                fromPage: currentIndex,
                duration: 0
            }, !0);
        }
    }
    /**
     * @type {ActiveText.Animators.SlideAnimation.Utils}
     */
    var utils, whiteboard, animateContainer, DEFAULT_ANIMATION_SPEED = 1e3, isAnimating = !1;
    return {
        register: register,
        fixPagePositions: fixPagePositions
    };
}, /* global ActiveText, namespace */
ActiveText.namespace("ActiveText.Animators.SlideAnimation.Utils"), /**
 * @class Utils
 * @memberOf ActiveText.Animators.SlideAnimation
 * @param activeTextInstance {ActiveText}
 * @type {{calculateInitialAnimationPositions: calculateInitialAnimationPositions, calculateFinalAnimationPositions: calculateFinalAnimationPositions, shouldAnimateBetweenPages: shouldAnimateBetweenPages}}
 * @constructor
 */
ActiveText.Animators.SlideAnimation.Utils = function(activeTextInstance) {
    "use strict";
    function calculateSinglePageInitialPosition(direction, dpsWidth, sameDPS) {
        var rtn = getDefaultReturnObject();
        //
        //        else
        //        {
        //            if(ActiveText.NavigationUtils.isLeftPage(activeTextInstance, toPage))
        //            {
        //                rtn.current.left -= dpsWidth;
        //            }
        //            else
        //            {
        //                rtn.current.left -= 0;
        //            }
        //        }
        return "left" === direction ? rtn.current.left = sameDPS ? 0 : dpsWidth / 2 : "right" === direction && (rtn.current.left = sameDPS ? -dpsWidth / 2 : -dpsWidth), 
        rtn.previous.left = rtn.current.left - dpsWidth, rtn.next.left = rtn.current.left + dpsWidth, 
        rtn;
    }
    function calculateDoublePageInitialPosition(direction, dpsWidth) {
        var rtn = {
            current: {
                left: 0
            },
            next: {
                left: 0
            },
            previous: {
                left: 0
            }
        };
        return "left" === direction ? (rtn.current.left = dpsWidth, rtn.next.left = 2 * dpsWidth, 
        rtn.previous.left = 0) : "right" === direction && (rtn.current.left = -dpsWidth, 
        rtn.next.left = 0, rtn.previous.left = 2 * -dpsWidth), rtn;
    }
    /**
     * @param dpsWidth {number}
     * @param fromPage {number}
     * @param toPage {number}
     * @return {object}
     */
    function calculateInitialAnimationPositions(dpsWidth, fromPage, toPage) {
        var rtn, direction = calculateAnimationDirection(activeTextInstance, fromPage, toPage), isSinglePageView = ActiveText.ViewUtils.isSinglePageView(activeTextInstance);
        if (isSinglePageView) {
            var sameDPS = ActiveText.ViewUtils.pagesArePartOfTheSameDPS(activeTextInstance, fromPage, toPage);
            rtn = calculateSinglePageInitialPosition(direction, dpsWidth, sameDPS, toPage);
        } else rtn = calculateDoublePageInitialPosition(direction, dpsWidth);
        return rtn;
    }
    function calculateAnimationDirection(activeTextInstance, from, to) {
        return from === to ? "none" : to > from ? "left" : "right";
    }
    function getDefaultReturnObject() {
        return {
            current: {
                left: 0
            },
            next: {
                left: 0
            },
            previous: {
                left: 0
            }
        };
    }
    function calculateSinglePageFinalPosition(dpsWidth, fromPage, toPage) {
        function setLeftPosition() {
            rtn.current.left = 0;
        }
        function setRightPosition() {
            //            var startsLeft = activeTextInstance.settings.getFirstPageIsLeft();
            //            if(startsLeft)
            //            {
            //                rtn.current.left = -dpsWidth;
            //            }
            //            else
            //            {
            rtn.current.left = -dpsWidth / 2;
        }
        var isLeftPage = ActiveText.NavigationUtils.isLeftPage(activeTextInstance, toPage), rtn = getDefaultReturnObject();
        return isLeftPage ? setLeftPosition() : setRightPosition(), rtn.previous.left = rtn.current.left - 2 * dpsWidth, 
        rtn.next.left = rtn.current.left + 2 * dpsWidth, rtn;
    }
    /**
     * @param dpsWidth {number}
     * @param fromPage {number}
     * @param toPage {number}
     * @return {object}
     */
    function calculateFinalAnimationPositions(dpsWidth, fromPage, toPage) {
        var rtn = {
            current: {
                left: 0
            },
            next: {
                left: dpsWidth
            },
            previous: {
                left: -dpsWidth
            }
        }, isSinglePageView = ActiveText.ViewUtils.isSinglePageView(activeTextInstance);
        return isSinglePageView && (rtn = calculateSinglePageFinalPosition(dpsWidth, fromPage, toPage)), 
        rtn;
    }
    function shouldAnimateBetweenPages(options) {
        var allowAnimation = !0;
        activeTextInstance && activeTextInstance.options && void 0 !== activeTextInstance.options.allowAnimation && (allowAnimation = activeTextInstance.options.allowAnimation);
        var isOldVersionOfIE = $.browser.msie && $.browser.version < 10, isOnTheSameDPS = Math.abs(options.fromPage - options.toPage) < 3, isInSinglePageView = !1;
        try {
            isInSinglePageView = ActiveText.ViewUtils.isSinglePageView(activeTextInstance);
        } catch (e) {}
        return !isInSinglePageView && isOnTheSameDPS && !isOldVersionOfIE && allowAnimation;
    }
    return {
        calculateInitialAnimationPositions: calculateInitialAnimationPositions,
        calculateFinalAnimationPositions: calculateFinalAnimationPositions,
        shouldAnimateBetweenPages: shouldAnimateBetweenPages
    };
}, /* global ActiveText */
/**
 * @class Behaviours
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{shouldAllowOverlappingContent: shouldAllowOverlappingContent, allowOverlappingButtons: allowOverlappingButtons}}
 * @constructor
 */
ActiveText.Behaviours = function(activeTextInstance) {
    "use strict";
    function shouldAllowOverlappingContent() {
        return !ActiveText.ViewUtils.isSinglePageView(activeTextInstance);
    }
    function allowOverlappingButtons() {
        return "ftw" === activeTextInstance.view.model.getScaleMode() ? !1 : !(void 0 !== activeTextInstance.options.allowOverlap && "false" === activeTextInstance.options.allowOverlap.toString().toLowerCase());
    }
    function shouldGeneratePageEdges() {
        var defaults = activeTextInstance && activeTextInstance.options && activeTextInstance.options.defaults ? activeTextInstance.options.defaults : {
            generatePageEdges: !0
        }, generatePageEdges = defaults.generatePageEdges !== !1;
        return generatePageEdges === !0;
    }
    return {
        shouldAllowOverlappingContent: shouldAllowOverlappingContent,
        allowOverlappingButtons: allowOverlappingButtons,
        shouldGeneratePageEdges: shouldGeneratePageEdges
    };
}, /* global ActiveText */
ActiveText.Navigation = ActiveText.Navigation || {}, /**
 * @class Controller
 * @memberOf ActiveText.Navigation
 * @param activeTextInstance {ActiveText}
 * @returns {{canGoToPreviousPage: canGoToPreviousPage, gotoPrevPage: gotoPrevPage, canGoToNextPage: canGoToNextPage, gotoNextPage: gotoNextPage, gotoPage: goToPage}}
 * @constructor
 */
ActiveText.Navigation.Controller = function(activeTextInstance) {
    "use strict";
    /**
     * @param from {number}
     * @param to {number}
     * @param immediate {boolean=}
     */
    function internalGoToPage(from, to, immediate) {
        var duration;
        immediate && (duration = 0), $(activeTextInstance).trigger(ActiveText.Commands.GO_TO_PAGE, {
            fromPage: from,
            toPage: to,
            duration: duration
        });
    }
    /**
     * @param pageNumber {number}
     * @param immediate {boolean=}
     */
    function goToPage(pageNumber, immediate) {
        var oldIndex = activeTextInstance.model.getCurrentIndex(), pageIndex = ActiveText.NavigationUtils.pageNumberToPageIndex(activeTextInstance, pageNumber), nearestValidPageIndex = ActiveText.NavigationUtils.getNearestValidPageFromIndex(activeTextInstance, pageIndex), newIndex = nearestValidPageIndex;
        ActiveText.ViewUtils.isSinglePageView(activeTextInstance) || (newIndex = ActiveText.NavigationUtils.calculateLeftmostPageIndexFromIndex(activeTextInstance, nearestValidPageIndex));
        var validIndex = activeTextInstance.model.setCurrentIndex(newIndex);
        internalGoToPage(oldIndex, validIndex, immediate);
    }
    /**
     * @returns {boolean}
     */
    function canGoToPreviousPage() {
        return activeTextInstance.model.getCurrentIndex() - activeTextInstance.view.model.getDisplayedPages() >= ActiveText.NavigationUtils.getMinimumValidPageIndex(activeTextInstance);
    }
    /**
     * @returns {boolean}
     */
    function canGoToNextPage() {
        var pages = activeTextInstance.data.getFlatListOfNavigation();
        return activeTextInstance.model.getCurrentIndex() + activeTextInstance.view.model.getDisplayedPages() < pages.length;
    }
    /**
     * @returns {boolean}
     */
    function gotoNextPage() {
        var success = !1;
        if (canGoToNextPage()) {
            var originalIndex = activeTextInstance.model.getCurrentIndex(), newIndex = originalIndex + activeTextInstance.view.model.getDisplayedPages(), validIndex = activeTextInstance.model.setCurrentIndex(newIndex);
            internalGoToPage(originalIndex, validIndex), success = !0;
        }
        return success;
    }
    /**
     * @returns {boolean}
     */
    function gotoPrevPage() {
        var success = !1;
        if (canGoToPreviousPage()) {
            var originalIndex = activeTextInstance.model.getCurrentIndex(), newIndex = originalIndex - activeTextInstance.view.model.getDisplayedPages(), validIndex = activeTextInstance.model.setCurrentIndex(newIndex);
            internalGoToPage(originalIndex, validIndex), success = !0;
        }
        return success;
    }
    return {
        canGoToPreviousPage: canGoToPreviousPage,
        gotoPrevPage: gotoPrevPage,
        canGoToNextPage: canGoToNextPage,
        gotoNextPage: gotoNextPage,
        gotoPage: goToPage
    };
}, /* global ActiveText, Modernizr */
/**
 * @class ErrorMessages
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{init: init}}
 * @constructor
 */
ActiveText.ErrorMessages = function(activeTextInstance) {
    "use strict";
    function showMessage(event, data) {
        $("#messages-placeholder").notify(data, {
            position: "bottom center",
            style: "base",
            autoHide: !0,
            clickToHide: !0,
            arrowShow: !1,
            showAnimation: "slideDown",
            gap: 8
        });
    }
    function attachEvents() {
        $(activeTextInstance).on(ActiveText.Commands.DISPLAY_ERROR, showMessage);
    }
    function init() {
        generatePlaceHolderElement(), attachEvents(), $.notify.addStyle("base", {
            html: '<div role="alert" aria-live="assertive"><span data-notify-text/></div>',
            classes: {
                base: {
                    color: "#ffffff",
                    "white-space": "nowrap",
                    "background-color": Modernizr.rgba ? "rgba(0,0,0,0.5)" : "#666",
                    padding: "5px 8px 2px",
                    "border-radius": "8px",
                    border: "1px solid #000000"
                }
            }
        });
    }
    function generatePlaceHolderElement() {
        if (activeTextInstance && activeTextInstance.options && activeTextInstance.options.containerElement) {
            var container = activeTextInstance.options.containerElement, placeholderElement = $('<div id="messages-placeholder"></div>').css({
                top: 0,
                left: 0,
                right: 0,
                height: 1,
                position: "absolute",
                zIndex: 1001
            });
            container.append(placeholderElement);
        }
    }
    return {
        init: init
    };
}, /* global ActiveText, requestAnimationFrame */
/**
 * @class View
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{getAllReaders: getReaderElements, init: init, getIFrames: getIFrames, getAnimator: getAnimator, getContainer: getContainer, disableInteraction: disableInteraction, enableInteraction: enableInteraction, getOverlayElements: getOverlayElements, getEdgeFactory: getEdgeFactory}}
 * @constructor
 */
ActiveText.View = function(activeTextInstance) {
    "use strict";
    function setupPageAnimator() {
        animator = new ActiveText.Animators.SlideAnimation(activeTextInstance), //            var slideAnimation = new FlipAnimationDecorator();
        animator.register();
    }
    function init() {
        function onWindowResize() {
            $(activeTextInstance).trigger(ActiveText.Events.RESIZE);
        }
        function teardown() {
            $(activeTextInstance.options.containerElement).off("remove", teardown), $(window, window.top).off("resize", debouncedResize), 
            //        removeWindowResizeListeners();
            whiteboardContainer = void 0, whiteboardCache = void 0;
        }
        iframes = [];
        var jQActiveTextInstance = $(activeTextInstance);
        jQActiveTextInstance.one(ActiveText.Commands.INIT_WHITEBOARD, initWhiteboard), jQActiveTextInstance.on(ActiveText.Commands.FRAME_CONTENT_ERROR, addErrorMessageToFrame);
        var viewController = new ActiveText.View.Controller(activeTextInstance);
        viewController.init(), setupPageAnimator(), loadingVisController = new ActiveText.View.Loader(activeTextInstance), 
        zoomController = new ActiveText.ZoomController(activeTextInstance), swipeInteractionController = new ActiveText.Interaction.SwipeGesture(activeTextInstance);
        var messages = new ActiveText.ErrorMessages(activeTextInstance);
        messages.init();
        var debouncedResize = _.debounce(onWindowResize, 100);
        api.model = new ActiveText.View.Model(activeTextInstance), activeTextInstance.options && activeTextInstance.options.containerElement && ($(window, window.top).on("resize", debouncedResize), 
        $(activeTextInstance.options.containerElement).on("remove", teardown));
    }
    function initWhiteboard() {
        var container = getContainerElement();
        if (container) {
            activeTextInstance.behaviours.shouldGeneratePageEdges() && (edgeFactory = new ActiveText.MinimalPageEdgeFactory(activeTextInstance)), 
            whiteboardContainer = ActiveText.ViewFactory.initialiseWhiteboard(activeTextInstance, container), 
            activeTextInstance.behaviours.shouldGeneratePageEdges() && enableInteraction(), 
            resizeController = new ActiveText.View.Resize(activeTextInstance), resizeController.init(whiteboardContainer), 
            resizeController.register();
            var whiteboard = getContainer();
            edgeFactory && edgeFactory.generateEdges(whiteboard), loadingVisController.register(whiteboard), 
            zoomController.register(), activeTextInstance.options.containerElement.css({
                overflow: "hidden",
                transform: "translateZ(0)"
            }).addClass("activetext"), activeTextInstance.utils.isFullWindowScalingMode() ? (activeTextInstance.options.containerElement.css({
                position: "fixed",
                width: "100%",
                height: "100%"
            }), //                $('body').attr("role", "document").css('overflow', 'hidden');
            $("body").css("overflow", "hidden")) : activeTextInstance.options.containerElement.attr("role", "document"), 
            whiteboardContainer.on("remove", zoomController.deregister), whiteboardContainer.on("remove", loadingVisController.deregister), 
            whiteboardContainer.on("remove", resizeController.deregister), whiteboardContainer.on("remove", animator.deregister), 
            enableInteraction();
        }
        $(activeTextInstance).trigger(ActiveText.Commands.LOAD_RESOURCES);
    }
    function getIFrames() {
        return iframes;
    }
    function addErrorMessageToFrame(event, data) {
        var index = data.index, frame = ActiveText.ViewUtils.getFrameForPageByIndex(activeTextInstance, index);
        frame && frame.addClass("errorPage").css({
            background: activeTextInstance.theme.getBackgroundColor()
        });
    }
    function enableInteraction() {
        var container = getContainer();
        swipeInteractionController.register(container), whiteboardContainer.find(".leftEdge, .rightEdge").show();
    }
    function disableInteraction() {
        var container = getContainer();
        swipeInteractionController.deregister(container), whiteboardContainer.find(".leftEdge, .rightEdge").hide();
    }
    function getContainerElement() {
        return activeTextInstance.options ? activeTextInstance.options.containerElement : void 0;
    }
    function getContainer() {
        return !whiteboardCache && getContainerElement() && (whiteboardCache = getContainerElement().find(".whiteboard")), 
        whiteboardCache;
    }
    function getReaderElements() {
        var whiteboard = getContainer();
        return whiteboard.find("div.dps-container");
    }
    function getOverlayElements() {
        var whiteboard = getContainer();
        return whiteboard.find("div.dps-container > div > div").not(".iframe");
    }
    function getAnimator() {
        return animator;
    }
    function getEdgeFactory() {
        return edgeFactory;
    }
    /**
     * @type {jQuery|object}
     */
    var whiteboardContainer, whiteboardCache, loadingVisController, zoomController, edgeFactory, iframes, animator, resizeController, swipeInteractionController, api = {
        getAllReaders: getReaderElements,
        init: init,
        getIFrames: getIFrames,
        getAnimator: getAnimator,
        getContainer: getContainer,
        disableInteraction: disableInteraction,
        enableInteraction: enableInteraction,
        getOverlayElements: getOverlayElements,
        getEdgeFactory: getEdgeFactory
    };
    return api;
}, /* global ActiveText, requestAnimationFrame, Modernizr */
ActiveText.View.Model = function(activeTextInstance) {
    "use strict";
    function parseDefaults() {
        var defaults = activeTextInstance && activeTextInstance.options && activeTextInstance.options.defaults ? activeTextInstance.options.defaults : defaultValues;
        for (var prop in defaultValues) void 0 === defaults[prop] && (defaults[prop] = defaultValues[prop]);
        var initialDisplayedPages = parseInt(defaults.pagesToDisplay, 10);
        (!isNaN(initialDisplayedPages) || 1 > initialDisplayedPages) && (displayedPages = initialDisplayedPages);
        var initialScaleMode = defaults.scaleMode;
        void 0 !== initialScaleMode && (currentDisplayScaleMode = initialScaleMode), void 0 === defaults.wmode && (defaults.wmode = defaultValues.wmode);
    }
    function hasActualZoomAreaDimensions() {
        return void 0 !== actualZoomAreaDimensions;
    }
    function getZoomAreaDimensions() {
        return hasActualZoomAreaDimensions() ? actualZoomAreaDimensions : defaultZoomAreaDimensions;
    }
    function setZoomAreaDimensions(value) {
        actualZoomAreaDimensions = value;
    }
    function getPageDimensions() {
        return actualPageSettings ? actualPageSettings : defaultPageSettings;
    }
    function setPageDimensions(newData) {
        var isDifferent = void 0 === newData || void 0 === actualPageSettings || newData.width !== actualPageSettings.width || newData.height !== actualPageSettings.height || newData.aspectRatio !== actualPageSettings.aspectRatio;
        isDifferent && (actualPageSettings = newData, $(activeTextInstance).trigger(ActiveText.Events.RESIZE));
    }
    function getDisplayedPages() {
        return displayedPages;
    }
    function setDisplayedPages(value) {
        displayedPages = value;
    }
    function getMagnificationValue() {
        return magnificationValue;
    }
    function setMagnificationValue(value) {
        magnificationValue = value;
    }
    function getScaleMode() {
        return currentDisplayScaleMode;
    }
    function setScaleMode(value) {
        currentDisplayScaleMode !== value && (currentDisplayScaleMode = value, $(activeTextInstance).trigger(ActiveText.Events.CHANGE_SCALING_MODE, value));
    }
    function setCardMode(mode) {
        cardMode = mode;
    }
    function returnCardMode() {
        return cardMode;
    }
    var actualPageSettings, actualZoomAreaDimensions, currentDisplayScaleMode, displayedPages, magnificationValue = 1, cardMode = !1, defaultValues = {
        pagesToDisplay: 2,
        scaleMode: "fth",
        wmode: "window"
    }, defaultZoomAreaDimensions = {
        width: 621,
        height: 783
    }, defaultPageSettings = {
        width: 600,
        height: 800,
        aspectRatio: .75
    };
    return parseDefaults(), {
        getPageDimensions: getPageDimensions,
        setPageDimensions: setPageDimensions,
        setZoomAreaDimensions: setZoomAreaDimensions,
        getZoomAreaDimensions: getZoomAreaDimensions,
        getDisplayedPages: getDisplayedPages,
        setDisplayedPages: setDisplayedPages,
        setScaleMode: setScaleMode,
        getScaleMode: getScaleMode,
        getMagnificationValue: getMagnificationValue,
        setMagnificationValue: setMagnificationValue,
        setCardMode: setCardMode,
        returnCardMode: returnCardMode
    };
}, /* global ActiveText, requestAnimationFrame, Modernizr */
ActiveText.View = ActiveText.View || {}, /**
 * @class Resize
 * @memberOf ActiveText.View
 * @param activeTextInstance {ActiveText}
 * @returns {{init: init, register: register, deregister: deRegister}}
 * @constructor
 */
ActiveText.View.Resize = function(activeTextInstance) {
    "use strict";
    function init(container) {
        whiteboardContainer = container, $(activeTextInstance.options.containerElement).on("remove", teardown);
    }
    function teardown() {
        $(activeTextInstance.options.containerElement).off("remove", teardown), $(window, window.top).off("orientationchange"), 
        removeWindowResizeListeners(), whiteboardContainer = void 0;
    }
    function register() {
        setupWindowResizeListeners();
    }
    function deRegister() {
        removeWindowResizeListeners();
    }
    function onWindowResize() {
        resizeReaderToFitContainer(), fixPositions();
    }
    function setupWindowResizeListeners() {
        $(activeTextInstance).on(ActiveText.Events.RESIZE, onWindowResize), activeTextInstance.utils.isFullWindowScalingMode() && $(window, window.top).on("orientationchange", onWindowResize), 
        onWindowResize();
    }
    function removeWindowResizeListeners() {
        $(activeTextInstance).off(ActiveText.Events.RESIZE, onWindowResize), $(window, window.top).off("orientationchange", onWindowResize);
    }
    function fixPositions() {
        "function" == typeof activeTextInstance.view.getAnimator().fixPagePositions && activeTextInstance.view.getAnimator().fixPagePositions(), 
        activeTextInstance.utils.isFullWindowScalingMode() && setTimeout(function() {
            // Hide the address bar!
            window.scrollTo(0, 1);
        }, 0);
    }
    function fitView(dimensions, dpsElement, iframeWrappers, scaleValue) {
        var iframeElementWidth, pageElementWidth, magnificationValue = activeTextInstance.view.model.getMagnificationValue(), individualPages = iframeWrappers.parent(), readerWidth = dimensions.width * magnificationValue, dpsWidth = dimensions.dpswidth * magnificationValue, readerHeight = (dimensions.dpsheight * magnificationValue, 
        dimensions.height * magnificationValue), whiteboard = activeTextInstance.view.getContainer(), magnifiedScaleValue = scaleValue, iframeElementHeight = Math.ceil(readerHeight * magnifiedScaleValue), pageElementHeight = readerHeight, isNotZoomMode = "zoom" !== activeTextInstance.view.model.getScaleMode(), widthReduction = 0 * magnificationValue;
        isNotZoomMode && whiteboardContainer.width(readerWidth).height(readerHeight);
        var isSinglePageFitToWidth = ActiveText.ViewUtils.isSinglePageView(activeTextInstance) && "ftw" === activeTextInstance.view.model.getScaleMode();
        whiteboard.height(readerHeight), whiteboardContainer.width(readerWidth - 2 * widthReduction), 
        isSinglePageFitToWidth ? (whiteboard.width(readerWidth), whiteboardContainer.height(dimensions.availHeight), 
        whiteboard.css({
            marginTop: 0
        }), whiteboardContainer.css({
            overflowY: "hidden"
        })) : (whiteboard.width(dpsWidth), whiteboard.css(activeTextInstance.behaviours.shouldAllowOverlappingContent() ? {
            overflowY: "visible",
            overflowX: "visible"
        } : {
            overflowY: "hidden",
            overflowX: "hidden"
        }), whiteboardContainer.css({
            overflowY: "hidden",
            overflowX: "hidden"
        })), ActiveText.ViewUtils.isSinglePageView(activeTextInstance) ? (iframeElementWidth = Math.ceil(readerWidth * magnifiedScaleValue), 
        pageElementWidth = readerWidth) : (iframeElementWidth = Math.ceil(readerWidth * magnifiedScaleValue) / 2, 
        pageElementWidth = readerWidth / 2), dpsElement.height(readerHeight).width(dpsWidth), 
        individualPages.width(pageElementWidth).height(pageElementHeight), // empty children don't get scaled down, so we need to do that manually.
        dpsElement.children(":empty").width(readerWidth).height(readerHeight), // we want the left page to be slightly thinner, and then no gap in the middle!
        //        individualPages.filter('.leftPage').css({
        //            marginRight: -widthReduction
        //        });
        isNotZoomMode ? iframeWrappers.width(iframeElementWidth).height(iframeElementHeight) : iframeWrappers.width(pageElementWidth / (1 / scaleValue * magnificationValue)).height(pageElementHeight / (1 / scaleValue * magnificationValue));
        var isFullWindowScalingMode = activeTextInstance.utils.isFullWindowScalingMode();
        isFullWindowScalingMode && activeTextInstance.options.containerElement.css({
            minWidth: window.document.clientWidth,
            minHeight: window.document.clientHeight
        });
        var drawingToolsActive = !1, drawingTools = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "drawingtools");
        drawingTools && (drawingToolsActive = drawingTools.active);
        var isZoomMode = !isNotZoomMode;
        (isZoomMode && !drawingToolsActive || isSinglePageFitToWidth) && $(activeTextInstance).trigger(ActiveText.Commands.ENABLE_PAGE_DRAGGING);
    }
    function resetStyles(parentElement) {
        parentElement.css({
            padding: 0,
            left: "auto",
            marginTop: 0,
            marginBottom: 0
        });
    }
    function verticallyCenterWhiteboardInsideContainer(activeTextInstance, dimensions, whiteboardContainer) {
        var containerCoordinates = ActiveText.ViewUtils.getContainerCoordinates(activeTextInstance), verticalPaddingSpace = (dimensions.availHeight - dimensions.height) / 2;
        whiteboardContainer.css({
            top: verticalPaddingSpace + containerCoordinates.top,
            marginRight: containerCoordinates.right,
            bottom: verticalPaddingSpace + containerCoordinates.bottom,
            marginLeft: containerCoordinates.left
        });
    }
    function horizontallyAlign(dpsCollection) {
        dpsCollection.css({
            margin: "0",
            marginLeft: "auto",
            marginRight: "auto"
        });
    }
    function delayedResizeAction(dimensions, container, activeTextContainer, dpsCollection) {
        function setDimensions() {
            "zoom" !== activeTextInstance.view.model.getScaleMode() && whiteboardContainer.height(dimensions.height).width(dimensions.width), 
            container.height(dimensions.height).width(dimensions.width - 5);
        }
        function verticallyAlign() {
            verticallyCenterWhiteboardInsideContainer(activeTextInstance, dimensions, whiteboardContainer);
        }
        if (whiteboardContainer) {
            var horizontalDiff = (dimensions.availWidth - dimensions.width) / 2;
            "ftw" === activeTextInstance.view.model.getScaleMode() ? (resetStyles(activeTextContainer), 
            whiteboardContainer.css({
                left: horizontalDiff,
                top: 0
            })) : (setDimensions(), "zoom" === activeTextInstance.view.model.getScaleMode() ? whiteboardContainer.css({
                left: 0
            }) : (verticallyAlign(), horizontallyAlign(dpsCollection), whiteboardContainer.css({
                left: horizontalDiff
            })));
            var scaleValue = ActiveText.ViewUtils.getScaleValue(activeTextInstance), pageWrappers = dpsCollection.find(".rightPage, .leftPage"), iFrameWrappers = pageWrappers.find("div.iframe"), magnification = activeTextInstance.view.model.getMagnificationValue();
            if (Modernizr.csstransforms) ActiveText.ViewUtils.scaleHTMLElement(activeTextInstance, iFrameWrappers, 1 / scaleValue * magnification); else {
                var iframeElements = iFrameWrappers.find("iframe");
                ActiveText.ViewUtils.scaleHTMLElement(activeTextInstance, iframeElements, 1 / scaleValue * magnification);
                var transformValue = scaleValue;
                ActiveText.ViewUtils.isSinglePageView(activeTextInstance) && (transformValue = 1 / scaleValue), 
                iFrameWrappers.find("div").css({
                    width: 100 * transformValue + "%",
                    height: 100 * transformValue + "%"
                });
            }
            fitView(dimensions, dpsCollection, iFrameWrappers, scaleValue);
        }
    }
    function resizeReaderToFitContainer() {
        function delayedResizeActionCall() {
            delayedResizeAction(dimensions, whiteboard, $(activeTextInstance.options.containerElement), dpsCollection);
        }
        var dimensions = ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance), whiteboard = activeTextInstance.view.getContainer(), dpsCollection = activeTextInstance.view.getAllReaders();
        requestAnimationFrame(delayedResizeActionCall);
    }
    /**
     * @type {object}
     */
    var whiteboardContainer;
    return {
        init: init,
        register: register,
        deregister: deRegister
    };
}, /* global ActiveText, namespace */
/**
 * @class ViewFactory
 * @memberOf ActiveText
 */
ActiveText.ViewFactory = function(ActiveText) {
    "use strict";
    /**
     * Generates an individual page for the specified id and returns it.
     *
     * @param index {number}
     * @return {object}
     */
    function createIndividualPage(activeTextInstance, index) {
        var currentPage, pageNumber = ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, index), classNames = activeTextInstance.utils.updatePageClassNameFor(index);
        return currentPage = $("<div></div>").css({
            "float": "left",
            height: "100%",
            position: "relative"
        }).addClass(classNames + " page" + index).attr("data-page", pageNumber);
    }
    /**
     * @param index The page index to generate the DPS for.
     */
    function generateDPS(activeTextInstance, index) {
        var dpsElement = $("<div class='dps-container'></div>").css({
            margin: 0,
            height: "100%",
            width: "100%",
            position: "absolute",
            top: 0,
            display: "none",
            left: "100%"
        }), iOSversion = ActiveText.BrowserUtils.iOSversion[0];
        (!iOSversion || 7 > iOSversion) && dpsElement.css({
            transform: 7 > iOSversion ? "rotate(360deg)" : "translateZ(0)"
        });
        for (var frame, iFrames = activeTextInstance.view.getIFrames(), startIndex = 0, i = startIndex; 2 + startIndex > i; i++) frame = createIndividualPage(activeTextInstance, index + i), 
        iFrames[index + i] = frame, frame.appendTo(dpsElement), //TODO: Event below not actually used by anything
        $(activeTextInstance).trigger(ActiveText.Events.FRAME_CREATED, [ index + i ]);
        var rightEdge = activeTextInstance.view.getContainer().find(".rightEdge");
        rightEdge.length > 0 ? dpsElement.insertBefore(rightEdge) : dpsElement.appendTo(activeTextInstance.view.getContainer());
    }
    function createFrameForPage(activeTextInstance, index) {
        var newIndex = ActiveText.NavigationUtils.calculateLeftmostPageIndexFromIndex(activeTextInstance, index);
        generateDPS(activeTextInstance, newIndex);
    }
    function initialiseWhiteboard(activeTextInstance, containerElement) {
        var backgroundColor = activeTextInstance.theme.getPageBackgroundColor(), whiteboardTemplate = '<div class="whiteboard-container"><div class="whiteboard"></div></div>', whiteboardContainer = $(whiteboardTemplate).css({
            position: "relative",
            backgroundColor: backgroundColor,
            overflow: "hidden",
            display: "block"
        }).attr("role", "document");
        whiteboardContainer.appendTo(containerElement);
        var whiteboard = whiteboardContainer.find(".whiteboard");
        return whiteboard.css({
            backgroundColor: backgroundColor,
            position: "relative"
        }), whiteboardContainer;
    }
    function createPageContentsWithURL(activeTextInstance, sourceURL, index) {
        var iframeContainerElement = $('<div class="iframe"></div>').css({
            position: "absolute",
            background: "white"
        }), iframeAsString = '<iframe src="' + sourceURL + '" id="iframe' + index + '" scrolling="no" class="content" title="Page Content" role="main" frameborder="0" height="100%" width="100%" aria-atomic="true" aria-live="polite" aria-describedby="iframe-content-' + index + '" seamless></iframe>', contentsLink = ($(iframeAsString).css({
            position: "absolute",
            lineHeight: "normal",
            background: "white"
        }).appendTo(iframeContainerElement), $('<a id="iframe-content-' + index + '" aria-hidden="true" href="' + sourceURL + '">Accessible Link to Page ' + ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, index) + "</a>"));
        iframeContainerElement.append(contentsLink);
        var clickInteractionBlocker = $("<div style='position:absolute;top:0;bottom:0;left:0;right:0;background-color:rgba(0,0,0,0);'></div>");
        return $(iframeContainerElement).append(clickInteractionBlocker), iframeContainerElement;
    }
    return {
        createPageContentsWithURL: createPageContentsWithURL,
        createFrameForPage: createFrameForPage,
        initialiseWhiteboard: initialiseWhiteboard
    };
}(ActiveText), /* global ActiveText */
/**
 * @class MinimalPageEdgeFactory
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{generateEdges: generateEdges, removeEdges: removeEdges, minimumWidth: number}}
 * @constructor
 */
ActiveText.MinimalPageEdgeFactory = function(activeTextInstance) {
    "use strict";
    function refreshAllButtons() {
        $(nextButtons).each(function(index, element) {
            var canGoAgain = activeTextInstance.navigation.canGoToNextPage();
            canGoAgain ? $(element).removeClass("disabled").attr("aria-disabled", !1) : $(element).addClass("disabled").attr("aria-disabled", !0);
        }), $(prevButtons).each(function(index, element) {
            var canGoAgain = activeTextInstance.navigation.canGoToPreviousPage();
            canGoAgain ? $(element).removeClass("disabled").attr("aria-disabled", !1) : $(element).addClass("disabled").attr("aria-disabled", !0);
        });
    }
    function rightEdgeClickHandler() {
        $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
            which: "rightedge"
        }), activeTextInstance.navigation.gotoNextPage(), refreshAllButtons();
    }
    function leftEdgeClickHandler() {
        $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
            which: "leftedge"
        }), activeTextInstance.navigation.gotoPrevPage(), refreshAllButtons();
    }
    function injectCSSTag() {
        ActiveText.UI && ActiveText.UI.FontInjection && !ActiveText.UI.FontInjection.hasBeenAdded() && ActiveText.UI.FontInjection.injectFontTag();
        var cssString = ActiveText.MinimalPageEdgeFactory.Style.getStyle(activeTextInstance);
        ActiveText.CSSUtils.embedCSS(cssString, activeTextInstance.options.containerElement.selector + "-minimal-page-edge");
    }
    function onResize() {
        var dimensions = ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance), buttonWidth = -(dimensions.width - dimensions.availWidth) / 2, edges = $(leftEdge).add(rightEdge), buttons = $(leftEdge.find("i")).add(rightEdge.find("i")), horizontalMargins = 10;
        MINIMUM_OVERFLOW_WIDTH > buttonWidth ? (buttonWidth = MINIMUM_OVERFLOW_WIDTH, edges.addClass("overlap")) : edges.removeClass("overlap");
        var containerCoordinates = ActiveText.ViewUtils.getContainerCoordinates(activeTextInstance), controlsExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "controls"), barHeight = 0;
        controlsExtension && (barHeight = controlsExtension.getBarHeight()), edges.css({
            width: buttonWidth,
            height: dimensions.availHeight + containerCoordinates.top + (containerCoordinates.bottom - barHeight)
        }), buttonWidth > MAX_FONT_ICON_SIZE && (horizontalMargins = (buttonWidth - MAX_FONT_ICON_SIZE) / 2, 
        buttonWidth = MAX_FONT_ICON_SIZE), buttons.css({
            fontSize: buttonWidth,
            lineHeight: Math.floor(.7 * buttonWidth) + "px",
            marginTop: (dimensions.availHeight - Math.floor(buttonWidth) / 2) / 2,
            paddingLeft: horizontalMargins,
            paddingRight: horizontalMargins
        }), buttonWidth === MINIMUM_OVERFLOW_WIDTH && (leftEdge.width(buttonWidth + 2 * horizontalMargins), 
        rightEdge.width(buttonWidth + 2 * horizontalMargins));
    }
    function generateEdges(container) {
        injectCSSTag(), container = container.parent().parent(), activeTextInstance.utils.isFullWindowScalingMode() || container.css({
            position: "relative"
        });
        var leftEdgeString = '<div class="minimal-edge leftEdge" role="button" tabindex="0" title="Previous Page" aria-label="Previous Page"><a role="presentation"><i class="icon-angle-left"></i></a></div>';
        leftEdge = $(leftEdgeString).css({
            left: 0,
            position: "absolute",
            top: 0,
            bottom: 0,
            zIndex: 1e3,
            textDecoration: "none"
        }), leftEdge.find("a").css({
            left: 0,
            right: 0,
            position: "absolute",
            top: 0,
            bottom: 0,
            textAlign: "center"
        }), leftEdge.find("i").css({
            display: "inline-block"
        }), prevButtons.push(leftEdge);
        var rightEdgeString = '<div class="minimal-edge rightEdge" role="button" tabindex="1" title="Next Page" aria-label="Next Page"><a role="presentation"><i class="icon-angle-right"></i></a></div>';
        rightEdge = $(rightEdgeString).css({
            right: 0,
            position: "absolute",
            top: 0,
            bottom: 0,
            zIndex: 1e3,
            textDecoration: "none"
        }), rightEdge.find("a").css({
            left: 0,
            right: 0,
            position: "absolute",
            top: 0,
            bottom: 0,
            textAlign: "center"
        }), rightEdge.find("i").css({
            display: "inline-block"
        }), nextButtons.push(rightEdge), activeTextInstance.navigation.canGoToNextPage() || rightEdge.addClass("disabled").attr("aria-disabled", !0), 
        activeTextInstance.navigation.canGoToPreviousPage() || leftEdge.addClass("disabled").attr("aria-disabled", !0), 
        onResize();
        var whiteboardContainer = container.find(".whiteboard-container");
        leftEdge.insertAfter(whiteboardContainer), rightEdge.insertAfter(whiteboardContainer), 
        rightEdge.click(rightEdgeClickHandler), leftEdge.click(leftEdgeClickHandler), $(activeTextInstance).one(ActiveText.Events.BOOK_STRUCTURE_LOADED, refreshAllButtons), 
        $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, refreshAllButtons), $(activeTextInstance).on(ActiveText.Events.RESIZE, onResize);
    }
    function removeEdges() {
        leftEdge.remove(), rightEdge.remove(), nextButtons = [], prevButtons = [], $(activeTextInstance).off(ActiveText.Events.BOOK_STRUCTURE_LOADED, refreshAllButtons), 
        $(activeTextInstance).off(ActiveText.Commands.GO_TO_PAGE, refreshAllButtons), $(activeTextInstance).off(ActiveText.Events.RESIZE, onResize);
    }
    /** @const */
    var leftEdge, rightEdge, MINIMUM_OVERFLOW_WIDTH = 44, MAX_FONT_ICON_SIZE = 100, nextButtons = [], prevButtons = [];
    return {
        generateEdges: generateEdges,
        removeEdges: removeEdges,
        minimumWidth: 64
    };
}, /* global ActiveText */
ActiveText.namespace("ActiveText.MinimalPageEdgeFactory.Style"), ActiveText.MinimalPageEdgeFactory.Style = function() {
    "use strict";
    function getStyle(activeTextInstance) {
        var edgeColor = activeTextInstance.theme.getControlsForegroundColor(), overlapEdgeColor = activeTextInstance.theme.getControlsAltForegroundColor(), backgroundColor = activeTextInstance.theme.getPageBackgroundColor(.5), hoverColor = activeTextInstance.theme.getControlsForegroundHoverColor(), altHoverColor = activeTextInstance.theme.getControlsAltForegroundHoverColor(), scope = activeTextInstance.options.containerElement.selector + " ", useHoverStyles = !ActiveText.BrowserUtils.isMobileDevice;
        return scope + ".minimal-edge," + scope + ".minimal-edge a{text-decoration:none;color:" + overlapEdgeColor + ';-webkit-transition: all .3s;-moz-transition: all .3s;-ms-transition: all .3s;-o-transition: all .3s;transition: all .3s;-webkit-touch-callout: none;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;font-family: "Segoe UI", Tahoma, sans-serif;outline:none;}' + scope + ".minimal-edge a," + scope + ".minimal-edge a:link," + (useHoverStyles ? scope + ".minimal-edge a:hover," : "") + scope + ".minimal-edge a:active," + scope + ".minimal-edge a:focus {background-color:transparent;text-decoration:none;}" + scope + '.minimal-edge a i {font-style:normal;-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";filter:alpha(opacity=50);opacity:0.5;}' + scope + ".minimal-edge.overlap," + scope + ".minimal-edge.overlap a{color:" + edgeColor + ";}" + scope + ".minimal-edge.disabled a," + (useHoverStyles ? ".minimal-edge.disabled a:hover," : "") + scope + ".minimal-edge.disabled a:active," + scope + ".minimal-edge.disabled a:focus{cursor:default;color:transparent}" + (useHoverStyles ? scope + ".minimal-edge a:hover," : "") + scope + ".minimal-edge a:active," + scope + ".minimal-edge a:focus{color:" + hoverColor + ";background-color:" + backgroundColor + ';cursor:pointer;-webkit-transition: all .3s;-moz-transition: all .3s;-ms-transition: all .3s;-o-transition: all .3s;transition: all .3s;-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=50)";filter:alpha(opacity=50);}' + (useHoverStyles ? scope + ".minimal-edge a:hover i," : "") + scope + ".minimal-edge a:active i," + scope + '.minimal-edge a:focus i{-ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=100)";filter:alpha(opacity=100);opacity:1;}' + (useHoverStyles ? scope + ".minimal-edge.overlap a:hover," : "") + scope + ".minimal-edge.overlap a:active," + scope + ".minimal-edge.overlap a:focus{color:" + altHoverColor + ";}" + scope + ".minimal-edge.disabled," + scope + ".minimal-edge.disabled a:link," + (useHoverStyles ? scope + ".minimal-edge.disabled a:hover," : "") + scope + ".minimal-edge.disabled a:active," + scope + ".minimal-edge.disabled a:focus{color:transparent;cursor:default;background-color:transparent;}";
    }
    return {
        getStyle: getStyle
    };
}(), /* global ActiveText, _, Modernizr */
ActiveText.LayerUtils = function() {
    "use strict";
    /**
     * @param convertedIndex {number}
     * @param key {string}
     * @returns {jQuery}
     */
    function getOverlayForIndex(activeTextInstance, convertedIndex, key) {
        var page = ActiveText.ViewUtils.getFrameForPageByIndex(activeTextInstance, convertedIndex);
        return getOrCreateOverlayContainerForPage(activeTextInstance, page, convertedIndex, key);
    }
    /**
     * @param page {jQuery}
     * @param convertedIndex {number}
     * @param key {string}
     * @returns {jQuery}
     */
    function getOrCreateOverlayContainerForPage(activeTextInstance, page, convertedIndex, key) {
        var rtn;
        if (void 0 !== page) {
            var host = page.parent(), pageClassName = activeTextInstance.utils.updatePageClassNameFor(convertedIndex), existingRef = $(host.find("div." + pageClassName + " div." + key));
            rtn = 0 === existingRef.length ? createOverlayByKey(activeTextInstance, host, convertedIndex, key) : existingRef, 
            rtn && rtn.css("top", 0);
        }
        return rtn;
    }
    /**
     * @param host {jQuery}
     * @param convertedIndex {number}
     * @param key {string}
     * @returns {jQuery}
     */
    function createOverlayByKey(activeTextInstance, host, convertedIndex, key) {
        var returnKeyZindex = function() {
            var zIndex;
            return "drawing" === key ? zIndex = drawingToolsAreActive ? 30 : 0 : "annotations" === key ? zIndex = drawingToolsAreActive ? 20 : 40 : "standalone_hotspots" === key && (zIndex = drawingToolsAreActive ? 10 : 30), 
            zIndex;
        }, newChild = $("<div/>").addClass(key + " page" + convertedIndex).css({
            position: "absolute",
            "z-index": returnKeyZindex,
            pointerEvents: "none"
        }), targetContainer = $(host.find("div." + activeTextInstance.utils.updatePageClassNameFor(convertedIndex)));
        $(targetContainer).children("." + key).remove();
        var newLayerShouldBeVisible = getLayerVisibility(activeTextInstance, key);
        return newLayerShouldBeVisible || newChild.hide(), newChild.appendTo(targetContainer), 
        newChild;
    }
    /**
     * @param key {string}
     */
    function hideLayerByKey(activeTextInstance, key) {
        activeTextInstance.view.getOverlayElements().filter("." + key).hide();
    }
    /**
     * @param key {string}
     */
    function showLayerByKey(activeTextInstance, key) {
        activeTextInstance.view.getOverlayElements().filter("." + key).show();
    }
    /**
     * @param layerKey {string}
     * @param visibleBoolean {boolean}
     */
    function setLayerVisibility(activeTextInstance, layerKey, visibleBoolean) {
        layerKey && "string" == typeof layerKey && (getModelForInstance(activeTextInstance)[layerKey] = Boolean(visibleBoolean)), 
        Boolean(visibleBoolean) ? showLayerByKey(activeTextInstance, layerKey) : hideLayerByKey(activeTextInstance, layerKey);
    }
    function getModelForInstance(activeTextInstance) {
        var rtn;
        return activeTextInstance && (void 0 === activeTextInstance.layerVisibility && (activeTextInstance.layerVisibility = {}), 
        rtn = activeTextInstance.layerVisibility), rtn;
    }
    /**
     * @param layerKey {string}
     * @returns {boolean}
     */
    function getLayerVisibility(activeTextInstance, layerKey) {
        var modelForInstance = getModelForInstance(activeTextInstance);
        return Boolean(modelForInstance && modelForInstance[layerKey] !== !1);
    }
    function bringLayerToFront(activeTextInstance) {
        drawingToolsAreActive = !0, toggleAnnotationLayers(), disableDraggingWhenDrawing(activeTextInstance, drawingToolsAreActive);
    }
    function returnLayerToOriginalDepth(activeTextInstance) {
        drawingToolsAreActive = !1, toggleAnnotationLayers(), disableDraggingWhenDrawing(activeTextInstance, drawingToolsAreActive);
    }
    function disableDraggingWhenDrawing(activeTextInstance, drawingToolsAreActive) {
        var scaleMode = activeTextInstance.view.model.getScaleMode();
        if ("ftw" === scaleMode) if (drawingToolsAreActive) {
            var whiteboard = $(".whiteboard");
            try {
                activeTextInstance.view.getContainer().draggable("disable");
            } catch (e) {
                // do nothing
                activeTextInstance.view.getContainer().data({
                    uiDraggable: !1
                });
            }
            whiteboard.css("opacity", 1);
        } else try {
            activeTextInstance.view.getContainer().draggable("enable");
        } catch (e) {
            // do nothing
            activeTextInstance.view.getContainer().data({
                uiDraggable: !0
            });
        }
    }
    function returnDrawingToolsState() {
        return drawingToolsAreActive;
    }
    function toggleAnnotationLayers() {
        drawingToolsAreActive === !0 ? ($(".drawing").css("z-index", "30"), $(".standalone_hotspots").css("z-index", "10"), 
        $(".annotations").css("z-index", "20")) : drawingToolsAreActive === !1 && ($(".drawing").css("z-index", "0"), 
        $(".standalone_hotspots").css("z-index", "30"), $(".annotations").css("z-index", "40"));
    }
    var drawingToolsAreActive = !1;
    return {
        bringLayerToFront: bringLayerToFront,
        returnLayerToOriginalDepth: returnLayerToOriginalDepth,
        getOverlayForIndexByKey: getOverlayForIndex,
        setLayerVisibility: setLayerVisibility,
        getLayerVisibility: getLayerVisibility,
        disableDraggingWhenDrawing: disableDraggingWhenDrawing,
        returnDrawingToolsState: returnDrawingToolsState
    };
}(), /* global ActiveText */
ActiveText.View = ActiveText.View || {}, /**
 * @class Controller
 * @memberOf ActiveText.View
 * @param activeTextInstance {ActiveText}
 * @returns {{init: init}}
 * @constructor
 */
ActiveText.View.Controller = function(activeTextInstance) {
    "use strict";
    function init() {
        var signalBus = $(activeTextInstance);
        signalBus.on(ActiveText.Commands.SWITCH_TO_DPS_VIEW, switchToDPSView), signalBus.on(ActiveText.Commands.SWITCH_TO_SPS_VIEW, switchToSinglePageFitToHeightView), 
        signalBus.on(ActiveText.Commands.SWITCH_TO_SPS_FTW_VIEW, switchToSinglePageFitToWidthView), 
        signalBus.on(ActiveText.Commands.SWITCH_TO_ZOOM_MODE, switchToZoomMode);
    }
    function scrollContainerToTop() {
        activeTextInstance.options.containerElement.find(".whiteboard-container,.whiteboard").animate({
            scrollTop: 0
        }, 0);
    }
    function switchToDPSView() {
        if (ActiveText.ViewUtils.isSinglePageView(activeTextInstance)) {
            var currentIndex = activeTextInstance.model.getCurrentPageNumber();
            activeTextInstance.view.model.setDisplayedPages(2), setScalingModeToFitToHeight(), 
            activeTextInstance.navigation.gotoPage(currentIndex, !0), $(activeTextInstance).trigger(ActiveText.Events.VIEW_MODE_CHANGED), 
            $(activeTextInstance).trigger(ActiveText.Events.RESIZE);
        }
    }
    function switchToZoomMode() {
        activeTextInstance.options.containerElement.find(".whiteboard-container,.whiteboard").animate({
            top: 0,
            scrollTop: 0
        }, 0), activeTextInstance.view.model.setScaleMode("zoom"), $(activeTextInstance).trigger(ActiveText.Events.VIEW_MODE_CHANGED), 
        $(activeTextInstance).trigger(ActiveText.Events.RESIZE);
    }
    function setScalingModeToFitToWidth() {
        activeTextInstance.view.model.setScaleMode("ftw");
    }
    function setScalingModeToFitToHeight() {
        "zoom" !== activeTextInstance.view.model.getScaleMode() && (scrollContainerToTop(), 
        activeTextInstance.view.model.setScaleMode("fth"));
    }
    function switchToSinglePageView() {
        activeTextInstance.view.getContainer().parent().css({
            overflow: "hidden"
        });
        // todo: I'm sure there's a cleaner way to ask this.
        var isInDPSViewMode = Boolean(activeTextInstance.view.model.getDisplayedPages() > 1);
        if (isInDPSViewMode) {
            var leftMostPageNumber = activeTextInstance.model.getCurrentPageNumber();
            activeTextInstance.view.model.setDisplayedPages(1), activeTextInstance.navigation.gotoPage(leftMostPageNumber, !0);
        }
    }
    function switchToSinglePageFitToWidthView() {
        switchToSinglePageView(), setScalingModeToFitToWidth(), $(activeTextInstance).trigger(ActiveText.Events.VIEW_MODE_CHANGED), 
        $(activeTextInstance).trigger(ActiveText.Events.RESIZE);
    }
    function switchToSinglePageFitToHeightView() {
        switchToSinglePageView(), setScalingModeToFitToHeight(), $(activeTextInstance).trigger(ActiveText.Events.VIEW_MODE_CHANGED), 
        $(activeTextInstance).trigger(ActiveText.Events.RESIZE);
    }
    return {
        init: init
    };
}, /* global ActiveText, Spinner, NProgress */
ActiveText.View = ActiveText.View || {}, /**
 * @class Loader
 * @memberOf ActiveText.View
 * @param activeTextInstance {ActiveText}
 * @returns {{register: register, showOn: showOn, hideOn: hideOn}}
 * @constructor
 */
ActiveText.View.Loader = function(activeTextInstance) {
    "use strict";
    function register() {
        function teardown() {
            $(activeTextInstance.options.containerElement).off("remove", teardown), NProgress.configure({
                containerElement: void 0,
                showSpinner: !ActiveText.BrowserUtils.isOldVersionOfInternetExplorer
            }), $(document).off("ajaxStart", showLoader).off("ajaxComplete", hideLoader);
        }
        new ActiveText.View.Loader.Styles().init(activeTextInstance), NProgress.configure({
            containerElement: $("#messages-placeholder")
        }), $(document).ajaxStart(showLoader).ajaxComplete(hideLoader), $(activeTextInstance).on(ActiveText.Commands.SHOW_LOADER, forceShowLoader), 
        $(activeTextInstance).on(ActiveText.Commands.HIDE_LOADER, forceHideLoader), activeTextInstance.options && activeTextInstance.options.containerElement && $(activeTextInstance.options.containerElement).on("remove", teardown);
    }
    function forceShowLoader() {
        forced = !0, showLoader();
    }
    function forceHideLoader() {
        forced = !1, hideLoader();
    }
    function showLoader() {
        NProgress.start();
    }
    function showOn(eventNamesArray) {
        for (var event, i = 0, l = eventNamesArray.length; l > i; i++) event = eventNamesArray[i], 
        $(activeTextInstance).on(event, showLoader);
    }
    function hideLoader() {
        forced ? NProgress.inc() : NProgress.done();
    }
    function hideOn(eventNamesArray) {
        for (var event, i = 0, l = eventNamesArray.length; l > i; i++) event = eventNamesArray[i], 
        $(activeTextInstance).on(event, hideLoader);
    }
    /**
     * @type {boolean}
     */
    var forced = !1;
    return {
        register: register,
        showOn: showOn,
        hideOn: hideOn
    };
}, /* global ActiveText, ActiveText, Modernizr */
ActiveText.View.Loader.Styles = function() {
    "use strict";
    function init(activeTextInstance) {
        var bgColor = activeTextInstance.theme.getBackgroundColor(), fgColor = activeTextInstance.theme.getControlsForegroundHoverColor(), keyColor = fgColor;
        bgColor === fgColor && (keyColor = activeTextInstance.theme.getControlsForegroundColor());
        var cssStr = "#nprogress {pointer-events:none;-webkit-pointer-events:none;}#nprogress .bar {background:" + keyColor + ";position:absolute;z-index:100;top:0;left:0;width:100%;height:4px;}/* Fancy blur effect */#nprogress .peg {display:block;position:absolute;right:0px;width:100px;height:100%;box-shadow:0 0 10px " + keyColor + ", 0 0 5px " + keyColor + ";opacity:1.0;-webkit-transform:rotate(3deg) translate(0px, -4px);-moz-transform:rotate(3deg) translate(0px, -4px);-ms-transform:rotate(3deg) translate(0px, -4px);-o-transform:rotate(3deg) translate(0px, -4px);transform:rotate(3deg) translate(0px, -4px);}/* Remove these to get rid of the spinner */#nprogress .spinner {display:block;position:absolute;z-index:100;top:15px;right:15px;}.leftPage .spinner {display:block;position:absolute;top:50%;left:25%;}.rightPage .spinner {display:block;position:absolute;top:50%;left:75%;}#nprogress .spinner-icon,.leftPage .spinner-icon,.rightPage .spinner-icon {width:14px;height:14px;border: solid 2px transparent;border-top-color: " + keyColor + ";border-left-color:" + keyColor + ";border-radius:10px;-webkit-animation:nprogress-spinner 400ms linear infinite;-moz-animation:nprogress-spinner 400ms linear infinite;-ms-animation:nprogress-spinner 400ms linear infinite;-o-animation:nprogress-spinner 400ms linear infinite;animation:nprogress-spinner 400ms linear infinite;}@-webkit-keyframes nprogress-spinner {0%   { -webkit-transform:rotate(0deg);   transform:rotate(0deg); }100% { -webkit-transform:rotate(360deg); transform:rotate(360deg); }}@-moz-keyframes nprogress-spinner {0%   { -moz-transform:rotate(0deg);   transform:rotate(0deg); }100% { -moz-transform:rotate(360deg); transform:rotate(360deg); }}@-o-keyframes nprogress-spinner {0%   { -o-transform:rotate(0deg);   transform:rotate(0deg); }100% { -o-transform:rotate(360deg); transform:rotate(360deg); }}@-ms-keyframes nprogress-spinner {0%   { -ms-transform:rotate(0deg);   transform:rotate(0deg); }100% { -ms-transform:rotate(360deg); transform:rotate(360deg); }}@keyframes nprogress-spinner {0%   { transform:rotate(0deg);   transform:rotate(0deg); }100% { transform:rotate(360deg); transform:rotate(360deg); }}";
        ActiveText.CSSUtils.embedCSS(cssStr, "view-loader");
    }
    return {
        init: init
    };
}, /* global ActiveText */
/**
 * @class ZoomController
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{register: register, deregister: deregister}}
 * @constructor
 */
ActiveText.ZoomController = function(activeTextInstance) {
    "use strict";
    /**
     * @param event {object}
     * @param spreadHeight {int}
     * @param spreadWidth {int}
     */
    function enableMouseDragScrolling() {
        var options = {}, visiblePages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance);
        options.isSPS = ActiveText.ViewUtils.isSinglePageView(activeTextInstance), options.isRightMostPage = ActiveText.ViewUtils.isTheRightHandPage(activeTextInstance, visiblePages);
        {
            var dimensions = ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance), magnificationValue = activeTextInstance.view.model.getMagnificationValue(), spreadWidth = (options.isSPS ? dimensions.width : dimensions.dpswidth) * magnificationValue, spreadHeight = (options.isSPS ? dimensions.height : dimensions.dpsheight) * magnificationValue, scaleMode = activeTextInstance.view.model.getScaleMode();
            activeTextInstance.view.getContainer().find(".animate-container");
        }
        return "ftw" === scaleMode && (options.axis = "y"), activeTextInstance.options.fitToWidthPageDragging === !1 ? void allowWhiteBoardContainerToScroll(!0) : (applyZoomDraggableBehaviours(spreadHeight, spreadWidth, options), 
        void ActiveText.LayerUtils.disableDraggingWhenDrawing(activeTextInstance, ActiveText.LayerUtils.returnDrawingToolsState()));
    }
    /**
     * @param {object} event
     */
    function disableMouseDragScrolling() {
        try {
            activeTextInstance.view.getContainer().draggable("destroy"), activeTextInstance.view.getContainer().parent().draggable("destroy");
        } catch (e) {}
    }
    /**
     * @param {boolean} allow
     */
    function allowWhiteBoardContainerToScroll() {
        var whiteboardContainer = activeTextInstance.view.getContainer().parent();
        whiteboardContainer.css({
            top: 0,
            height: "auto"
        });
    }
    function applyZoomDraggableBehaviours(spreadHeight, spreadWidth, extraOptions) {
        //        console.log('applyZoomDraggableBehaviours');
        var whiteboardContainer = activeTextInstance.view.getContainer().parent(), animateContainer = whiteboardContainer.find(".animate-container");
        $("#panContainer").length < 1 && whiteboardContainer.parent().prepend('<div id="panContainer"></div>');
        var containerCoordinates = ActiveText.ViewUtils.getContainerCoordinates(activeTextInstance), targetHeight = whiteboardContainer.parent().height() - (containerCoordinates.top + containerCoordinates.bottom), targetWidth = whiteboardContainer.parent().width() - (containerCoordinates.left + containerCoordinates.right), cssLeft = containerCoordinates.left, verticalOverlap = spreadHeight - targetHeight, horizontalOverlap = spreadWidth - targetWidth;
        0 > verticalOverlap && (verticalOverlap = 0), 0 > horizontalOverlap && (cssLeft = -horizontalOverlap / 2, 
        horizontalOverlap = 0, targetWidth = spreadWidth), whiteboardContainer.css("left", cssLeft), 
        $("#panContainer").css({
            position: "absolute",
            height: 2 * verticalOverlap + targetHeight,
            width: 2 * horizontalOverlap + targetWidth,
            marginTop: -verticalOverlap,
            marginLeft: -horizontalOverlap,
            top: containerCoordinates.top,
            left: cssLeft
        }), extraOptions.isSPS && extraOptions.isRightMostPage ? setTimeout(function() {
            animateContainer.css("left", -spreadWidth);
        }, 250) : animateContainer.css("left", 0);
        try {
            activeTextInstance.view.getContainer().draggable("destroy"), activeTextInstance.view.getContainer().parent().draggable("destroy");
        } catch (e) {}
        var defaults = {
            containment: "#panContainer"
        };
        ActiveText.BrowserUtils.isOldVersionOfInternetExplorer && (//defaults.iframeFix = $('iframe');
        defaults.create = function() {
            var i, element, elements = $("iframe ~ div");
            for (i = 0; i < elements.length; i++) element = $(elements[i]), ActiveText.ViewUtils.setOpacityValue(element, 0), 
            element.css({
                backgroundColor: "#000"
            });
        });
        var options = $.extend({}, defaults, extraOptions);
        if ("ftw" === activeTextInstance.view.model.getScaleMode()) try {
            activeTextInstance.view.getContainer().draggable(options);
        } catch (e) {} else try {
            activeTextInstance.view.getContainer().parent().draggable(options);
        } catch (e) {}
    }
    /**
     * @param event {object}
     * @param mode {string}
     */
    function reactToScalingModeChange(event, mode) {
        var whiteboard = activeTextInstance.view.getContainer(), edgeFactory = activeTextInstance.view.getEdgeFactory(), isDoublePageView = ActiveText.ViewUtils.isDoublePageView(activeTextInstance);
        if (edgeFactory && edgeFactory.removeEdges && edgeFactory.removeEdges(), "zoom" === mode) $(activeTextInstance).trigger(isDoublePageView ? ActiveText.Commands.SWITCH_TO_DPS_VIEW : ActiveText.Commands.SWITCH_TO_SPS_VIEW), 
        disableAllPageInteractions(), whiteboard.css({
            cursor: "move"
        }), activeTextInstance.options.containerElement.css({
            overflow: "hidden"
        }), allowWhiteBoardContainerToScroll(!1); else if ("ftw" === mode) $("#panContainer").remove(), 
        edgeFactory && edgeFactory.generateEdges && edgeFactory.generateEdges(whiteboard), 
        disableAllPageInteractions(), activeTextInstance.options.containerElement.css({
            overflow: "hidden"
        }), $(activeTextInstance.view.getContainer()).css({
            cursor: "move"
        }); else {
            $("#panContainer").remove(), edgeFactory && edgeFactory.generateEdges && edgeFactory.generateEdges(whiteboard), 
            whiteboard.css({
                top: 0,
                left: 0,
                cursor: ""
            });
            try {
                ActiveText.BrowserUtils.isOldVersionOfInternetExplorer && $("iframe ~ div").css({
                    background: "none"
                }), whiteboard.draggable("destroy"), whiteboard.parent().draggable("destroy");
            } catch (e) {}
            enableAllPageInteractions();
        }
        $(activeTextInstance).trigger(ActiveText.Events.RESIZE);
    }
    function disableAllPageInteractions() {
        activeTextInstance.view.disableInteraction();
    }
    function enableAllPageInteractions() {
        activeTextInstance.view.enableInteraction();
    }
    function register() {
        $(activeTextInstance).on(ActiveText.Commands.ENABLE_PAGE_DRAGGING, enableMouseDragScrolling), 
        $(activeTextInstance).on(ActiveText.Commands.DISABLE_PAGE_DRAGGING, disableMouseDragScrolling), 
        $(activeTextInstance).on(ActiveText.Events.CHANGE_SCALING_MODE, reactToScalingModeChange);
    }
    function deregister() {
        $(activeTextInstance).off(ActiveText.Commands.ENABLE_PAGE_DRAGGING, enableMouseDragScrolling), 
        $(activeTextInstance).off(ActiveText.Commands.DISABLE_PAGE_DRAGGING, disableMouseDragScrolling), 
        $(activeTextInstance).off(ActiveText.Events.CHANGE_SCALING_MODE, reactToScalingModeChange);
    }
    return {
        register: register,
        deregister: deregister
    };
}, /* global ActiveText */
/**
 * @class Notes
 * @memberOf ActiveText
 * @returns {{init: init, key: string, hideNotes: hideNotes, showNotes: showNotes, loadData: undefined}}
 * @constructor
 */
ActiveText.Notes = function() {
    "use strict";
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        activeTextInstance = instance, factory = new ActiveText.NoteFactory(activeTextInstance), 
        data = new ActiveText.NoteDataService(activeTextInstance), api.loadData = data.loadData, 
        ActiveText.CSSUtils.embedCSS(ActiveText.Notes.Style);
        var containerResizeFunction = ActiveText.ResizeUtils.getNonProportionalResizeBehaviour(activeTextInstance, LAYER_KEY);
        $(data).on(ActiveText.Events.LOADED_NOTES_FOR_INDEX, onNotesDataLoaded), $(activeTextInstance).on(ActiveText.Events.RESIZE, containerResizeFunction), 
        $(activeTextInstance.options.containerElement).on(ActiveText.Notes.Events.UPDATE, "." + LAYER_KEY, onNoteUpdated);
    }
    /**
     * @param event {event}
     * @param eventData {{data:object, index:number}}
     */
    function onNotesDataLoaded(event, eventData) {
        var data = eventData.data, convertedIndex = eventData.index, overlayWrapperElement = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, convertedIndex, LAYER_KEY);
        overlayWrapperElement.empty();
        for (var i = 0, l = data.length; l > i; i++) "note" === data[i].type && 0 !== data[i].data.text.length && renderNoteFromDataOnPage(data[i].data, overlayWrapperElement);
    }
    /**
     * @returns {array}
     */
    function getDataForAllNotes() {
        function pushDataForEachNote(index, value) {
            rtn.push(factory.getDataRepresentation(value));
        }
        for (var currentFrame, rtn, currentIndex = activeTextInstance.model.getCurrentIndex(), i = 0, l = activeTextInstance.view.model.getDisplayedPages(); l > i; i++) rtn = [], 
        currentFrame = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, currentIndex + i, LAYER_KEY), 
        $(currentFrame).find(".note-container").each(pushDataForEachNote), data.setCacheForPage(currentIndex + i, rtn);
        return rtn;
    }
    function onNoteUpdated() {
        getDataForAllNotes();
    }
    function renderNoteFromDataOnPage(data, page) {
        var newNote = factory.renderNoteFromData(data);
        page.append(newNote);
    }
    function hideNotes() {
        notesVisible = !1, ActiveText.LayerUtils.setLayerVisibility(activeTextInstance, LAYER_KEY, !1);
    }
    function showNotes() {
        notesVisible = !0, ActiveText.LayerUtils.setLayerVisibility(activeTextInstance, LAYER_KEY, !0);
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, factory, data, notesVisible = !0, LAYER_KEY = "annotations", api = {
        init: init,
        key: "notes",
        hideNotes: hideNotes,
        showNotes: showNotes,
        loadData: void 0
    };
    return api;
}, /* global ActiveText */
ActiveText.Notes.Events = {
    UPDATE: "update"
}, /* global ActiveText */
/**
 * @class NoteDataService
 * @memberOf ActiveText
 * @param {ActiveText} activeTextInstance
 * @returns {{setCacheForPage: setCacheForPage, loadData: loadData}}
 * @constructor
 */
ActiveText.NoteDataService = function(activeTextInstance) {
    "use strict";
    function init() {
        backupClass = new ActiveText.NoteDataJStorageService(api), $(activeTextInstance).on(ActiveText.Events.FRAME_CONTENT_LOADED, fetchNotesDataForPage), 
        $(activeTextInstance).on(ActiveText.Events.LOADED_OVERLAY_DATA, fetchNotesDataForPage);
    }
    /**
     * @param pageIndex {number}
     * @param data {object}
     */
    function setCacheForPage(pageIndex, data) {
        "function" == typeof activeTextInstance.options.noteSetDataFunction ? activeTextInstance.options.noteSetDataFunction(activeTextInstance, pageIndex, data) : backupClass.noteSetDataFunction(pageIndex, data);
    }
    /**
     * @param pageIndex {number}
     */
    function getCacheForPage(pageIndex) {
        "function" == typeof activeTextInstance.options.noteLoadDataFunction ? activeTextInstance.options.noteLoadDataFunction(activeTextInstance, pageIndex) : backupClass.noteLoadDataFunction(pageIndex);
    }
    /**
     * @param pageIndex {number}
     * @param data {object}
     */
    function loadData(pageIndex, data) {
        dataIsValid(data) && $(api).trigger(ActiveText.Events.LOADED_NOTES_FOR_INDEX, {
            index: pageIndex,
            data: data
        });
    }
    /**
     * @param event {object}
     * @param eventData {{index:number, data:Object}}
     */
    function fetchNotesDataForPage(event, eventData) {
        var index = eventData.index;
        getCacheForPage(index);
    }
    /**
     * @param data {array}
     * @returns {boolean}
     */
    function dataIsValid(data) {
        return Boolean($.isArray(data) && data.length > 0);
    }
    /**
     * @type {ActiveText.NoteDataJStorageService}
     */
    var backupClass, api = {
        setCacheForPage: setCacheForPage,
        loadData: loadData
    };
    return init(), api;
}, /* global ActiveText */
/**
 * @class NoteDataJStorageService
 * @memberOf ActiveText
 * @param parentClass
 * @returns {{noteSetDataFunction: noteSetDataFunction, noteLoadDataFunction: noteLoadDataFunction}}
 * @constructor
 */
ActiveText.NoteDataJStorageService = function(parentClass) {
    "use strict";
    function noteLoadDataFunction(pageIndex) {
        var data = getStoredDataForPage(pageIndex);
        parentClass.loadData(pageIndex, data);
    }
    function getStoredDataForPage(pageIndex) {
        return $.jStorage.get(bookId + "-" + pageIndex + "-" + userId, void 0);
    }
    function noteSetDataFunction(page, data) {
        return $.jStorage.set(bookId + "-" + page + "-" + userId, data);
    }
    /**
     * @type {number}
     */
    var userId = 1, bookId = 1, api = {
        noteSetDataFunction: noteSetDataFunction,
        noteLoadDataFunction: noteLoadDataFunction
    };
    return api;
}, /* global ActiveText*/
ActiveText.namespace("ActiveText.Notes.Style"), ActiveText.Notes.Style = 'div.annotations {position: relative;z-index: 1;overflow: visible;list-style: none;margin: 0;padding: 0;pointer-events: none}div.annotations div.note {position: relative;float: left;padding: 0;background: #ffcc00;background: -moz-linear-gradient(top,  #ffcc00 0%, #ffdf60 100%);background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#ffcc00), color-stop(100%,#ffdf60));background: -webkit-linear-gradient(top,  #ffcc00 0%,#ffdf60 100%);background: -o-linear-gradient(top,  #ffcc00 0%,#ffdf60 100%);background: -ms-linear-gradient(top,  #ffcc00 0%,#ffdf60 100%);background: linear-gradient(to bottom,  #ffcc00 0%,#ffdf60 100%);filter: progid:DXImageTransform.Microsoft.gradient( startColorstr="#ffcc00", endColorstr="#ffdf60",GradientType=0 );-webkit-box-shadow: 0 3px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;-moz-box-shadow: 0 3px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;box-shadow: 0 3px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset;}div.annotations div.note textarea {background: transparent;background: rgba(255,255,255,0.2);border: none;outline: none;resize: none;width:100%;height:100%;}div.annotations div.note div.close {position: absolute;top:0;right:0;padding:6px 8px 12px;line-height:8px;cursor:pointer;background:transparent}div.annotations div.note div.close a {color:black;text-decoration:none}div.annotations div.note div.close a:hover {color:red}div.annotations div.note div.content {word-wrap: break-word;position: absolute;top: 25px;bottom: 10px;left: 10px;right: 10px;overflow: hidden}div.annotations div.note:before,div.annotations div.note:after {content: "";z-index: -1;position: absolute;left: 10px;bottom: 10px;width: 70%;max-width: 300px;max-height: 100px;height: 55%;-webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);-moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);-webkit-transform: skew(-15deg) rotate(-6deg);-moz-transform: skew(-15deg) rotate(-6deg);-ms-transform: skew(-15deg) rotate(-6deg);-o-transform: skew(-15deg) rotate(-6deg);transform: skew(-15deg) rotate(-6deg);}div.annotations div.note:after {left: auto;right: 10px;-webkit-transform: skew(15deg) rotate(6deg);-moz-transform: skew(15deg) rotate(6deg);-ms-transform: skew(15deg) rotate(6deg);-o-transform: skew(15deg) rotate(6deg);transform: skew(15deg) rotate(6deg);}.ui-resizable-e {cursor: e-resize;width: 7px;right: -5px;top: 0;height: 100%;}.ui-resizable-s {cursor: s-resize;height: 7px;width: 100%;bottom: -5px;left: 0;}.ui-resizable-se {cursor: se-resize;width: 12px;height: 12px;right: 1px;bottom: 1px;}.ui-resizable-handle {position: absolute;font-size: 0.1px;display: block;}.note-container {pointer-events:all}', 
/* global ActiveText */
ActiveText.NoteFactory = function(activeTextInstance) {
    "use strict";
    function getDataRepresentation(elem) {
        var newNote = $(elem), noteElement = newNote.find(".note"), noteWidth = noteElement.width(), noteHeight = noteElement.height(), noteTop = newNote.get(0).style.top, noteLeft = newNote.get(0).style.left, pageSize = ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance);
        return {
            type: "note",
            data: {
                point: [ noteTop, noteLeft ],
                relativePoint: [ parseInt(noteTop, 10) / pageSize.height, parseInt(noteLeft, 10) / pageSize.width ],
                id: newNote.data("id"),
                text: newNote.find(".content").text(),
                width: noteWidth,
                height: noteHeight
            }
        };
    }
    function renderNoteFromData(data) {
        function onSaveClick(e) {
            var note = $(e.target).parent().parent();
            return exitEditMode(note), !1;
        }
        function noteBlurAction(e) {
            var note = $(e.currentTarget);
            return exitEditMode(note), !1;
        }
        function onMoveComplete() {
            newNote.parent().trigger(ActiveText.Notes.Events.UPDATE);
        }
        function onResizeComplete(e) {
            newNote.parent().trigger(ActiveText.Notes.Events.UPDATE), e.stopImmediatePropagation();
        }
        function exitEditMode(note) {
            note.data("edit", !1);
            var newText = note.find(".content textarea").val();
            note.find(".content").html(newText), note.find(".save-button").hide(), note.parent().trigger(ActiveText.Notes.Events.UPDATE);
        }
        function enterEditMode(note) {
            note.data("edit", !0);
            var existingText = note.find(".content").text(), newHTMLContent = $('<textarea cols="12" rows="4"></textarea>');
            note.find(".content").html(newHTMLContent), note.find(".save-button").show(), newHTMLContent.blur(noteBlurAction), 
            newHTMLContent.focus().val(existingText);
        }
        function toggleEditMode(e) {
            var note = $(e.currentTarget), isInEditMode = note.data("edit") === !0;
            //                    exitEditMode(note);
            return isInEditMode ? newNote.parent().trigger(ActiveText.Notes.Events.UPDATE) : enterEditMode(note), 
            !1;
        }
        function removeNote(e) {
            var removeButton = $(e.target), note = removeButton.parent().parent(), annotationsLayer = note.parent();
            note.remove(), annotationsLayer.trigger(ActiveText.Notes.Events.UPDATE);
        }
        function onMouseDown(e) {
            dragged = !1, e.stopPropagation();
        }
        function onMouseUp(e) {
            var $target = $(e.target), editableElements = "textarea, .content", closeElements = 'a[role="button"], div.close', saveElements = ".save-button", drawingToolsAreActive = $(".iwbToolsPanel").is(":visible");
            dragged || drawingToolsAreActive || ($target.is(editableElements) ? toggleEditMode(e) : $target.is(closeElements) ? removeNote(e) : $target.is(saveElements) && onSaveClick(e));
        }
        function onStartDrag() {
            return $(".iwbToolsPanel").is(":visible") ? !1 : void (dragged = !0);
        }
        _.defaults(data, {
            width: DEFAULT_NOTE_WIDTH,
            height: DEFAULT_NOTE_HEIGHT
        });
        var dragged, noteTemplate = '<div class="note-container"><div class="note"><button class="save-button" style="display:none" role="button">Save</button><div class="hide"></div><div class="close"><a href="#" title="Delete Note" role="button" aria-label="Delete Note">x</a></div><div class="content"></div></div></div>';
        data.point = data.relativePoint || data.point;
        var pageSize = ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance), newNote = $(noteTemplate).data(data).css({
            // top: data.point[0],
            // left: data.point[1],
            top: pageSize.height * data.point[0] + "px",
            left: pageSize.width * data.point[1] + "px",
            width: data.width,
            height: data.height,
            position: "absolute"
        });
        return newNote.data("edit", !1).find(".content").text(data.text), newNote.on({
            mousedown: onMouseDown,
            mouseup: onMouseUp
        }).draggable({
            cursor: "move",
            stack: ".note-container",
            zIndex: 100,
            start: onStartDrag,
            stop: onMoveComplete
        }).find(".note").css({
            width: "100%",
            height: "100%"
        }).resizable({
            minWidth: 50,
            minHeight: 50,
            stop: onResizeComplete
        }), newNote;
    }
    /**
     * @const
     * @type {number}
     */
    var DEFAULT_NOTE_WIDTH = 100, DEFAULT_NOTE_HEIGHT = 100;
    // disable swipe gestures on notes.
    return $.fn.swipe.excludedElements += ",.note,.note-container", {
        renderNoteFromData: renderNoteFromData,
        getDataRepresentation: getDataRepresentation
    };
}, /* global ActiveText, Modernizr */
/**
 * @class ActiveText.DrawingToolsController
 * @memberOf ActiveText.DrawingTools
 * @param activeTextInstance {ActiveText}
 * @returns {{init: init, initStateForIndex: initStateForIndex, getStateForPage: getStateForPage, setStateForPage: setStateForPage, exportCurrentDrawing: exportCurrentDrawing}}
 * @constructor
 */
ActiveText.DrawingToolsController = function(activeTextInstance) {
    "use strict";
    function getStateForPage(pageIndex) {
        var rtn = states[String(pageIndex)];
        return rtn || (initStateForIndex(pageIndex), rtn = states[String(pageIndex)]), rtn;
    }
    function setStateForPage(pageIndex, context) {
        states[String(pageIndex)] = context;
    }
    function initStateForIndex(pageIndex) {
        setStateForPage(pageIndex, {
            clickX: [],
            clickY: [],
            clickColor: [],
            clickTool: [],
            clickSize: [],
            clickDrag: []
        });
    }
    /**
     * @param {number} pageIndex
     * @returns {{clickX: Array, clickY: Array, clickTool: Array, clickColor: Array, clickSize: Array, clickDrag: Array}}
     */
    function exportCurrentDrawing(pageIndex) {
        return getStateForPage(pageIndex);
    }
    /**
     * @param pageIndex {number}
     * @returns {string}
     */
    function getDrawingData(pageIndex) {
        var drawingData = exportCurrentDrawing(pageIndex);
        return JSON.stringify(drawingData);
    }
    /**
     * @param {object} event
     * @param {object} data
     */
    function saveDrawingDataFromEvent(event, data) {
        var pageIndex = data.index, drawingData = getDrawingData(pageIndex);
        saveDrawingDataForPageIndex(pageIndex, drawingData);
    }
    function saveDrawingDataForPageIndex(pageIndex, drawingData) {
        "function" == typeof activeTextInstance.options.drawingToolsGetDataFunction ? activeTextInstance.options.drawingToolsGetDataFunction(activeTextInstance, pageIndex, drawingData) : ActiveText.DrawingToolsJStorageExtension.drawingToolsGetDataFunction(activeTextInstance, pageIndex, drawingData);
    }
    function delayedInit() {
        $(activeTextInstance).on(ActiveText.Events.RESIZE, drawingTools.resize), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, drawingTools.loadDrawingsOnPageChange), 
        $(drawingTools).on(ActiveText.DrawingTools.Events.DRAWING_DELETED, saveDrawingDataFromEvent), 
        $(drawingTools).on(ActiveText.DrawingTools.Events.DRAWING_UPDATED, saveDrawingDataFromEvent);
        var resizeFunction = ActiveText.ResizeUtils.getProportionalResizeBehaviour(activeTextInstance, "drawing");
        $(activeTextInstance).on(ActiveText.Events.RESIZE, resizeFunction), $(activeTextInstance).on(ActiveText.Events.FRAME_CONTENT_LOADED, drawingTools.makeCanvasVisible), 
        drawingTools.resize(), // assume that the GO_TO_PAGE event has already fired, so manually re-trigger it.
        drawingTools.loadDrawingsOnPageChange(void 0, {
            toPage: activeTextInstance.model.getCurrentPageNumber()
        });
    }
    /**
     * @param instance {ActiveText.DrawingTools}
     */
    function init(instance) {
        drawingTools = instance, $(activeTextInstance).one(ActiveText.Events.BOOK_STRUCTURE_LOADED, delayedInit);
    }
    /**
     * @type {{}}
     */
    var drawingTools, states = {}, api = {
        init: init,
        initStateForIndex: initStateForIndex,
        getStateForPage: getStateForPage,
        setStateForPage: setStateForPage,
        exportCurrentDrawing: exportCurrentDrawing
    };
    return api;
}, /* global ActiveText, Modernizr */
/**
 * @class ActiveText.DrawingTools
 * @memberOf ActiveText
 * @typedef {{init: init, key: string, setCurrentTool: setCurrentTool, clearDrawings: clearDrawings, setActiveColour: setActiveColour, enable: enable, disable: disable, exportCurrentDrawing: exportCurrentDrawing, importDrawing: importDrawing, loadData: function, redraw: redraw, addClick: addClick, dispatchUpdate: dispatchUpdate}}
 * @constructor
 */
ActiveText.DrawingTools = function() {
    "use strict";
    function getContextForPage(pageIndex) {
        var rtn, container = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, pageIndex, "drawing");
        if (container) {
            var canvasElement = container.find("canvas").get(0);
            canvasElement && (rtn = canvasElement.getContext("2d"));
        }
        return rtn;
    }
    /**
     * @param pageIndex {number}
     */
    function clearCanvas(pageIndex) {
        var context = getContextForPage(pageIndex);
        if (void 0 !== context) {
            var dimensions = activeTextInstance.view.model.getPageDimensions();
            context.clearRect(0, 0, dimensions.width, dimensions.height);
        }
    }
    /**
     * @param pageIndex {number}
     * @param doNotSendDeletedEvent {boolean}
     */
    function clearDrawings(pageIndex, doNotSendDeletedEvent) {
        controller.initStateForIndex(pageIndex), clearCanvas(pageIndex), doNotSendDeletedEvent !== !0 && $(api).trigger(ActiveText.DrawingTools.Events.DRAWING_DELETED, {
            index: pageIndex
        });
    }
    /**
     * @param pageIndex {number}
     */
    function redraw(pageIndex) {
        var radius, i, l, context = getContextForPage(pageIndex), state = controller.getStateForPage(pageIndex);
        if (void 0 !== context && void 0 !== state) {
            clearCanvas(pageIndex);
            var dimensions = activeTextInstance.view.model.getPageDimensions();
            context.save(), context.fillStyle = ActiveText.ColourUtils.convertHexToRGB("#FFFFFF", 0), 
            context.fillRect(0, 0, dimensions.width, dimensions.height), context.restore(), 
            context.save(), context.beginPath();
            var previousX, previousY, currentX, currentY;
            for (i = 0, l = state.clickX.length; l > i; i++) {
                var currentColour = state.clickColor[i], currentTool = state.clickTool[i];
                if ("pointer" === currentTool) return;
                currentX = state.clickX[i], currentY = state.clickY[i], void 0 !== previousX && void 0 !== previousY ? context.moveTo(previousX, previousY) : context.moveTo(currentX - 1, currentY - 1), 
                context.lineTo(currentX, currentY), previousX = currentX, previousY = currentY, 
                radius = state.clickSize[i], "eraser" === currentTool ? (context.globalCompositeOperation = "destination-out", 
                context.strokeStyle = "white") : "pen" === currentTool ? (context.globalCompositeOperation = "source-over", 
                context.strokeStyle = currentColour) : "highlighter" === currentTool && (context.globalCompositeOperation = "source-over", 
                context.strokeStyle = ActiveText.ColourUtils.convertHexToRGB(state.clickColor[i], .5)), 
                context.lineCap = "round", context.lineJoin = "round", context.lineWidth = radius;
                var thisIsTheLastPointInTheArray = void 0 !== state.clickTool[i + 1], currentToolHasChanged = currentTool !== state.clickTool[i + 1], currentColourHasChanged = currentColour !== state.clickColor[i + 1], currentDragStateHasChanged = state.clickDrag[i] !== state.clickDrag[i + 1], falseToFalse = state.clickDrag[i] === !1 && state.clickDrag[i + 1] === !1, isDragging = state.clickDrag[i] === !0, shouldFinishLineAndRestart = thisIsTheLastPointInTheArray && currentToolHasChanged || falseToFalse || isDragging && currentDragStateHasChanged || currentColourHasChanged;
                shouldFinishLineAndRestart && (previousX = void 0, previousY = void 0, context.stroke(), 
                context.closePath(), context.beginPath());
            }
            context.stroke(), context.closePath(), context.restore(), context.globalAlpha = 1;
        }
    }
    /**
     * @param pageIndex {number}
     * @param x {number}
     * @param y {number}
     * @param dragging {boolean}
     */
    function addClick(pageIndex, x, y, dragging) {
        var magnification = 1 / activeTextInstance.view.model.getMagnificationValue(), state = controller.getStateForPage(pageIndex), scaleVar = 1 / model.getScale(), fixedXPos = x * scaleVar * magnification, fixedYPos = y * scaleVar * magnification, fixedToolSize = interactionController.curSize * scaleVar * magnification;
        state.clickX.push(fixedXPos), state.clickY.push(fixedYPos), state.clickTool.push(interactionController.curTool), 
        state.clickColor.push(interactionController.curColor), state.clickSize.push(fixedToolSize), 
        state.clickDrag.push(dragging);
    }
    /**
     * @param pageIndex {number}
     */
    function dispatchUpdate(pageIndex) {
        $(api).trigger(ActiveText.DrawingTools.Events.DRAWING_UPDATED, {
            index: pageIndex
        });
    }
    /**
     * @param pageIndex {number}
     */
    function enable(pageIndex) {
        api.active = !0, selectionController.createUserEvents(), interactionController.createUserEvents(), 
        ActiveText.LayerUtils.bringLayerToFront(activeTextInstance, pageIndex, "drawing"), 
        $(activeTextInstance).on(ActiveText.Events.CHANGE_SCALING_MODE, reactToScalingModeChange);
    }
    function reactToScalingModeChange(event, mode) {
        ("zoom" === mode || "ftw" === mode) && $(activeTextInstance).trigger(ActiveText.Commands.DISABLE_PAGE_DRAGGING);
    }
    /**
     * @param pageIndex {number}
     */
    function disable(pageIndex) {
        api.active = !1, selectionController.destroyUserEvents(), interactionController.destroyUserEvents(), 
        viewContainer.css({
            userSelect: ""
        }).attr("unselectable", "");
        var drawingToolsExtension = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, pageIndex, "drawing");
        if (drawingToolsExtension) {
            var canvasElement = drawingToolsExtension.parent();
            canvasElement.css("cursor", ""), ActiveText.LayerUtils.returnLayerToOriginalDepth(activeTextInstance, pageIndex, "drawing");
        }
        ("zoom" === activeTextInstance.view.model.getScaleMode() || "ftw" === activeTextInstance.view.model.getScaleMode()) && $(activeTextInstance).trigger(ActiveText.Commands.ENABLE_PAGE_DRAGGING);
    }
    function resizeCanvas() {
        var dimensions = activeTextInstance.view.model.getPageDimensions(), canvas = $(activeTextInstance.options.containerElement).find("canvas");
        $(canvas).attr({
            width: dimensions.width,
            height: dimensions.height
        });
        for (var pages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), i = 0, l = pages.length; l > i; i++) redraw(pages[i]);
    }
    /**
     * @param pageIndex {number}
     * @param drawingData {object}
     */
    function populateDrawingArraysFromObject(pageIndex, drawingData) {
        controller.setStateForPage(pageIndex, drawingData);
    }
    /**
     * @param pageIndex {number}
     * @param drawingData {object}
     */
    function importDrawing(pageIndex, drawingData) {
        clearDrawings(pageIndex, !0), populateDrawingArraysFromObject(pageIndex, drawingData), 
        redraw(pageIndex);
    }
    /**
     * @param pageIndex {number}
     * @param loadedData {string}
     */
    function renderDrawingFromData(pageIndex, loadedData) {
        $(activeTextInstance).trigger(ActiveText.DrawingTools.Events.DRAWING_TOOLS_LOAD_START, {
            index: pageIndex
        });
        var parsedData = JSON.parse(loadedData);
        importDrawing(pageIndex, parsedData), $(activeTextInstance).trigger(ActiveText.DrawingTools.Events.DRAWING_TOOLS_LOAD_COMPLETE, {
            index: pageIndex
        });
    }
    function internalLoadDataFunction(pageIndex, data) {
        var savedDrawingData = null;
        "undefined" == typeof data || "string" != typeof data ? // data not defined so fallback to localStorage
        savedDrawingData = ActiveText.DrawingToolsJStorageExtension.loadData(activeTextInstance, pageIndex) : "string" == typeof data && (// otherwise if its a string as expected do something with it.
        savedDrawingData = data), null !== savedDrawingData ? renderDrawingFromData(pageIndex, savedDrawingData) : clearDrawings(pageIndex, !0);
    }
    function loadDrawingsOnPageChange() {
        /**
         * @type {Array}
         */
        var pages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), loadFunction = function(scope, page) {
            internalLoadDataFunction.call(this, page);
        };
        "function" == typeof activeTextInstance.options.drawingToolsLoadDataFunction && (loadFunction = activeTextInstance.options.drawingToolsLoadDataFunction);
        for (var i = 0, l = pages.length; l > i; i++) {
            var canvasContainer = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, pages[i], "drawing");
            canvasContainer.css({
                visibility: "hidden"
            }), createCanvasElementForContainer(pages[i], canvasContainer), clearCanvas(pages[i]), 
            loadFunction(activeTextInstance, pages[i]);
        }
    }
    function makeCanvasVisible(event, data) {
        var canvasContainer = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, data.index, "drawing");
        canvasContainer && canvasContainer.css({
            visibility: ""
        });
    }
    function createCanvasElementForContainer(pageIndex, canvasContainer) {
        if (canvasContainer && !$(canvasContainer).find("canvas").length) {
            var canvas = ActiveText.DrawingTools.Factory.createCanvas();
            viewContainer.css({
                userSelect: "none"
            }).attr("unselectable", "on"), canvasContainer.get(0).appendChild(canvas);
        }
    }
    function delayedInit() {
        viewContainer = activeTextInstance.view.getContainer(), model = new ActiveText.DrawingToolsModel(activeTextInstance, viewContainer);
    }
    function init(instance) {
        supported && (activeTextInstance = instance, $(activeTextInstance).one(ActiveText.Events.BOOK_STRUCTURE_LOADED, delayedInit), 
        controller = new ActiveText.DrawingToolsController(activeTextInstance), controller.init(api), 
        selectionController = new ActiveText.DrawingToolsSelectionController(activeTextInstance, api), 
        interactionController = new ActiveText.DrawingToolsInteractionController(activeTextInstance, api), 
        activeTextInstance && activeTextInstance.options && activeTextInstance.options.containerElement && $(activeTextInstance.options.containerElement).on("remove", teardown));
    }
    function teardown() {
        $(activeTextInstance).off(ActiveText.Events.BOOK_STRUCTURE_LOADED, delayedInit), 
        $(activeTextInstance.options.containerElement).off("remove", teardown), $(activeTextInstance).off(ActiveText.Events.CHANGE_SCALING_MODE, reactToScalingModeChange);
    }
    function setCurrentTool() {
        return interactionController.setCurrentTool.apply(api || window, arguments);
    }
    function setActiveColour() {
        return interactionController.setActiveColour.apply(api || window, arguments);
    }
    function exportCurrentDrawing(pageIndex) {
        return controller.exportCurrentDrawing(pageIndex);
    }
    function supported() {
        return Modernizr.canvas;
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, model, interactionController, selectionController, controller, viewContainer, api = {
        init: init,
        key: "drawingtools",
        setCurrentTool: setCurrentTool,
        clearDrawings: clearDrawings,
        setActiveColour: setActiveColour,
        enable: enable,
        disable: disable,
        exportCurrentDrawing: exportCurrentDrawing,
        importDrawing: importDrawing,
        loadData: internalLoadDataFunction,
        redraw: redraw,
        addClick: addClick,
        dispatchUpdate: dispatchUpdate,
        supported: supported,
        resize: resizeCanvas,
        loadDrawingsOnPageChange: loadDrawingsOnPageChange,
        makeCanvasVisible: makeCanvasVisible,
        active: !1
    };
    return api;
}, /* global ActiveText, Modernizr */
/**
 * @class Factory
 * @memberOf ActiveText.DrawingTools
 * @type {{createCanvas:function}}
 */
ActiveText.DrawingTools.Factory = function() {
    "use strict";
    function createCanvasElementForContainer() {
        var canvas = document.createElement("canvas");
        return canvas.setAttribute("class", "canvas"), canvas.setAttribute("style", "position:absolute;left:0;top:0"), 
        canvas;
    }
    return {
        createCanvas: createCanvasElementForContainer
    };
}(), /* global ActiveText */
/**
 * @class DrawingToolsSelectionController
 * @memberOf ActiveText
 * @class {{createUserEvents: createUserEvents, destroyUserEvents: destroyUserEvents}}
 */
ActiveText.DrawingToolsSelectionController = function(activeTextInstance) {
    "use strict";
    function removeSelection() {
        document.selection && document.selection.clear();
    }
    function press() {
        removeSelection();
    }
    function drag() {
        removeSelection();
    }
    function release() {
        removeSelection();
    }
    function createUserEvents() {
        destroyUserEvents();
        var container = activeTextInstance.view.getContainer();
        $(container).on({
            mousedown: press,
            mousemove: drag,
            mouseup: release,
            selectstart: cancelEvent,
            touchstart: press,
            touchmove: drag,
            touchend: release
        });
    }
    function cancelEvent() {
        return !1;
    }
    function destroyUserEvents() {
        var container = activeTextInstance.view.getContainer();
        $(container).off({
            mousedown: press,
            mousemove: drag,
            mouseup: release,
            selectstart: cancelEvent,
            touchstart: press,
            touchmove: drag,
            touchend: release
        });
    }
    /**
     * @type {{createUserEvents: createUserEvents, destroyUserEvents: destroyUserEvents}}
     */
    var api = {
        createUserEvents: createUserEvents,
        destroyUserEvents: destroyUserEvents
    };
    return api;
}, /* global ActiveText */
/**
 * @class DrawingToolsInteractionController
 * @memberOf ActiveText
 * @type {{setCurrentTool: setCurrentTool, setActiveColour: setActiveColour, paint: boolean, curColor: string, curTool: string, curSize: number, createUserEvents: createUserEvents, destroyUserEvents: destroyUserEvents}}
 */
ActiveText.DrawingToolsInteractionController = function(activeTextInstance, drawingTools) {
    "use strict";
    function setCurrentTool(tool) {
        api.curTool = tool;
        var valid = !1, canvasElement = activeTextInstance.options.containerElement.find(".whiteboard-container");
        switch (tool) {
          case "pointer":
            valid = !0, canvasElement.css("cursor", "");
            break;

          case "eraser":
            valid = !0, api.curSize = ERASER_SIZE, $.browser.msie ? canvasElement.css("cursor", "url(" + largeCUR + "), crosshair") : canvasElement.css("cursor", "url(" + largeSVG + ") 17 17, url(" + largePNG + ") 17 17, crosshair");
            break;

          case "pen":
            valid = !0, api.curSize = PEN_SIZE, $.browser.msie ? canvasElement.css("cursor", "url(" + smallCUR + "), crosshair") : canvasElement.css("cursor", "url(" + smallSVG + ") 5 5, url(" + smallPNG + ") 5 5, crosshair");
            break;

          case "highlighter":
            valid = !0, api.curSize = HIGHLIGHTER_SIZE, $.browser.msie ? canvasElement.css("cursor", "url(" + mediumCUR + "), crosshair") : canvasElement.css("cursor", "url(" + mediumSVG + ") 11 11, url(" + mediumPNG + ") 11 11, crosshair");
            break;

          default:
            valid = !1;
        }
        return valid && "pointer" !== tool ? canvasElement.find(".whiteboard").css({
            cursor: ""
        }) : "pointer" === tool && "zoom" === activeTextInstance.view.model.getScaleMode() && canvasElement.find(".whiteboard").css({
            cursor: "move"
        }), valid;
    }
    /**
     * @param hexCode {string}
     */
    function setActiveColour(hexCode) {
        api.curColor = hexCode;
    }
    function normaliseTouchEvent(event) {
        var mouseX, mouseY;
        return event.originalEvent && event.originalEvent.touches && event.originalEvent.touches[0] ? (mouseX = event.originalEvent.touches[0].pageX, 
        mouseY = event.originalEvent.touches[0].pageY) : (mouseX = event.pageX, mouseY = event.pageY), 
        {
            mouseX: mouseX,
            mouseY: mouseY
        };
    }
    function press(event) {
        var pageNumber = $(event.data).attr("data-page"), pageIndex = ActiveText.NavigationUtils.pageNumberToPageIndex(activeTextInstance, pageNumber), offset = $(event.data).offset(), e = normaliseTouchEvent(event), mouseX = e.mouseX, mouseY = e.mouseY;
        return api.paint = !0, drawingTools.addClick(pageIndex, mouseX - offset.left, mouseY - offset.top, !1), 
        drawingTools.redraw(pageIndex), !1;
    }
    function drag(event) {
        if (api.paint) {
            var pageNumber = $(event.data).attr("data-page"), pageIndex = ActiveText.NavigationUtils.pageNumberToPageIndex(activeTextInstance, pageNumber), offset = $(event.data).offset(), e = normaliseTouchEvent(event), mouseX = e.mouseX, mouseY = e.mouseY;
            drawingTools.addClick(pageIndex, mouseX - offset.left, mouseY - offset.top, !0), 
            drawingTools.redraw(pageIndex);
        }
        return !1;
    }
    function release(event) {
        var pageNumber = $(event.data).attr("data-page"), pageIndex = ActiveText.NavigationUtils.pageNumberToPageIndex(activeTextInstance, pageNumber);
        if (api.paint = !1, api.paint) {
            var offset = $(event.data).offset(), e = normaliseTouchEvent(event), mouseX = e.mouseX, mouseY = e.mouseY;
            drawingTools.addClick(pageIndex, mouseX - offset.left, mouseY - offset.top, !1);
        }
        return drawingTools.redraw(pageIndex), drawingTools.dispatchUpdate(pageIndex), !1;
    }
    function cancel() {
        return api.paint = !1, !1;
    }
    function cancelWithFinalPoint(event) {
        if (api.paint) {
            var container = activeTextInstance.view.getContainer(), offset = $(container).offset(), isWithinBounds = event.pageX > offset.left && event.pageX < offset.left + container.width() && event.pageY > offset.top && event.pageY < offset.top + container.height();
            if (isWithinBounds) {
                var pageNumber = $(event.data).attr("data-page"), pageIndex = ActiveText.NavigationUtils.pageNumberToPageIndex(activeTextInstance, pageNumber), pageOffset = $(event.data).offset();
                drawingTools.addClick(pageIndex, event.originalEvent.pageX - pageOffset.left, event.originalEvent.pageY - pageOffset.top, !0), 
                drawingTools.redraw(pageIndex);
            } else cancel();
        }
        return !1;
    }
    function createUserEvents() {
        destroyUserEvents();
        for (var container = activeTextInstance.view.getContainer(), pages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), i = 0, l = pages.length; l > i; i++) {
            var canvasElement = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, pages[i], "drawing").parent();
            $(container).on({
                mousedown: press,
                mousemove: drag,
                mouseup: release,
                mouseout: cancelWithFinalPoint,
                touchstart: press,
                touchmove: drag,
                touchend: release,
                touchcancel: cancel
            }, canvasElement), setCurrentTool(api.curTool);
        }
        $(activeTextInstance).trigger(ActiveText.Commands.DISABLE_PAGE_DRAGGING), $(activeTextInstance).on(ActiveText.Commands.SWITCH_TO_ZOOM_MODE, checkCursors), 
        $(activeTextInstance).on(ActiveText.Commands.SWITCH_TO_SPS_FTW_VIEW, checkCursors);
    }
    function destroyUserEvents() {
        var container = activeTextInstance.view.getContainer();
        $(container).off({
            mousedown: press,
            mousemove: drag,
            mouseup: release,
            mouseout: cancelWithFinalPoint,
            touchstart: press,
            touchmove: drag,
            touchend: release,
            touchcancel: cancel
        });
        var canvasElement = activeTextInstance.options.containerElement.find(".whiteboard-container");
        canvasElement.css("cursor", ""), "zoom" === activeTextInstance.view.model.getScaleMode() && canvasElement.find(".whiteboard").css({
            cursor: "move"
        }), $(activeTextInstance).off(ActiveText.Commands.SWITCH_TO_ZOOM_MODE, checkCursors), 
        $(activeTextInstance).off(ActiveText.Commands.SWITCH_TO_SPS_FTW_VIEW, checkCursors);
    }
    function checkCursors() {
        activeTextInstance.options.containerElement.find(".whiteboard-container .whiteboard").css({
            cursor: ""
        });
    }
    function preloadGraphicalElements() {
        pathToResources = ActiveText.SkinUtils.getPathToGlobalResource() + "img/cursor/", 
        largeSVG = pathToResources + "33x33-pointer.svg", largeCUR = pathToResources + "33x33-pointer.png", 
        largePNG = pathToResources + "33x33-pointer.cur", mediumSVG = pathToResources + "23x23-pointer.svg", 
        mediumCUR = pathToResources + "23x23-pointer.png", mediumPNG = pathToResources + "23x23-pointer.cur", 
        smallSVG = pathToResources + "5x5-pointer.svg", smallCUR = pathToResources + "5x5-pointer.png", 
        smallPNG = pathToResources + "5x5-pointer.cur";
        var ASSETS_TO_PRELOAD = [ largeSVG, largePNG, mediumSVG, mediumPNG, smallSVG, smallPNG ];
        $.browser.msie && (ASSETS_TO_PRELOAD = [ largeCUR, mediumCUR, smallCUR ]), $(document).ready(function() {
            $.imgpreload(ASSETS_TO_PRELOAD);
        });
    }
    /**
     * @const
     * @type {number}
     */
    var pathToResources, largeSVG, largePNG, largeCUR, mediumSVG, mediumPNG, mediumCUR, smallSVG, smallPNG, smallCUR, ERASER_SIZE = 30, PEN_SIZE = 5, HIGHLIGHTER_SIZE = 20;
    preloadGraphicalElements();
    /**
     * @type {{setCurrentTool: setCurrentTool, setActiveColour: setActiveColour, paint: boolean, curColor: string, curTool: string, curSize: number, createUserEvents: createUserEvents, destroyUserEvents: destroyUserEvents}}
     */
    var api = {
        setCurrentTool: setCurrentTool,
        setActiveColour: setActiveColour,
        paint: !1,
        curColor: "#0000CD",
        curTool: "pointer",
        curSize: PEN_SIZE,
        createUserEvents: createUserEvents,
        destroyUserEvents: destroyUserEvents
    };
    return api;
}, /* global ActiveText */
/**
 * @class DrawingToolsModel
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @constructor
 */
ActiveText.DrawingToolsModel = function(activeTextInstance) {
    "use strict";
    /**
     * @returns {number}
     */
    function getScale() {
        return 1 / ActiveText.ViewUtils.getScaleValue(activeTextInstance);
    }
    /**
     * @returns {{width: number, height: number}}
     */
    function getUnscaledResourceDimensions() {
        return {
            width: DEFAULT_WIDTH,
            height: DEFAULT_HEIGHT
        };
    }
    /**
     * @const
     * @type {number}
     */
    var DEFAULT_WIDTH = 996, DEFAULT_HEIGHT = 698;
    return {
        getScale: getScale,
        getUnscaledResourceDimensions: getUnscaledResourceDimensions
    };
}, /* globals ActiveText */
/**
 * @class DrawingToolsJStorageExtension
 * @memberOf ActiveText
 * @type {{drawingToolsGetDataFunction:drawingToolsGetDataFunction, loadData:loadData}}
 */
ActiveText.DrawingToolsJStorageExtension = function() {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param pageIndex {number}
     * @param drawingData {*}
     */
    function drawingToolsGetDataFunction(activeTextInstance, pageIndex, drawingData) {
        var pageKey = getCurrentPageKey(activeTextInstance, pageIndex);
        $.jStorage.set(pageKey, drawingData);
    }
    /**
     * @param activeTextInstance {ActiveText}
     * @param pageIndex {number}
     * @returns {*}
     */
    function loadData(activeTextInstance, pageIndex) {
        var pageKey = getCurrentPageKey(activeTextInstance, pageIndex);
        return $.jStorage.get(pageKey, null);
    }
    /**
     * @param activeTextInstance {ActiveText}
     * @param pageIndex {number}
     * @returns {string}
     */
    function getCurrentPageKey(activeTextInstance, pageIndex) {
        var bookIdFromOPFMetaData, returnPageKey;
        return bookIdFromOPFMetaData = activeTextInstance.data.getMetaData(), bookIdFromOPFMetaData = bookIdFromOPFMetaData && null !== bookIdFromOPFMetaData.identifier || bookIdFromOPFMetaData && "" !== bookIdFromOPFMetaData.identifier ? bookIdFromOPFMetaData.identifier : "defaultBookId", 
        returnPageKey = pageIndex + "_" + bookIdFromOPFMetaData;
    }
    return {
        drawingToolsGetDataFunction: drawingToolsGetDataFunction,
        loadData: loadData
    };
}(), /* global ActiveText*/
/**
 * @class Events
 * @memberOf ActiveText.DrawingTools
 * @type {{DRAWING_TOOLS_LOAD_START: string, DRAWING_TOOLS_LOAD_COMPLETE: string, DRAWING_TOOLS_LOAD_ERROR: string, DRAWING_DELETED: string, DRAWING_UPDATED: string}}
 */
ActiveText.DrawingTools.Events = {
    DRAWING_TOOLS_LOAD_START: "drawingtools.load.start",
    DRAWING_TOOLS_LOAD_COMPLETE: "drawingtools.load.complete",
    DRAWING_TOOLS_LOAD_ERROR: "drawingtools.load.error",
    DRAWING_DELETED: "drawing.deleted",
    DRAWING_UPDATED: "drawing.updated"
}, /* global ActiveText */
/**
 * @class SoundEffects
 * @memberOf ActiveText
 * @returns {{init: init, hasSoundEffectsForPage: hasSoundEffectsForPage, hasLoadedOverlayDataForPages: hasLoadedOverlayDataForPages, key: string}}
 * @constructor
 */
ActiveText.SoundEffects = function() {
    "use strict";
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        /* jshint validthis:true */
        activeTextInstance = instance, soundEffectsData = [], soundEffectPromises = [], 
        audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(instance), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, changePage), 
        $(activeTextInstance).on(ActiveText.Events.LOADED_OVERLAY_DATA, parseOverlayData);
    }
    function changePage() {
        for (var visiblePages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), deferredObjects = [], i = 0, l = visiblePages.length; l > i; i++) deferredObjects.push(getPromiseFor(visiblePages[i]));
        $.when.apply($, deferredObjects).then(playSoundEffectsForPages);
    }
    function getPromiseFor(page) {
        void 0 === soundEffectPromises[page] && (soundEffectPromises[page] = $.Deferred());
        var shouldHaveDataForIndex = getOverlayDataLoader().hasOverlayDataForIndex(page);
        return shouldHaveDataForIndex || soundEffectPromises[page].resolve(), soundEffectPromises[page];
    }
    function hasLoadedOverlayDataForPages(visiblePages) {
        for (var rtn = $.Deferred(), deferredObjects = [], i = 0, l = visiblePages.length; l > i; i++) deferredObjects.push(getPromiseFor(visiblePages[i]));
        return $.when.apply($, deferredObjects).then(function() {
            rtn.resolve(visiblePages);
        }), rtn;
    }
    function getSoundEffectsFileForPages(visiblePages) {
        for (var rawSrc, i = 0, l = visiblePages.length; l > i; i++) void 0 !== soundEffectsData[visiblePages[i]] && soundEffectsData[visiblePages[i]] !== !0 && (rawSrc = soundEffectsData[visiblePages[i]]);
        return rawSrc;
    }
    function hasSoundEffectsForPage(visiblePages) {
        return Boolean(getSoundEffectsFileForPages(visiblePages));
    }
    function playSoundEffectsForPages() {
        function whenGotPlayerReference() {
            setTimeout(function() {
                var rawSrc = getSoundEffectsFileForPages(visiblePages), src = ActiveText.DataUtils.correctURLPath(activeTextInstance, rawSrc);
                audioPlayback.stop(), audioPlayback.setSrc(src), // todo: refactor this, please. (as 20140902)
                setTimeout(function() {
                    audioPlayback.play();
                }, 0);
            }, 0);
        }
        var visiblePages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance);
        hasSoundEffectsForPage(visiblePages) && $.when(audioPlayback.getMediaPlayer()).then(whenGotPlayerReference);
    }
    /**
     * @param event {object}
     * @param data {{index:Number, data:object}}
     */
    function parseOverlayData(event, data) {
        soundEffectsData[data.index] = !0;
        for (var item, i = 0, l = data.data.length; l > i; i++) item = data.data[i], "sound-effect" === item.type && void 0 !== item.audio && void 0 !== item.audio.src && (soundEffectsData[data.index] = item.audio.src);
        void 0 === soundEffectPromises[data.index] && (soundEffectPromises[data.index] = $.Deferred()), 
        soundEffectPromises[data.index].resolve(), $(api).trigger(ActiveText.SoundEffects.Events.UPDATE, {
            index: data.index
        });
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, audioPlayback, soundEffectsData, soundEffectPromises, getOverlayDataLoader = _.memoize(function() {
        return ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "overlaydataloader");
    }, _.identifier), api = {
        init: init,
        hasSoundEffectsForPage: hasSoundEffectsForPage,
        hasLoadedOverlayDataForPages: hasLoadedOverlayDataForPages,
        key: "soundeffects"
    };
    return api;
}, /* globals ActiveText */
/**
 * @class Events
 * @memberOf ActiveText.SoundEffects
 * @type {{UPDATE: string}}
 */
ActiveText.SoundEffects.Events = {
    UPDATE: "update"
}, /* global ActiveText */
ActiveText.CharacterSelection = function() {
    "use strict";
    function setCharacter(targetElement, character) {
        clearCharacter(), targetElement && "svg" !== targetElement[0].nodeName && (targetElement[0].setAttribute("class", "character-selected"), 
        currentCharacter = character);
    }
    function getCharacter() {
        return currentCharacter;
    }
    function clearCharacter() {
        $(".character-selected").each(function() {
            deselectCharacter($(this));
        });
    }
    function deselectCharacter(targetElement) {
        targetElement && "svg" !== targetElement[0].nodeName && (targetElement[0].setAttribute("class", ""), 
        currentCharacter = "");
    }
    var currentCharacter = "";
    return {
        setCharacter: setCharacter,
        getCharacter: getCharacter,
        deselectCharacter: deselectCharacter
    };
}(), /* global ActiveText */
/**
 * @class ReadToMe
 * @memberOf ActiveText
 * @param {*=} options
 * @returns {{init: init, options: *, play: function, pause: function, getState: getState, skip: function, stop: function, key: string}}
 * @constructor
 */
ActiveText.ReadToMe = function(options) {
    "use strict";
    /**
	 * @param instance {ActiveText}
	 */
    function init(instance) {
        activeTextInstance = instance;
        var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance);
        state = new ActiveText.ReadToMe.State(activeTextInstance);
        var defaultAutoPlayValue = Boolean(options && options.autoplay);
        state.setAutoPlay(defaultAutoPlayValue), getDependencies(), $(audioPlayback).on("onplay onresume onpause onfinish", forwardEvents), 
        $(audioPlayback).on("onerror", onError), $(audioPlayback).on("ontimeupdate", whilePlaying), 
        $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, changePage), $(activeTextInstance).on(ActiveText.Hotspots.Events.CLICKED, stopAudio);
    }
    function getDependencies() {
        ActiveText.ReadToMe.Utils.autoInjectSMILLoader(activeTextInstance);
        var smilDataModel = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildatamodel");
        smilDataModel || (smilDataModel = new ActiveText.SMILDataModel(), smilDataModel.init(activeTextInstance), 
        activeTextInstance.extensions.push(smilDataModel));
    }
    function forwardEvents(e) {
        $(api).trigger(e.type);
    }
    // the previous approach based on the onfinish event triggered by SM2 was not 
    // working on iPads, where the event would fire only sporadically. (as 20140902)
    // this should be refactored somewhere in the future...
    function whilePlaying() {
        var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance), position = Math.ceil(audioPlayback.getPosition()), duration = Math.ceil(audioPlayback.getDuration()), diffInterval = duration - 50, delay = duration - position;
        position && duration && 0 !== duration && position >= diffInterval && (audioPlayback.setPosition(0), 
        audioPlayback.duration = 0, audioPlayback.stop(), $(audioPlayback).trigger("onfinish"), 
        setTimeout(onEnded, delay));
    }
    function resetAudioProgressionState(activePage) {
        state.activePage = activePage, state.queuePos = 0, state.activeCharacter = "", state.activeFile = "";
        var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance);
        audioPlayback.stop(), audioFileIsFlaggedForAChange = !0;
    }
    function changePage(event, data) {
        function checkAndBeginAudio() {
            state.getAutoPlay(event.type + "." + event.namespace) && !mustWaitForSoundEffectsToPlay && setTimeout(function() {
                setTheCorrectNextAudioFile();
            }, 0);
        }
        var visiblePageHasChanged = data.toPage !== data.fromPage;
        visiblePageHasChanged && resetAudioProgressionState(data.toPage);
        // re-enable "Done" button on rotation/resize if the first character is the selected one.
        var shouldAutoplay = state.getAutoPlay(), audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance);
        shouldAutoplay || setTimeout(function() {
            $(audioPlayback).trigger("onpause");
        }, 200);
        /**
		 * @type {ActiveText.SoundEffects}
		 */
        var soundEffectsExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "soundeffects"), mustWaitForSoundEffectsToPlay = !1;
        if (soundEffectsExtension) {
            var visiblePages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance);
            $.when(soundEffectsExtension.hasLoadedOverlayDataForPages(visiblePages)).then(function() {
                soundEffectsExtension.hasSoundEffectsForPage(visiblePages) && (mustWaitForSoundEffectsToPlay = !0), 
                checkAndBeginAudio();
            });
        } else {
            var pagesToCheck = ActiveText.ViewUtils.getVisiblePages(activeTextInstance);
            $.when(ActiveText.ReadToMe.Utils.hasLoadedSMILFilesForVisiblePages(activeTextInstance, pagesToCheck)).then(checkAndBeginAudio);
        }
    }
    function autoAdvanceAudioToNextPage() {
        function switchToTheNextPage() {
            var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance), isLeftMostPage = ActiveText.NavigationUtils.isLeftPage(activeTextInstance, state.activePage);
            state.activePage++, state.queuePos = 0;
            var JDPlayer = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "jdplays"), RapidPlayer = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "rapidplays"), plays = JDPlayer || RapidPlayer;
            state.inPerformanceMode = plays ? plays.isInPerformanceMode(activeTextInstance) : !1, 
            state.setAutoPlay(!0), isLeftMostPage ? setTheCorrectNextAudioFile() : (state.inPerformanceMode && (audioPlayback.setSrc(""), 
            state.activeFile = ""), $(api).trigger(ActiveText.ReadToMe.Events.UPDATE), audioPlayback.stop());
        }
        var pagesToCheck = ActiveText.ViewUtils.getVisiblePages(activeTextInstance);
        $.when(ActiveText.ReadToMe.Utils.hasLoadedSMILFilesForVisiblePages(activeTextInstance, pagesToCheck)).then(switchToTheNextPage);
    }
    function startLoadingTheNextAudioFile(pagesDataLoaded) {
        var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance), smilDataModel = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildatamodel"), dataHasBeenLoadedForTheActivePage = _.contains(pagesDataLoaded, state.activePage);
        if (dataHasBeenLoadedForTheActivePage) {
            var audioCollectionForThisPage = smilDataModel.getSmilDataForPage(state.activePage), hasAnAudioFileForTheCurrentPage = Boolean(audioCollectionForThisPage && audioCollectionForThisPage[state.queuePos]);
            hasAnAudioFileForTheCurrentPage ? $.when(audioPlayback.getMediaPlayer()).then(function() {
                var src = ActiveText.DataUtils.correctURLPath(activeTextInstance, audioCollectionForThisPage[state.queuePos].audioSource);
                audioPlayback.setSrc(src), state.activeCharacter = audioCollectionForThisPage[state.queuePos].character, 
                state.activeFile = audioCollectionForThisPage[state.queuePos].audioSource, $(api).trigger(ActiveText.ReadToMe.Events.UPDATE), 
                audioFileIsFlaggedForAChange = !1, playAudio();
            }) : ((1 !== pagesDataLoaded.length || void 0 === audioCollectionForThisPage) && audioPlayback.setSrc(""), 
            state.activeFile = "", $(api).trigger(ActiveText.ReadToMe.Events.UPDATE), $(activeTextInstance).trigger(ActiveText.Commands.HIDE_LOADER), 
            state.activeCharacter = "", audioPlayback.stop(), autoAdvanceAudioToNextPage());
        }
    }
    function setTheCorrectNextAudioFile() {
        var pagesToCheck = ActiveText.ViewUtils.getVisiblePages(activeTextInstance);
        $.when(ActiveText.ReadToMe.Utils.hasLoadedSMILFilesForVisiblePages(activeTextInstance, pagesToCheck)).then(startLoadingTheNextAudioFile);
    }
    function onError(event, data) {
        $(activeTextInstance).trigger(ActiveText.Commands.DISPLAY_ERROR, "An Error occurred loading audio file " + data.url), 
        api.skip();
    }
    function advanceToNextFile(audioElement) {
        var smilDataModel = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildatamodel");
        state.queuePos++;
        var pageAudioCollection = smilDataModel.getSmilDataForPage(state.activePage);
        pageAudioCollection && pageAudioCollection[state.queuePos] ? (state.activeCharacter = pageAudioCollection[state.queuePos].character, 
        state.activeFile = pageAudioCollection[state.queuePos].audioSource) : (state.activeCharacter = "", 
        state.activeFile = "");
        var existingSrc = "";
        audioElement && (existingSrc = audioElement.url);
        // I think this makes the sound effects work!
        var audioFileIsFromActivePage = !1;
        if (existingSrc && pageAudioCollection) for (var i = 0, l = pageAudioCollection.length; l > i; i++) -1 !== existingSrc.indexOf(pageAudioCollection[i].audioSource) && (audioFileIsFromActivePage = !0);
        audioFileIsFromActivePage || (state.queuePos = 0), setTheCorrectNextAudioFile();
    }
    function onEnded() {
        var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance), pagesToCheck = ActiveText.ViewUtils.getVisiblePages(activeTextInstance);
        $.when(audioPlayback.getMediaPlayer(), ActiveText.ReadToMe.Utils.hasLoadedSMILFilesForVisiblePages(activeTextInstance, pagesToCheck)).then(advanceToNextFile);
    }
    function playAudio() {
        var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance), JDPlayer = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "jdplays"), RapidPlayer = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "rapidplays"), plays = JDPlayer || RapidPlayer, pagesToCheck = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), delay = ActiveText.BrowserUtils.iOSversion[0] >= 6 ? 200 : 1;
        state.inPerformanceMode = plays ? plays.isInPerformanceMode(activeTextInstance) : !1, 
        state.setAutoPlay(!0), $.when(audioPlayback.getMediaPlayer()).then(function(mp) {
            var visiblePageHasChanged = !_.contains(pagesToCheck, state.activePage) || 1 === pagesToCheck.length && state.activePage !== pagesToCheck[0], pageHasTurned = state.activePage > pagesToCheck[pagesToCheck.length - 1], smilDataModel = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildatamodel"), pageAudioCollection = smilDataModel.getSmilDataForPage(state.activePage), samePageOrReadToMe = !pageHasTurned || !state.inPerformanceMode, nextPageAndPerformanceMode = pageHasTurned && state.inPerformanceMode && void 0 !== pageAudioCollection, hasOverlay = $(window.frameElement).is(":hidden");
            mp || (audioFileIsFlaggedForAChange = !0), audioFileIsFlaggedForAChange ? setTheCorrectNextAudioFile() : visiblePageHasChanged && (samePageOrReadToMe || nextPageAndPerformanceMode) ? (resetAudioProgressionState(pagesToCheck[0]), 
            setTheCorrectNextAudioFile()) : "" !== state.activeFile || state.inPerformanceMode || setTheCorrectNextAudioFile(), 
            hasOverlay || setTimeout(function() {
                audioPlayback.play();
            }, delay);
        });
    }
    /**
	 * @returns {boolean}
	 */
    function pauseAudio() {
        state.setAutoPlay(!1);
        var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance);
        return audioPlayback.pause();
    }
    function stopAudio() {
        var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance);
        audioPlayback.stop(), resetAudioProgressionState(state.activePage);
    }
    /**
	 * @returns {ActiveText.ReadToMe.State}
	 */
    function getState() {
        return state;
    }
    /**
	 * @type {ActiveText}
	 */
    var activeTextInstance, state, audioFileIsFlaggedForAChange = !0, api = {
        init: init,
        options: options,
        play: playAudio,
        pause: pauseAudio,
        getState: getState,
        skip: onEnded,
        stop: stopAudio,
        key: "readtome"
    };
    return api;
}, /* global ActiveText */
/**
 * @class Events
 * @memberOf ActiveText.ReadToMe
 * @type {{AUTO_ADVANCE: string}}
 */
ActiveText.ReadToMe.Events = {
    UPDATE: "update.readtome"
}, /* global ActiveText */
/**
 * @class Utils
 * @memberOf ActiveText.ReadToMe
 * @type {{autoInjectSMILLoader:autoInjectSMILLoader}}
 */
ActiveText.ReadToMe.Utils = function(ActiveText) {
    "use strict";
    function autoInjectSMILLoader(activeTextInstance) {
        var smilLoader = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildataloader");
        smilLoader || "function" != typeof ActiveText.SMILDataLoader || (smilLoader = new ActiveText.SMILDataLoader(), 
        smilLoader.init(activeTextInstance), activeTextInstance.extensions.push(smilLoader));
    }
    /**
     * @param pagesToCheck {Array}
     * @returns {jQuery.Deferred}
     */
    function hasLoadedSMILFilesForVisiblePages(activeTextInstance, pagesToCheck) {
        function checkCurrentState() {
            for (var hasAllSMILFiles = !0, i = 0, l = pagesToCheck.length; l > i; i++) {
                var pageIndex = pagesToCheck[i];
                smilDataExtension.hasSMILForPage(pageIndex) && void 0 === smilDataModel.getSmilDataForPage(pageIndex) && (hasAllSMILFiles = !1);
            }
            hasAllSMILFiles ? rtn.resolve(pagesToCheck) : $(activeTextInstance).off(ActiveText.SMILDataLoader.Events.SMIL_DATA_LOADED, checkCurrentState).on(ActiveText.SMILDataLoader.Events.SMIL_DATA_LOADED, checkCurrentState);
        }
        var rtn = $.Deferred(), smilDataExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildataloader"), smilDataModel = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildatamodel");
        return checkCurrentState(), rtn;
    }
    return {
        autoInjectSMILLoader: autoInjectSMILLoader,
        hasLoadedSMILFilesForVisiblePages: hasLoadedSMILFilesForVisiblePages
    };
}(ActiveText), /* global ActiveText */
/**
 * @class State
 * @memberOf ActiveText.ReadToMe
 * @param {ActiveText} activeTextInstance
 * @returns {{setAutoPlay: function, getAutoPlay: function, playing: isPlaying, getActiveCharacter: getActiveCharacter, queuePos: number, activePage: number, shouldAutoPlay: boolean, activeCharacter: string}}
 * @constructor
 */
ActiveText.ReadToMe.State = function(activeTextInstance) {
    "use strict";
    function getAutoPlay(eventType) {
        var rtn;
        return rtn = activeTextInstance && activeTextInstance.options && activeTextInstance.options.audioPlaybackController ? activeTextInstance.options.audioPlaybackController(void 0, eventType) : api.shouldAutoPlay;
    }
    function setAutoPlay(value, eventType) {
        activeTextInstance && activeTextInstance.options && activeTextInstance.options.audioPlaybackController ? activeTextInstance.options.audioPlaybackController(value, eventType) : api.shouldAutoPlay = Boolean(value);
    }
    /**
     * @returns {boolean}
     */
    function isPlaying() {
        var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance), smilDataModel = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildatamodel"), rtn = !1;
        return $.when(audioPlayback.getMediaPlayer()).then(function(mp) {
            var existingSrc = "";
            mp && (existingSrc = mp.url);
            var found = !1;
            if (existingSrc) {
                var pageAudioCollection = smilDataModel.getSmilDataForPage(api.activePage);
                if (pageAudioCollection) for (var i = 0, l = pageAudioCollection.length; l > i; i++) -1 !== existingSrc.indexOf(pageAudioCollection[i].audioSource) && (found = !0);
            }
            found && (rtn = audioPlayback.playing());
        }), rtn;
    }
    /**
     * @returns {string}
     */
    function getActiveCharacter() {
        return api.activeCharacter;
    }
    var api = {
        setAutoPlay: setAutoPlay,
        getAutoPlay: getAutoPlay,
        playing: isPlaying,
        getActiveCharacter: getActiveCharacter,
        queuePos: 0,
        activePage: 0,
        shouldAutoPlay: !1,
        activeCharacter: "",
        activeFile: ""
    };
    return api;
}, /* global ActiveText */
ActiveText.RecordAndPlay = function() {
    "use strict";
    function insertButtonsDiv() {
        var $buttons = $(".button.record, .button.play"), $playbackDiv = $("<div />", {
            "class": "playbackDiv"
        });
        $buttons.wrapAll($playbackDiv), hasFlash() || $(".playbackDiv").hide();
    }
    function embedSWFrecorder() {
        var resourcePath = ActiveText.SkinUtils.getPathToResources(activeTextInstance), swfPath = resourcePath + "swf/ActiveTextRecordAndRateWidget.swf", opt = {
            swfUrl: swfPath,
            id: "flashRecorder",
            width: 467,
            height: 174,
            version: "9.0.0",
            expressInstall: !1,
            flashvars: {},
            params: {
                movie: swfPath,
                wmode: "transparent",
                quality: "high",
                allowscriptaccess: "always"
            }
        }, $swfWrapper = $("<div />", {
            "class": "recordingWidget"
        }).hide();
        $("<div />", {
            id: "flashRecorder"
        }).appendTo($swfWrapper), $("body").append($swfWrapper), swfobject.embedSWF(opt.swfUrl, opt.id, opt.width, opt.height, opt.version, opt.expressInstall, opt.flashvars, opt.params), 
        recObject.wrapper = $swfWrapper;
    }
    function pauseReadToMe() {
        recObject.readToMeAudio && recObject.readToMeAudio.pause();
    }
    function openRecPopup() {
        // temporary measure to enable the recording only after the user allowed it.
        return pauseReadToMe(), recObject.wrapper.show(), !0;
    }
    function toggleRecord() {
        pauseReadToMe(), recObject.hasConfirmed && !recObject.isPlaying && (eventType = recObject.isRecording ? "stop" : "record", 
        recObject.element = $("#flashRecorder")[0], recObject.element.recPressed(), recObject.isRecording = !recObject.isRecording, 
        recObject.hasRecorded = !0, // trigger the event to allow the button control to behave accordingly.
        $(activeTextInstance).trigger(eventType)), recObject.hasPlayed = recObject.isPaused = !1, 
        // not true. but if the user didn't allow and it doesn't work, well..
        recObject.hasConfirmed = openRecPopup();
    }
    function togglePlay() {
        pauseReadToMe(), recObject.hasRecorded && !recObject.isRecording && (recObject.element.playPausePressed(), 
        recObject.isPlaying || recObject.isPaused || (eventType = "play"), recObject.isPlaying && (eventType = "pause"), 
        recObject.isPaused && (eventType = "resume"), recObject.isPlaying = !recObject.isPlaying, 
        recObject.isPaused = !recObject.isPaused, recObject.hasPlayed = !0, // trigger the event to allow the button control to behave accordingly.
        $(activeTextInstance).trigger(eventType));
    }
    function swfIsRecording() {
        return recObject.isRecording;
    }
    function swfIsPlaying() {
        return recObject.isPlaying;
    }
    function swfHasRecorded() {
        return recObject.hasRecorded;
    }
    function updateStates(isRecording, isPlaying) {
        isPlaying || setTimeout(function() {
            $(activeTextInstance).trigger("finish"), recObject.isPlaying = !1;
        }, 1e3);
    }
    function hasFlash() {
        return swfobject.hasFlashPlayerVersion("9.0.18");
    }
    function init(instance) {
        activeTextInstance = instance, embedSWFrecorder(), recObject.readToMeAudio = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance), 
        $(activeTextInstance).on(ActiveText.Events.UI_ELEMENT_LOADED, function(e) {
            "controls-bar" === e.element && insertButtonsDiv();
        });
    }
    var activeTextInstance, eventType, recObject = {
        hasConfirmed: !1,
        isPlaying: !1,
        isRecording: !1,
        hasPlayed: !1,
        hasRecorded: !1
    };
    window.updateStates = updateStates;
    var api = {
        init: init,
        swfIsRecording: swfIsRecording,
        swfIsPlaying: swfIsPlaying,
        toggleRecord: toggleRecord,
        togglePlay: togglePlay,
        hasRecorded: swfHasRecorded,
        hasFlash: hasFlash,
        key: "recordandplay"
    };
    return api;
}, /* global ActiveText, setTimeout */
/**
 * @class TextHighlightHelper
 * @memberOf ActiveText
 * @returns {{getSelectionClassName:Function}}
 */
ActiveText.TextHighlightHelper = function() {
    "use strict";
    /**
     * @returns {string}
     */
    function getSelectionClassName() {
        return "-epub-overlay-active";
    }
    return {
        getSelectionClassName: getSelectionClassName
    };
}(), /* global ActiveText */
/**
 * @class TextHighlightSettings
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{getDefaultHighlightColor: Function}}
 * @constructor
 */
ActiveText.TextHighlightSettings = function(activeTextInstance) {
    "use strict";
    function getDefaultHighlightColor() {
        return defaultHighlightColor;
    }
    function init() {
        $(activeTextInstance).on(ActiveText.Settings.Events.LOADED, setTextHighlightDefaultColourFromData);
    }
    function setTextHighlightDefaultColourFromData(event, data) {
        void 0 !== data.defaultHighlightColor && null !== data.defaultHighlightColor && (defaultHighlightColor = data.defaultHighlightColor);
    }
    /**
     * @type {String}
     */
    var defaultHighlightColor = "yellow";
    init();
    /**
     * @type {{getDefaultHighlightColor: Function}}
     */
    var api = {
        getDefaultHighlightColor: getDefaultHighlightColor
    };
    return api;
}, /* global ActiveText */
/**
 * @class TextHighlightAudioSync
 * @memberOf ActiveText
 * @param options
 * @returns {{init: Function, key: string}}
 * @constructor
 */
ActiveText.TextHighlightAudioSync = function(options) {
    "use strict";
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        function teardown() {
            $(readToMeClass).off(ActiveText.ReadToMe.Events.UPDATE, onAudioUpdateEvent), $(audioPlayback).off(TIME_UPDATE, onAudioUpdateEvent), 
            $(activeTextInstance).off(ActiveText.Commands.GO_TO_PAGE, resetTextSelectionForPage), 
            $(activeTextInstance.options.containerElement).off("remove", teardown), smilDataModel = void 0, 
            readToMeClass = void 0, audioPlayback = void 0, activeTextInstance = void 0;
        }
        activeTextInstance = instance, getDependencies(), $(readToMeClass).on(ActiveText.ReadToMe.Events.UPDATE, onAudioUpdateEvent), 
        $(audioPlayback).on(TIME_UPDATE, onAudioUpdateEvent), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, resetTextSelectionForPage), 
        activeTextInstance.options && activeTextInstance.options.containerElement && $(activeTextInstance.options.containerElement).on("remove", teardown);
    }
    function resetTextSelectionForPage() {
        var activePages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance);
        _(activePages).forEach(function(pageIndex) {
            removeHighlightingFromAllElementsExcept(pageIndex);
        }), onAudioUpdateEvent();
    }
    function getDependencies() {
        readToMeClass = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "readtome"), 
        readToMeClass || (readToMeClass = new ActiveText.ReadToMe(options), readToMeClass.init(activeTextInstance), 
        activeTextInstance.extensions.push(readToMeClass)), smilDataModel = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildatamodel"), 
        audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance);
        var settings = new ActiveText.TextHighlightSettings(activeTextInstance);
        ActiveText.TextHighlightPageInjection(activeTextInstance, settings);
    }
    function getSiblingClasses(initialSelector, page) {
        var selector, classesOnElement = page.contents().find(initialSelector).attr("class");
        if (classesOnElement) {
            var classesAsArray = classesOnElement.split(" "), selectionClassName = ActiveText.TextHighlightHelper.getSelectionClassName(), index = classesAsArray.indexOf(selectionClassName);
            -1 !== index && classesAsArray.splice(index, 1);
            for (var i = 0, l = classesAsArray.length; l > i; i++) classesAsArray[i] = "." + classesAsArray[i];
            classesAsArray.push(initialSelector), selector = classesAsArray.join(",");
        } else selector = initialSelector;
        return page.contents().find(selector);
    }
    function selectText(media, pageIndex) {
        function selectItems(item) {
            function highlightContent() {
                if (item) {
                    var frame = ActiveText.ViewUtils.getFrameForPageByIndex(activeTextInstance, pageIndex), iframeElement = frame.find("iframe"), siblingClasses = getSiblingClasses(item.highlightId, iframeElement);
                    colourCode = item.highlightColour, phrases ? phrases.add(siblingClasses) : phrases = siblingClasses;
                }
                currentTime > 0 && removeHighlightingFromAllElementsExcept(pageIndex, phrases), 
                phrases ? (removeHighlightingFromAllElementsExcept(pageIndex, phrases), highlightElement(phrases, colourCode)) : removeHighlightingFromAllElementsExcept(pageIndex, phrases);
            }
            function checkLoadStatus() {
                var frame = ActiveText.ViewUtils.getFrameForPageByIndex(activeTextInstance, pageIndex), iframeElement = frame.find("iframe"), iframeIsReady = iframeElement.contents().find("body").children().length > 0;
                timeoutReference && clearTimeout(timeoutReference), timeoutReference = iframeIsReady ? setTimeout(highlightContent, 100) : iframeElement.length ? setTimeout(checkLoadStatus, 100) : setTimeout(checkLoadStatus, 100);
            }
            checkLoadStatus();
        }
        function pauseAudio() {
            readToMeClass.pause();
        }
        var currentTime = 0;
        media && (currentTime = media.position / 1e3);
        var audioSourceFile = readToMeClass.getState().activeFile, currentCharacter = ActiveText.CharacterSelection.getCharacter(), shouldHighlight = Boolean(options && options.selectionModeHighlightByDefault), smilDataForThisPage = smilDataModel.getSmilDataForPage(pageIndex);
        if (smilDataForThisPage) {
            for (var selection, phrases, colourCode, i = 0, l = smilDataForThisPage.length; l > i; i++) {
                var item = smilDataForThisPage[i];
                if (-1 !== audioSourceFile.indexOf(item.audioSource)) {
                    var audioFileCharacter = item.character;
                    if (currentCharacter === audioFileCharacter) {
                        var delay = ActiveText.BrowserUtils.IEVersion && ActiveText.BrowserUtils.IEVersion < 10 ? 400 : 0;
                        setTimeout(pauseAudio, delay), shouldHighlight = !0;
                    }
                    if (shouldHighlight) {
                        var clipBegin = 0;
                        item.clipBegin && !isNaN(item.clipBegin) && (clipBegin = item.clipBegin);
                        var clipEnd = media.duration / 1e3;
                        item.clipEnd && !isNaN(item.clipEnd) && (clipBegin = item.clipEnd), currentTime >= clipBegin && clipEnd >= currentTime && (selection = item);
                    }
                }
            }
            removeHighlightsFromNonActivePage(pageIndex), selectItems(selection);
        } else removeHighlightsFromNonActivePage();
    }
    function removeHighlightsFromNonActivePage(pageIndex) {
        var activePages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), pages = _.without(activePages, pageIndex);
        _(pages).forEach(function(pageIndex) {
            removeHighlightingFromAllElementsExcept(pageIndex);
        }), timeoutReference && clearTimeout(timeoutReference);
    }
    function onAudioUpdateEvent() {
        $.when(audioPlayback.getMediaPlayer()).then(function(media) {
            var state = readToMeClass.getState(), pageIndex = state.activePage;
            selectText(media, pageIndex);
        });
    }
    function removeHighlightingFromAllElementsExcept(index, exceptions) {
        var selectionClassName = ActiveText.TextHighlightHelper.getSelectionClassName(), page = $("#iframe" + index), elements = page.contents().find("." + selectionClassName);
        exceptions && (elements = elements.not(exceptions)), $(elements).removeClass(selectionClassName).css("background-color", "").children().css("background-color", "");
    }
    function highlightElement(elements, colourCode) {
        var selectionClassName = ActiveText.TextHighlightHelper.getSelectionClassName();
        $(elements).addClass(selectionClassName).css("background-color", colourCode).children().css("background-color", colourCode);
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, audioPlayback, readToMeClass, smilDataModel, timeoutReference, TIME_UPDATE = "ontimeupdate", api = {
        init: init,
        key: "texthighlightaudiosync"
    };
    return api;
}, /* global ActiveText */
/**
 * @class TextHighlightPageInjection
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @param settings {ActiveText.TextHighlightSettings}
 * @constructor
 */
ActiveText.TextHighlightPageInjection = function(activeTextInstance, settings) {
    "use strict";
    function init() {
        $(activeTextInstance).on(ActiveText.Events.FRAME_CONTENT_LOADED, injectHighlightStylesToPage);
    }
    /**
     * @param index {number}
     * @param highlightColour {string}
     */
    function injectTextHighlightStyles(index, highlightColour) {
        function onLoaded() {
            $("#iframe" + index).contents().find("head").append(htmlString);
        }
        function waitForLoad() {
            $("#iframe" + index).contents().find("body").children().length ? onLoaded() : setTimeout(function() {
                waitForLoad();
            }, 100);
        }
        var selectionClassName = ActiveText.TextHighlightHelper.getSelectionClassName(), htmlString = '<style type="text/css">.' + selectionClassName + ",." + selectionClassName + " *{background-color:" + highlightColour + ";display:inline-block;}</style>";
        waitForLoad();
    }
    /**
     * @param event {object}
     * @param data {{index:number}}
     */
    function injectHighlightStylesToPage(event, data) {
        var index = data.index, defaultHighlightColor = settings.getDefaultHighlightColor();
        injectTextHighlightStyles(index, defaultHighlightColor);
    }
    init();
}, /* global ActiveText */
/**
 * @class SMILDataModel
 * @memberOf ActiveText
 * @returns {{init: init, getSmilDataForPage: getSmilDataForPage, key: string}}
 * @constructor
 */
ActiveText.SMILDataModel = function() {
    "use strict";
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        activeTextInstance = instance, $(activeTextInstance).on(ActiveText.SMILDataLoader.Events.SMIL_DATA_LOADED, extractDataFromSMILFile);
    }
    function extractDataFromSMILFile(event, data) {
        var pageIndex = data.index, response = data.data;
        pageAudioCollections[pageIndex] = ActiveText.SMILFormatHelper.parseSMIL(response);
    }
    function getSmilDataForPage(pageIndex) {
        return pageAudioCollections[pageIndex];
    }
    /**
     * @type {Array}
     */
    var activeTextInstance, pageAudioCollections = [];
    return {
        init: init,
        getSmilDataForPage: getSmilDataForPage,
        key: "smildatamodel"
    };
}, /* global ActiveText */
/**
 * @class SMILDataLoader
 * @memberOf ActiveText
 * @returns {{init: init, hasSMILForPage: hasSMILForPage, key: string}}
 * @constructor
 */
ActiveText.SMILDataLoader = function() {
    "use strict";
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        activeTextInstance = instance, $(activeTextInstance).on(ActiveText.Events.OPF_DATA_LOADED, extractSMILReferencesFromOPFData), 
        $(activeTextInstance).on(ActiveText.Commands.LOAD_PAGE_BY_INDEX, loadSMILForIndex);
    }
    /**
     * @param data {Document}
     */
    function extractSMILReferencesFromOPFData(event, data) {
        smilRefs = [];
        for (var opfFile = $(data), spineData = opfFile.find('spine itemref[linear!="no"]'), i = 0, l = spineData.length; l > i; i++) {
            var idRef = $(spineData[i]).attr("idref"), smilRef = opfFile.find('manifest item[id="' + idRef + '"]').attr("media-overlay"), smilHref = opfFile.find('manifest item[id="' + smilRef + '"]').attr("href");
            smilHref || (smilHref = opfFile.find('manifest item[id="' + idRef + '"]').attr("media-overlay")), 
            smilRefs[i] = smilHref;
        }
    }
    /**
     * @param pageIndex {Number}
     * @returns {Boolean}
     */
    function hasSMILForPage(pageIndex) {
        return Boolean(void 0 !== getSMILReferenceForPage(pageIndex));
    }
    /**
     * @param pageIndex {Number}
     * @returns {String}
     */
    function getSMILReferenceForPage(pageIndex) {
        return smilRefs[pageIndex];
    }
    /**
     * @param pageIndex {Number}
     * @returns {XMLDocument}
     */
    function getCachedSMILReferenceForPage(pageIndex) {
        return smilCache[pageIndex];
    }
    /**
     * @param pageIndex {number}
     * @return {jQuery}
     */
    function haveHaveLoadedSMILDataForIndex(pageIndex) {
        function onSMILLoaded(resp) {
            smilCache[pageIndex] = resp, deferred.resolve(pageIndex, resp);
        }
        function onSMILError() {
            //                debug.log(e);
            deferred.resolve(pageIndex), $(activeTextInstance).trigger(ActiveText.SMILDataLoader.Events.SMIL_DATA_ERROR, {
                index: pageIndex
            });
        }
        var deferred = $.Deferred(), urlFromSMILReference = getSMILReferenceForPage(pageIndex), cachedSMILData = getCachedSMILReferenceForPage(pageIndex);
        return cachedSMILData ? setTimeout(function() {
            deferred.resolve(pageIndex, cachedSMILData);
        }, 0) : urlFromSMILReference ? $.ajax({
            url: ActiveText.DataUtils.correctURLPath(activeTextInstance, urlFromSMILReference),
            dataType: "text xml",
            success: onSMILLoaded,
            error: onSMILError
        }) : setTimeout(function() {
            deferred.resolve(pageIndex);
        }, 0), deferred;
    }
    function makeSMILDataAvailable(pageIndex, response) {
        response ? $(activeTextInstance).trigger(ActiveText.SMILDataLoader.Events.SMIL_DATA_LOADED, {
            index: pageIndex,
            data: response
        }) : $(activeTextInstance).trigger(ActiveText.SMILDataLoader.Events.SMIL_DATA_ERROR, {
            index: pageIndex
        });
    }
    /**
     * @param event
     * @param data {{index:number}}
     */
    function loadSMILForIndex(event, data) {
        var pageIndex = 0;
        ActiveText.NavigationUtils.isValidPageIndex(activeTextInstance, data.index) && (pageIndex = data.index), 
        $.when(haveHaveLoadedSMILDataForIndex(pageIndex)).then(makeSMILDataAvailable);
    }
    /**
     * @type {Array}
     */
    var activeTextInstance, smilRefs = [], smilCache = {};
    return {
        init: init,
        hasSMILForPage: hasSMILForPage,
        key: "smildataloader"
    };
}, /* global ActiveText */
/**
 * @class Events
 * @memberOf ActiveText.SMILDataLoader
 * @type {{SMIL_DATA_LOADED: string, SMIL_DATA_ERROR: string}}
 */
ActiveText.SMILDataLoader.Events = {
    SMIL_DATA_LOADED: "activetext.smil.loaded",
    SMIL_DATA_ERROR: "activetext.smil.error"
}, /* global ActiveText */
/**
 * @class SMILFormatHelper
 * @memberOf ActiveText
 * @type {{SMIL_AUDIO_TAG_TEMPLATE:{audioSource:string, clipBegin:string, clipEnd:string, highLightClass:string}, parseTimeCode:parseSMILClockValue, parseSMIL:parseSMIL}}
 */
ActiveText.SMILFormatHelper = function(ActiveText) {
    "use strict";
    function parseSMILClockValue(value) {
        var hours = 0, mins = 0, secs = 0;
        if (value) {
            if (-1 !== value.indexOf("min")) mins = parseFloat(value.substr(0, value.indexOf("min"))); else if (-1 !== value.indexOf("ms")) {
                var ms = parseFloat(value.substr(0, value.indexOf("ms")));
                secs = ms / 1e3;
            } else if (-1 !== value.indexOf("s")) secs = parseFloat(value.substr(0, value.indexOf("s"))); else if (-1 !== value.indexOf("h")) hours = parseFloat(value.substr(0, value.indexOf("h"))); else {
                // parse as hh:mm:ss.fraction
                // this also works for seconds-only, e.g. 12.345
                var arr = value.split(":");
                secs = parseFloat(arr.pop()), arr.length > 0 && (mins = parseFloat(arr.pop()), arr.length > 0 && (hours = parseFloat(arr.pop())));
            }
            return 3600 * hours + 60 * mins + secs;
        }
    }
    function parseHighlightColourFromNode(node) {
        var rtn, type = node.get(0).getAttribute("epub:type");
        if (type && type.indexOf(!0)) for (var propertiesAsArray = type.split(" "), i = 0, l = propertiesAsArray.length; l > i; i++) {
            var typeName = propertiesAsArray[i], pattern = /^highlight-color_/;
            if (pattern.test(typeName)) {
                var keyPairs = typeName.split("_");
                keyPairs.shift(), rtn = keyPairs.join("_");
            }
        }
        return rtn;
    }
    function parseCharacterIdFromNode(node) {
        var rtn, type = node.get(0).getAttribute("epub:type");
        if (type && type.indexOf(!0)) for (var propertiesAsArray = type.split(" "), i = 0, l = propertiesAsArray.length; l > i; i++) {
            var typeName = propertiesAsArray[i], pattern = /^character_/;
            if (pattern.test(typeName)) {
                var keyPairs = typeName.split("_");
                keyPairs.shift(), rtn = keyPairs.join("_");
            }
        }
        return rtn;
    }
    function parseSMIL(smilFile) {
        var smil, audioNode, rawSource, selectionClassArray, rtn = [];
        return $(smilFile).find("body > seq > par > audio, body > par > audio").each(function() {
            audioNode = $(this), rawSource = audioNode.prev().attr("src"), selectionClassArray = rawSource.split("#"), 
            smil = {}, smil.audioSource = audioNode.attr("src"), smil.clipBegin = ActiveText.SMILFormatHelper.parseTimeCode(audioNode.attr("clipBegin")), 
            smil.clipEnd = ActiveText.SMILFormatHelper.parseTimeCode(audioNode.attr("clipEnd")), 
            smil.highlightId = "#" + selectionClassArray.pop(), smil.character = parseCharacterIdFromNode(audioNode.parent()), 
            smil.highlightColour = parseHighlightColourFromNode(audioNode.parent()), rtn.push(smil);
        }), rtn;
    }
    return {
        SMIL_AUDIO_TAG_TEMPLATE: {
            audioSource: "none",
            clipBegin: "00:00",
            clipEnd: "00:00",
            highLightClass: "highlight000"
        },
        parseTimeCode: parseSMILClockValue,
        parseSMIL: parseSMIL
    };
}(ActiveText), /* global ActiveText, Modernizr */
/**
 * @class ClickToPrompt
 * @memberOf ActiveText
 * @returns {{init: init, key: string}}
 * @constructor
 */
ActiveText.ClickToPrompt = function() {
    "use strict";
    /**
     * @param {ActiveText} instance
     */
    function init(instance) {
        instance && instance.options && instance.options.containerElement && (activeTextInstance = instance, 
        $(activeTextInstance.options.containerElement).on("remove", teardown));
    }
    function teardown() {
        $(activeTextInstance.options.containerElement).off("remove", teardown), activeTextInstance = void 0, 
        api.audioPlaybackController = void 0;
    }
    function audioPromptClickHandler(e, data) {
        api.audioPlaybackController || (api.audioPlaybackController = new ActiveText.AudioPlayback(), 
        api.audioPlaybackController.init(activeTextInstance));
        var activeStylesOn, activeStylesOff, fileExtension = ".mp3", params = ActiveText.DataUtils.parseURI(data.data.uri), fileName = params.source, doTrack = !0, hotSpotType = params.type, globalAudioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance), audioPlayback = api.audioPlaybackController, parentElement = $(e.target).parents(".target-area");
        Modernizr.rgba ? (activeStylesOn = {
            background: "rgba(250,250,0,0.2)"
        }, activeStylesOff = {
            background: ""
        }) : (activeStylesOn = {
            border: "1px solid yellow"
        }, activeStylesOff = {
            border: "none"
        });
        var readToMeExtension = ActiveText.ExtensionUtils.getExtensionByKey("readtome");
        $.when(audioPlayback.getMediaPlayer()).then(function() {
            audioPlayback.playing() || globalAudioPlayback && globalAudioPlayback.playing() || readToMeExtension && "" !== readToMeExtension.getState().activeFile ? "audio" === hotSpotType && audioPlayback.stop() : (audioPlayback.setSrc(activeTextInstance.options.pathToAssets + "OPS/media/" + fileName + fileExtension), 
            audioPlayback.play(), parentElement.css(activeStylesOn), $(audioPlayback).on("onfinish", function() {
                parentElement.css(activeStylesOff);
            }), params.hasOwnProperty("report") && "false" === params.report && (doTrack = !1), 
            $(activeTextInstance).trigger(ActiveText.ClickToPrompt.Events.ACTIVATED, {
                word: fileName,
                track: doTrack
            }));
        });
    }
    /**
     * @class ActiveText
     */
    var activeTextInstance, api = {
        init: init,
        audioPlaybackController: void 0,
        hotspotClickFunction: audioPromptClickHandler,
        key: "clicktoprompt"
    };
    return api;
}, /* global ActiveText */
ActiveText.ClickToPrompt.Events = {
    ACTIVATED: "activated.clicktoprompt"
}, /* global ActiveText */
/**
 * @class ReadingComplete
 * @memberOf ActiveText
 * @returns {{init: init}}
 * @constructor
 */
ActiveText.ReadingComplete = function() {
    "use strict";
    function init(instance) {
        instance && instance.options && instance.options.containerElement && (activeTextInstance = instance, 
        $(activeTextInstance.options.containerElement).on("remove", teardown), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, onPageChange));
    }
    function teardown() {
        $(activeTextInstance.options.containerElement).off("remove", teardown), $(activeTextInstance).off(ActiveText.Commands.GO_TO_PAGE, onPageChange), 
        activeTextInstance = void 0;
    }
    function onPageChange() {
        for (var maxIndex = ActiveText.NavigationUtils.getMaximumValidPageIndex(activeTextInstance), visiblePages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), isFinalPage = !1, i = 0, l = visiblePages.length; l > i; i++) visiblePages[i] === maxIndex && (isFinalPage = !0);
        isFinalPage && $(activeTextInstance).trigger(ActiveText.ReadingComplete.Events.READING_COMPLETE);
    }
    var activeTextInstance;
    return {
        init: init,
        key: "readingcomplete"
    };
}, /* global ActiveText */
ActiveText.ReadingComplete.Events = {
    READING_COMPLETE: "readingcomplete.activetext"
}, /* global ActiveText, SoundManager */
/**
 * @class AudioPlayback
 * @memberOf ActiveText
 * @returns {{init: init, play: function, setSrc: setSrc, pause: function, stop: function, getMediaPlayer: getMediaPlayer, playing: function, key: string}}
 * @constructor
 */
ActiveText.AudioPlayback = function() {
    "use strict";
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        activeTextInstance = instance, activeTextInstance && SoundManager && (soundManager = new SoundManager(), 
        soundManager.setup({
            url: ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "soundmanager2/",
            preferFlash: !1,
            debugMode: !1,
            debugFlash: !1,
            useHighPerformance: !0,
            onready: onready,
            ontimeout: ontimeout
        }), soundManager.defaultOptions.multiShot = !1, soundManager.beginDelayedInit(), 
        // important: SoundManager callbacks from Flash require window.soundManager to be set.
        // So the Flash fallbacks will never work if we don't include this line.
        window.soundManager = soundManager);
    }
    function outputLoadState() {
        currentAudio && (2 === currentAudio.readyState && void 0 !== currentAudio.url && "beep.mp3" !== currentAudio.url && $(api).trigger("onerror", {
            url: currentAudio.url
        }), currentAudio.readyState > 1 && $(activeTextInstance).trigger(ActiveText.Commands.HIDE_LOADER), 
        "" !== currentAudio.url && 2 !== currentAudio.readyState && 3 !== currentAudio.readyState && setTimeout(outputLoadState, 50));
    }
    /**
     * @private
     *
     * On iOS, audio remains muted until triggered as the result of a touch interaction, and cannot autoplay automatically.
     * Therefore we tap into the touch globally and try playing a dummy file. This won't work, but when the user taps the
     * screen again after this point, we'll be hooked in and we can play audio without restrictions after that point.
     */
    function applyIOSTouchStartHack() {
        function onFirstTouch() {
            getMediaPlayer(), setSrc("beep.mp3"), playAudio(), activeTextInstance.options.containerElement.off("touchstart", onFirstTouch);
        }
        activeTextInstance.options.containerElement.on("touchstart", onFirstTouch);
    }
    function hideLoader() {
        $(activeTextInstance).trigger(ActiveText.Commands.HIDE_LOADER);
    }
    function onready() {
        isReady = !0, ActiveText.BrowserUtils.isMobileDevice && applyIOSTouchStartHack(), 
        deferredAudioObject && getMediaPlayer();
    }
    function ontimeout() {
        // Hrmm, SM2 could not start. Missing SWF? Flash blocked? Show an error, etc.?
        $(activeTextInstance).trigger(ActiveText.Commands.DISPLAY_ERROR, "Timeout Error: Unable to start Flash Audio Playback.");
    }
    function setSrc(value) {
        if (currentAudio && currentAudio.url !== value) try {
            currentAudio.destruct();
        } catch (error) {}
        (!currentAudio || currentAudio && currentAudio.url !== value) && (currentAudio = soundManager.createSound({
            id: value,
            url: value,
            autoPlay: !1,
            autoLoad: !0,
            flashPollingInterval: 5,
            html5PollingInterval: 5,
            useHighPerformance: !0,
            onload: function() {
                $(api).trigger("onload"), $(activeTextInstance).trigger(ActiveText.Commands.SHOW_LOADER);
            },
            onpause: function() {
                $(api).trigger("onpause");
            },
            onplay: function() {
                $(api).trigger("onplay");
            },
            onresume: function() {
                $(api).trigger("onresume");
            },
            onfinish: function() {
                // important: this is a hack around ie9 spuriously firing onfinish
                // events when changing the source of the audio file
                lastProgress > 0 && $(api).trigger("onfinish");
            },
            whileplaying: function() {
                lastProgress = currentAudio.position, $(api).trigger("ontimeupdate", currentAudio);
            }
        }), lastProgress = 0, setTimeout(outputLoadState, 50));
    }
    function playAudio() {
        if (currentAudio) {
            var options = {
                url: currentAudio.url
            };
            currentAudio.play(options), hideLoader();
        }
    }
    function stopAudio() {
        currentAudio && (currentAudio.pause(), currentAudio.position = 0, currentAudio.stop(), 
        hideLoader());
    }
    function pauseAudio() {
        currentAudio && (currentAudio.pause(), hideLoader());
    }
    function getMediaPlayer() {
        var rtn;
        return isReady ? (deferredAudioObject ? (rtn = deferredAudioObject, deferredAudioObject = void 0) : rtn = $.Deferred(), 
        rtn.resolve(currentAudio)) : (deferredAudioObject || (deferredAudioObject = $.Deferred()), 
        rtn = deferredAudioObject), rtn;
    }
    /**
     * @returns {boolean}
     */
    function isPlaying() {
        var rtn = !1;
        return currentAudio && (rtn = !(currentAudio.paused || 0 === currentAudio.position)), 
        rtn;
    }
    /**
     * @returns {float}
     */
    function getDuration() {
        var rtn = !1;
        return currentAudio && (rtn = currentAudio.durationEstimate), rtn;
    }
    /**
     * @returns {float}
     */
    function getPosition() {
        var rtn = !1;
        return currentAudio && (rtn = currentAudio.position), rtn;
    }
    function setPosition(value) {
        currentAudio && value && currentAudio.setPosition(value);
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, currentAudio, deferredAudioObject, soundManager, lastProgress, isReady = !1, api = {
        init: init,
        play: playAudio,
        setSrc: setSrc,
        pause: pauseAudio,
        stop: stopAudio,
        getMediaPlayer: getMediaPlayer,
        playing: isPlaying,
        getDuration: getDuration,
        getPosition: getPosition,
        setPosition: setPosition,
        key: "audioplayback"
    };
    return api;
}, /* global ActiveText */
/**
 * @class ViewOrientationDetection
 * @memberOf ActiveText
 * @returns {{init: init}}
 * @constructor
 */
ActiveText.ViewOrientationDetection = function() {
    "use strict";
    function init(activeTextInstance) {
        function switchToLandscapeMode() {
            $(activeTextInstance).trigger(ActiveText.Commands.SWITCH_TO_DPS_VIEW);
        }
        function switchToPortraitMode() {
            $(activeTextInstance).trigger(ActiveText.Commands.SWITCH_TO_SPS_VIEW);
        }
        function onOrientationEvent(eventData) {
            switch (eventData = eventData || {}, eventData.orientationDegrees) {
              case PORTRAIT:
                switchToPortraitMode();
                break;

              case PORTRAIT_UPSIDE_DOWN:
                switchToPortraitMode();
                break;

              case LANDSCAPE_LEFT:
                switchToLandscapeMode();
                break;

              case LANDSCAPE_RIGHT:
                switchToLandscapeMode();
                break;

              default:
                var w = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
                w > h ? switchToLandscapeMode() : switchToPortraitMode();
            }
            window.scrollTo(0, 1);
            for (var iframeRef, iframes = document.getElementsByTagName("iframe"), i = 0, j = iframes.length; j > i; i++) iframeRef = iframes[i].contentWindow || iframes[i].contentDocument, 
            window.iframe = iframeRef, iframeRef.postMessage(eventData, "*");
        }
        function eventHandler(event) {
            var eventData = event.data;
            if ("undefined" == typeof eventData) {
                var $topFrame = $(window), innerWidth = $topFrame.innerWidth(), innerHeight = $topFrame.innerHeight(), orientation = innerWidth > innerHeight ? "landscape" : "portrait", orientationDegrees = "landscape" === orientation ? 90 : 0;
                eventData = {
                    orientation: orientation,
                    orientationDegrees: orientationDegrees,
                    innerWidth: innerWidth,
                    innerHeight: innerHeight
                };
            }
            setTimeout(function() {
                onOrientationEvent(eventData);
            }, 500);
        }
        /** @const */
        var PORTRAIT = 0, PORTRAIT_UPSIDE_DOWN = 180, LANDSCAPE_LEFT = 90, LANDSCAPE_RIGHT = -90;
        if (ActiveText.ViewUtils.isCardMode(activeTextInstance) === !1) {
            var orientationEvent = "onorientationchange" in window ? "orientationchange" : "resize";
            orientationEvent += " message", $(window).on(orientationEvent, function(event) {
                var newEvent = event.originalEvent || event;
                setTimeout(function() {
                    eventHandler(newEvent);
                }, 500);
            }), onOrientationEvent();
        }
    }
    return {
        init: init
    };
}, /* global ActiveText, requestAnimationFrame */
ActiveText.Interaction = ActiveText.Interaction || {}, /**
 * @class SwipeGesture
 * @memberOf ActiveText.Interaction
 * @param activeTextInstance {ActiveText}
 * @returns {{register: register, deregister: deregister}}
 * @constructor
 */
ActiveText.Interaction.SwipeGesture = function(activeTextInstance) {
    "use strict";
    function onWindowResize() {
        if (containerElement) {
            cachedContainerWidth = containerElement.width();
            /**
             * @type {boolean}
             */
            var containerElementIsDefined = void 0 !== containerElement, jQueryTouchSwipeIsAvailable = "function" == typeof $.fn.swipe;
            containerElementIsDefined && jQueryTouchSwipeIsAvailable && $(containerElement).swipe("option", "threshold", cachedContainerWidth / 4);
        }
    }
    function onPageChange() {
        shouldLoadNextPages = !0;
    }
    function onSwipeLeft() {
        activeTextInstance.navigation.canGoToNextPage() && activeTextInstance.navigation.gotoNextPage();
    }
    function onSwipeRight() {
        activeTextInstance.navigation.canGoToPreviousPage() && activeTextInstance.navigation.gotoPrevPage();
    }
    //    function cancelTactileMovement()
    //    {
    //        var offsetX = 0;
    //        animateAllPages(offsetX, PAGE_ANIMATION_SPEED);
    //    }
    // fixme: When the tactile gestures are fixed, start here.
    //    function onSwipeStatus(event, phase, direction, distance, duration, fingers)
    //    {
    //        if(phase === 'move')
    //        {
    //            if(direction === 'left' || direction === 'right')
    //            {
    //                var offsetX = distance;
    //                if(direction === 'left')
    //                {
    //                    offsetX *= -1;
    //                }
    //                animateAllPages(offsetX, 0);
    //            }
    //        }
    //        else if(phase === 'cancel')
    //        {
    //            cancelTactileMovement();
    //        }
    //        else if(phase === 'end')
    //        {
    //            if(distance < (cachedContainerWidth / 4))
    //            {
    //                cancelTactileMovement();
    //            }
    //            // otherwise, the other handlers will pick this up!
    //        }
    //    }
    //    function animateAllPages(offsetX, speed)
    //    {
    //        var currentReader = ActiveText.ViewUtils.getCurrentReader(activeTextInstance);
    //        var nextReader = ActiveText.ViewUtils.getNextReader(activeTextInstance);
    //        var prevReader = ActiveText.ViewUtils.getPrevReader(activeTextInstance);
    //
    //        activeTextInstance.view.getContainer().parent().css({
    //            overflow: 'hidden'
    //        });
    //
    //        if(currentReader)
    //        {
    //            currentReader.parent().animate({
    //                left: offsetX
    //            }, {
    //                duration: speed,
    //                easing: 'linear'
    //            });
    //        }
    //
    //        if(nextReader)
    //        {
    //            nextReader.show();
    //            requestAnimationFrame(function()
    //            {
    //                if(shouldLoadNextPages)
    //                {
    //                    activeTextInstance.loader.loadNextDPS();
    //                }
    //            });
    //        }
    //        if(prevReader)
    //        {
    //            prevReader.show();
    //            requestAnimationFrame(function()
    //            {
    //                if(shouldLoadNextPages)
    //                {
    //                    activeTextInstance.loader.loadPrevDPS();
    //                }
    //            });
    //        }
    //
    //        if(shouldLoadNextPages)
    //        {
    //            shouldLoadNextPages = false;
    //        }
    //    }
    function setupSwipeDetection() {
        function teardown() {
            $(activeTextInstance).off(ActiveText.Events.RESIZE, onWindowResize), $(activeTextInstance).off(ActiveText.Commands.GO_TO_PAGE, onPageChange), 
            $(activeTextInstance.options.containerElement).off("remove", teardown), deregister(), 
            containerElement = void 0;
        }
        /**
         * @type {boolean}
         */
        var containerElementIsDefined = void 0 !== containerElement, jQueryTouchSwipeIsAvailable = "function" == typeof $.fn.swipe;
        if (containerElementIsDefined && jQueryTouchSwipeIsAvailable) {
            var options = {
                swipeLeft: onSwipeLeft,
                swipeRight: onSwipeRight,
                // fixme: Reintroduce this for tactile swipe gestures
                //                swipeStatus: onSwipeStatus,
                threshold: 200,
                maxTimeThreshold: 300,
                allowPageScroll: "auto",
                triggerOnTouchLeave: !0
            };
            containerElement.swipe(options), containerElement.swipe("enable");
        }
        $(activeTextInstance).on(ActiveText.Events.RESIZE, onWindowResize), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, onPageChange), 
        activeTextInstance.options && activeTextInstance.options.containerElement && $(activeTextInstance.options.containerElement).on("remove", teardown);
    }
    function removeSwipeDetection() {
        /**
         * @type {boolean}
         */
        var containerElementIsDefined = void 0 !== containerElement, jQueryTouchSwipeIsAvailable = "function" == typeof $.fn.swipe;
        containerElementIsDefined && jQueryTouchSwipeIsAvailable && containerElement.swipe("disable");
    }
    function preventMomentumScrollOnElements(containerElement) {
        activeTextInstance.utils.isFullWindowScalingMode() && (containerElement = $(document.body)), 
        $(containerElement).on("touchmove", function(e) {
            $(e.target).parents(".scrollable").length || e.preventDefault();
        });
    }
    function register(parent) {
        containerElement = parent, preventMomentumScrollOnElements(containerElement), _.once(setupSwipeDetection)();
    }
    function deregister() {
        removeSwipeDetection();
    }
    /**
     * The container element which holds all of the DPS, loading overlays and animation containers.
     *
     * @type {jQuery|object|undefined}
     */
    var containerElement, cachedContainerWidth, shouldLoadNextPages;
    return {
        register: register,
        deregister: deregister
    };
}, /* global ActiveText, Modernizr */
ActiveText.UI = ActiveText.UI || {}, /**
 * @class BasicControls
 * @memberOf ActiveText.UI
 * @returns {{init: init, hideControls: hideControls, revealControls: revealControls, getBarHeight: getBarHeight, key: string, options: *}}
 * @constructor
 */
ActiveText.UI.BasicControls = function() {
    "use strict";
    function init(instance) {
        activeTextInstance = instance, visibilityHelper = new ActiveText.UI.BasicControls.ControlsBarVisibilityHelper(options), 
        $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, create), $(activeTextInstance).on(ActiveText.Events.RESIZE, setHitAreaHeight);
    }
    function getBarHeight() {
        return options && "number" == typeof options.barHeight ? options.barHeight : DEFAULT_BAR_HEIGHT;
    }
    /**
     * @param key {string}
     * @returns {*}
     */
    function getObjectByKey(key) {
        return options && "object" == typeof options[key] ? options[key] : void 0;
    }
    function getContainerVerticalMargins() {
        return parseInt(activeTextInstance.view.getContainer().parent().css("marginBottom"), 10);
    }
    function setHitAreaHeight() {
        if (void 0 !== hitArea) {
            var targetHeight = getContainerVerticalMargins(), barHeight = getBarHeight();
            barHeight > targetHeight && (targetHeight = barHeight), hitArea.css({
                paddingTop: targetHeight - barHeight
            });
        }
    }
    function injectCSSTagToHTMLPage() {
        ActiveText.UI && ActiveText.UI.FontInjection && !ActiveText.UI.FontInjection.hasBeenAdded() && ActiveText.UI.FontInjection.injectFontTag();
        var scope = activeTextInstance.options.containerElement.selector + " ", cssStr = ActiveText.UI.BasicControls.Style.getStyle(scope, activeTextInstance.theme, getBarHeight());
        ActiveText.CSSUtils.embedCSS(cssStr, activeTextInstance.options.containerElement.selector + "-activetext-controls-bar");
    }
    function createHitArea() {
        var container = activeTextInstance.view.getContainer().parent().parent();
        activeTextInstance.utils.isFullWindowScalingMode() || // to use absolute positioning for our main element, we need the container to be relative.
        container.css({
            position: "relative"
        }), hitArea = $("<div/>").css({
            position: activeTextInstance.utils.isFullWindowScalingMode() ? "fixed" : "absolute",
            bottom: 0,
            left: 0,
            right: 0,
            zIndex: DEFAULT_Z_INDEX
        }), hitArea.click(visibilityHelper.revealControls), container.append(hitArea);
    }
    function generateButtonByKeywordForElement(keyword, element) {
        var subClass = ActiveText.UI.BasicControls.AvailableControls[keyword];
        if (subClass && (!subClass.supported || "function" != typeof subClass.supported || subClass.supported()) && subClass.create && "function" == typeof subClass.create) {
            var classOptions = {
                styles: getObjectByKey("buttonStyles"),
                hoverStyles: getObjectByKey("buttonHoverStyles"),
                toggleStyles: getObjectByKey("toggleButtonStyles"),
                toggleHoverStyles: getObjectByKey("toggleButtonHoverStyles")
            };
            options && options.options && (classOptions.options = options.options[keyword]);
            var newElement = subClass.create(activeTextInstance, classOptions);
            return element.append(newElement), element.append(" "), newElement;
        }
    }
    function fitControlsToViewportOnResize() {
        if ("scale" === options.scaleMode) {
            var container = activeTextInstance.options.containerElement, containerWidth = container.outerWidth(), minWidth = options.minWidth;
            controlsBar.css(minWidth > containerWidth ? {
                transform: "scale(" + containerWidth / minWidth + ")",
                "-moz-transform-origin": "0% 100%",
                "-ms-transform-origin": "0% 100%"
            } : {
                transform: ""
            });
        }
    }
    function addEventListeners() {
        options.minWidth && void 0 !== options.scaleMode && ($(activeTextInstance).on(ActiveText.Events.RESIZE, fitControlsToViewportOnResize), 
        fitControlsToViewportOnResize());
    }
    function createButtonGroup(group, container, tabindexOffset) {
        if (group) {
            for (var controlsElement, buttons = group.split(","), returnValue = 0, i = 0, l = buttons.length; l > i; i++) controlsElement = generateButtonByKeywordForElement(buttons[i], container), 
            controlsElement && (controlsElement.find("*").andSelf().filter('[role="button"],input').attr("tabindex", i + tabindexOffset), 
            returnValue++, 0 === i && controlsElement.addClass("first"));
            return controlsElement && controlsElement.addClass("last"), {
                count: returnValue,
                container: container
            };
        }
        return {
            count: tabindexOffset
        };
    }
    function initDefaultSettings() {
        options || (options = {}), options.primary || options.secondary || options.leftButtons || options.rightButtons || (options.primary = "previous,next");
    }
    function checkOverlayMode() {
        options && "boolean" == typeof options.overlay && options.overlay === !1 && ("object" != typeof activeTextInstance.options.containerCoordinates && (activeTextInstance.options.containerCoordinates = {
            top: 0,
            left: 0,
            bottom: 0,
            right: 0
        }), activeTextInstance.options.containerCoordinates.bottom += getBarHeight());
    }
    function createControlsBar() {
        var DEFAULT_BAR_STYLE = {
            textAlign: "center",
            height: getBarHeight(),
            userSelect: "none",
            font: "16px/" + (getBarHeight() - 2) + "px Helvetica, Helvetica Neue, Arial",
            fontSize: 32,
            backgroundSize: "100% " + getBarHeight() + "px"
        }, version = parseInt($.browser.version, 10);
        (!$.browser.msie || $.browser.msie && version > 8) && $.extend(DEFAULT_BAR_STYLE, {
            backgroundColor: activeTextInstance.theme.getControlsBackgroundColor(.5)
        }), controlsBar = $("<div class='controls-bar'></div>").css(DEFAULT_BAR_STYLE), 
        controlsBar.click(function() {
            return !1;
        });
        var customStyles = getObjectByKey("barStyles");
        customStyles && controlsBar.css(customStyles), $(document).ready(function() {
            initDefaultSettings();
            var leftButtonsContainer = $('<div style="position:absolute;left:0"></div>');
            options.leftButtonOptions && leftButtonsContainer.css(options.leftButtonOptions);
            var primaryButtonsContainer = $('<div style="position:absolute;width:100%;"></div>');
            options.primaryButtonOptions && primaryButtonsContainer.css(options.primaryButtonOptions);
            var secondaryButtonsContainer = $('<div style="position:absolute;right:0;"></div>');
            options.secondaryButtonOptions && secondaryButtonsContainer.css(options.secondaryButtonOptions);
            var rightButtonsContainer = $('<div style="position:absolute;right:0"></div>');
            options.rightButtonOptions && rightButtonsContainer.css(options.rightButtonOptions);
            var tabIndexStart = 2, leftButtonGroup = createButtonGroup(options.leftButtons, leftButtonsContainer, tabIndexStart);
            tabIndexStart += leftButtonGroup.count;
            var primaryButtonGroup = createButtonGroup(options.primary, primaryButtonsContainer, tabIndexStart);
            tabIndexStart += primaryButtonGroup.count;
            var secondaryButtonGroup = createButtonGroup(options.secondary, secondaryButtonsContainer, tabIndexStart);
            tabIndexStart += secondaryButtonGroup.count;
            var rightButtonGroup = createButtonGroup(options.rightButtons, rightButtonsContainer, tabIndexStart);
            if (controlsBar.append(primaryButtonGroup.container), controlsBar.append(secondaryButtonGroup.container), 
            controlsBar.append(leftButtonGroup.container), controlsBar.append(rightButtonGroup.container), 
            !options.barStyles && !Modernizr.rgba) {
                var backgroundBlock = $('<div style="top:0;left:0;bottom:0;right:0;position:absolute" role="presentation"></div>').css({
                    background: activeTextInstance.theme.getControlsBackgroundColor(.5)
                });
                backgroundBlock.css({
                    filter: "alpha(opacity=50)"
                }), controlsBar.prepend(backgroundBlock);
            }
            addEventListeners(), checkOverlayMode(), $(activeTextInstance).trigger({
                type: ActiveText.Events.UI_ELEMENT_LOADED,
                element: "controls-bar"
            });
        }), hitArea.append(controlsBar), visibilityHelper.register(activeTextInstance, controlsBar, getBarHeight());
    }
    function create() {
        injectCSSTagToHTMLPage(), createHitArea(), createControlsBar();
    }
    function revealControls() {
        visibilityHelper.revealControls();
    }
    function hideControls() {
        visibilityHelper.hideControls();
    }
    /**
     * @const
     * @type {number}
     */
    var activeTextInstance, options, DEFAULT_Z_INDEX = 1010, DEFAULT_BAR_HEIGHT = 50;
    2 === arguments.length ? (activeTextInstance = arguments[0], options = arguments[1]) : 1 === arguments.length && (options = arguments[0]);
    var controlsBar, hitArea, visibilityHelper;
    return activeTextInstance && init(activeTextInstance), {
        init: init,
        hideControls: hideControls,
        revealControls: revealControls,
        getBarHeight: getBarHeight,
        key: "controls",
        options: options
    };
}, /* global ActiveText, Modernizr */
ActiveText.UI = ActiveText.UI || {}, ActiveText.UI.BasicControls = ActiveText.UI.BasicControls || {}, 
ActiveText.UI.BasicControls.ControlsBarVisibilityHelper = function(options) {
    "use strict";
    function register(instance, inputControlsBar, inputBarHeight) {
        activeTextInstance = instance, controlsBar = inputControlsBar, barHeight = inputBarHeight, 
        create(), addEventListeners();
    }
    function getContainerVerticalMargins(activeTextInstance) {
        return parseInt(activeTextInstance.view.getContainer().parent().css("marginBottom"), 10);
    }
    function addEventListeners() {
        function attachSwipeInteractions() {
            container && container.swipe && "function" == typeof container.swipe && (container.swipe({
                swipeUp: revealControls,
                swipeDown: hideControls
            }), container.parent().swipe({
                click: toggleControls
            }));
        }
        var container = activeTextInstance.view.getContainer().parent();
        options.overlay === !0 && attachSwipeInteractions(), options.minWidth && void 0 !== options.scaleMode && controlsBar.css({
            transformOriginX: "left",
            transformOriginY: "bottom",
            minWidth: options.minWidth
        });
    }
    function create() {
        options && (!options.openByDefault && options.overlay || void 0 === options.overlay && !options.openByDefault) && hideControls();
    }
    function toggleControls() {
        "on" === controlsBar.attr("data-toggle") ? hideControls() : revealControls();
    }
    function revealControls() {
        var targetHeight = getContainerVerticalMargins(activeTextInstance);
        return barHeight > targetHeight && (targetHeight = barHeight), options.overlay === !0 && controlsBar.attr("data-toggle", "on").animate({
            marginTop: targetHeight - barHeight,
            marginBottom: -(targetHeight - barHeight)
        }, {
            duration: DEFAULT_ANIMATION_SPEED,
            easing: "easeOutExpo"
        }), !1;
    }
    function hideControls() {
        var targetHeight = getContainerVerticalMargins(activeTextInstance);
        return barHeight > targetHeight && (targetHeight = barHeight), options.overlay === !0 && controlsBar.attr("data-toggle", "off").animate({
            marginTop: targetHeight,
            marginBottom: -targetHeight
        }, {
            duration: DEFAULT_ANIMATION_SPEED,
            easing: "easeOutExpo",
            queue: !1
        }), !1;
    }
    /**
     * @const
     * @private
     * @type {number}
     */
    var activeTextInstance, barHeight, controlsBar, DEFAULT_ANIMATION_SPEED = 300;
    return {
        register: register,
        hideControls: hideControls,
        revealControls: revealControls
    };
}, /* global ActiveText*/
ActiveText.namespace("ActiveText.UI.BasicControls.Style"), ActiveText.UI.BasicControls.Style = function() {
    "use strict";
    /**
     * @param scope {string}
     * @param theme {ActiveText.Theme}
     * @returns {string}
     */
    function getStyle(scope, theme) {
        var foregroundColor = theme.getControlsForegroundColor(), foregroundHoverColor = theme.getControlsForegroundHoverColor(), rtn = scope + "a.activetext-default," + scope + "a.activetext-default:link," + scope + "a.activetext-default:visited," + scope + "a.activetext-default svg polygon," + scope + "a.activetext-default:link svg polygon," + scope + "a.activetext-default:visited svg polygon {text-decoration:none;color:" + foregroundColor + ";fill:" + foregroundColor + ";cursor:pointer;-webkit-touch-callout: none;-webkit-user-select: none;-khtml-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;background: " + foregroundHoverColor + ";-webkit-border-radius: 21px;-khtml-border-radius: 21px;-moz-border-radius: 21px;-ms-border-radius: 21px;-o-border-radius: 21px;border-radius: 21px;margin: 4px 0;width: 42px;height: 42px;line-height: 1.3em !important;display:inline-block}" + scope + "a.activetext-default:hover," + scope + "a.activetext-default:focus," + scope + "a.activetext-default:active," + scope + "a.activetext-default:hover svg polygon," + scope + "a.activetext-default:focus svg polygon," + scope + "a.activetext-default:active svg polygon {text-decoration:none;color:" + foregroundHoverColor + ";fill:" + foregroundHoverColor + ";background:" + foregroundColor + "}.pull-right {float:right;}" + scope + "a.activetext-default.active," + scope + "a.activetext-default.active:link," + scope + "a.activetext-default.active:visited {background: red;}" + scope + "a.activetext-default.active:hover," + scope + "a.activetext-default.active:focus," + scope + "a.activetext-default.active:active {color:red;background:" + foregroundColor + "}}" + scope + "a.activetext-default i {position:absolute}" + scope + ".controls-bar img {vertical-align:middle;}.playbackDiv {width: 85px;height: 42px;position: absolute;left: -100px;margin-top: 4px;text-align: center;background: url(/static/img/rapid/ButtonsBackground.svg) no-repeat center center/contain;}.button.record, .button.play {z-index: 1010;margin-top: -1px;}.button.record img {margin-left: 7px;}.button.play img {margin-left: 2px;}.recordingWidget {bottom: 0;height: 174px;left: 0;margin: auto;position: absolute;top: 0;right: 0;width: 467px;z-index: 999;}.tooltip {position: absolute;z-index: 1030;display: block;font-size: 13px;line-height: 1.4;opacity: 0;filter: alpha(opacity=0);visibility: visible;padding-bottom:1em;-webkit-box-sizing: content-box;-moz-box-sizing: content-box;box-sizing: content-box;}.tooltip.in {opacity: 0.8;filter: alpha(opacity=80);}.tooltip.top {padding: 5px 0;margin-top: -3px;}.tooltip-inner {max-width: 200px;padding: 8px;color: #ffffff;text-align: center;text-decoration: none;background-color: #000000;-webkit-border-radius: 4px;-moz-border-radius: 4px;border-radius: 4px;max-height: 1.4em;text-overflow: ellipsis;white-space: nowrap;-webkit-box-sizing: content-box;-moz-box-sizing: content-box;box-sizing: content-box;}.tooltip-arrow {position: absolute;width: 0;height: 0;border-color: transparent;border-style: solid;-webkit-box-sizing: content-box;-moz-box-sizing: content-box;box-sizing: content-box;}.tooltip.top .tooltip-arrow {bottom: 0;left: 50%;margin-left: -5px;border-top-color: #000000;border-width: 5px 5px 0;}.fade {opacity: 0;-webkit-transition: opacity 0.15s linear;-moz-transition: opacity 0.15s linear;transition: opacity 0.15s linear;}.fade.in {opacity: 1;}";
        return rtn;
    }
    return {
        getStyle: getStyle
    };
}(), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.DrawingToolsPanel"), ActiveText.UI.DrawingToolsPanel = function() {
    "use strict";
    function getDefaultColour() {
        var rtn = DEFAULT_COLOUR_CODE;
        if (toolPanelRef) {
            var existingValue = toolPanelRef.find(".colorPicker-picker").css("background-color"), existingColour = ActiveText.ColourUtils.convertRGBToHex(existingValue);
            existingValue && existingColour && (rtn = existingColour);
        }
        return rtn;
    }
    function onPageChange() {
        if (drawingToolsInstance) {
            for (var pages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), i = 0, l = activePages.length; l > i; i++) drawingToolsInstance.disable(activePages[i]), 
            drawingToolsInstance.enable(pages[i]);
            activePages = pages;
        }
    }
    function createToolPanel() {
        var containerElement = activeTextInstance.options.containerElement, existingWidth = containerElement.width() - 268, existingHeight = containerElement.height();
        containerElement.find(".controls-bar") && (existingHeight -= containerElement.find(".controls-bar").height());
        var panelTemplate = factory.panelTemplate, newPanel = $(panelTemplate).css({
            position: "absolute",
            top: existingHeight - 54,
            left: existingWidth / 2,
            zIndex: 2e3,
            opacity: 0
        }).appendTo(containerElement);
        newPanel.find(".gripper").css({
            position: "absolute",
            left: 4,
            top: 4,
            bottom: 4,
            width: 20,
            cursor: "move"
        }), newPanel.draggable({
            containment: containerElement,
            drag: function() {
                $(this).find("#colourpicker-tool").colorPicker.hidePalette();
            }
        }), newPanel.find("#colourpicker-tool").colorPicker({
            pickerDefault: getDefaultColour(),
            colors: DEFAULT_COLOURS_PALETTE,
            onColorChange: function(id, newValue) {
                drawingToolsInstance.setActiveColour(newValue);
            }
        }), newPanel.animate({
            top: existingHeight - 64,
            opacity: 1
        }, 300), $(activeTextInstance).off(ActiveText.Events.RESIZE, onResize).on(ActiveText.Events.RESIZE, onResize);
    }
    function showToolPanel() {
        if ($(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, onPageChange), void 0 !== activeTextInstance.view.disableInteraction && activeTextInstance.view.disableInteraction(), 
        hasToolPanel() ? getToolPanel().fadeIn() : createToolPanel(), drawingToolsInstance = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "drawingtools")) {
            var defaultColour = getDefaultColour();
            drawingToolsInstance.setActiveColour(defaultColour);
            for (var pages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), i = 0, l = pages.length; l > i; i++) drawingToolsInstance.enable(pages[i]);
            activePages = pages, attachEvents(), activeTextInstance.options.containerElement.find("button.pen-tool").click();
        }
    }
    function hideToolPanel() {
        if ($(activeTextInstance).off(ActiveText.Commands.GO_TO_PAGE, onPageChange), void 0 !== activeTextInstance.view.enableInteraction && activeTextInstance.view.enableInteraction(), 
        getToolPanel().fadeOut(), drawingToolsInstance) {
            var i, l, pages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance);
            for (i = 0, l = pages.length; l > i; i++) drawingToolsInstance.disable(pages[i]);
            for (i = 0, l = activePages.length; l > i; i++) drawingToolsInstance.disable(activePages[i]);
        }
    }
    function getToolPanel() {
        return toolPanelRef && 0 !== toolPanelRef.length || (toolPanelRef = activeTextInstance.options.containerElement.find(".iwbToolsPanel")), 
        toolPanelRef;
    }
    function hasToolPanel() {
        return activeTextInstance.options.containerElement.find(".iwbToolsPanel").length > 0;
    }
    function penToolClickHandler() {
        var toolPanel = getToolPanel();
        toolPanel.find("button.pen-tool").addClass("active"), toolPanel.find("button.highlighter-tool").removeClass("active"), 
        toolPanel.find("button.eraser-tool").removeClass("active"), toolPanel.find("button.clear-tool").removeClass("active"), 
        drawingToolsInstance.setCurrentTool("pen");
    }
    function highlighterToolClickHandler() {
        var toolPanel = getToolPanel();
        toolPanel.find("button.pen-tool").removeClass("active"), toolPanel.find("button.highlighter-tool").addClass("active"), 
        toolPanel.find("button.eraser-tool").removeClass("active"), toolPanel.find("button.clear-tool").removeClass("active"), 
        drawingToolsInstance.setCurrentTool("highlighter");
    }
    function eraserToolClickHandler() {
        var toolPanel = getToolPanel();
        toolPanel.find("button.pen-tool").removeClass("active"), toolPanel.find("button.highlighter-tool").removeClass("active"), 
        toolPanel.find("button.eraser-tool").addClass("active"), toolPanel.find("button.clear-tool").removeClass("active"), 
        drawingToolsInstance.setCurrentTool("eraser");
    }
    function clearScreenToolClickHandler() {
        var toolPanel = getToolPanel();
        toolPanel.find("button.pen-tool").removeClass("active"), toolPanel.find("button.highlighter-tool").removeClass("active"), 
        toolPanel.find("button.eraser-tool").removeClass("active"), toolPanel.find("button.clear-tool").addClass("active");
        for (var pages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), i = 0, l = pages.length; l > i; i++) drawingToolsInstance.clearDrawings(pages[i]);
    }
    function attachEvents() {
        var toolPanel = getToolPanel();
        toolPanel.find("button.pen-tool").on("click", penToolClickHandler), toolPanel.find("button.highlighter-tool").on("click", highlighterToolClickHandler), 
        toolPanel.find("button.eraser-tool").on("click", eraserToolClickHandler), toolPanel.find("button.clear-tool").on("click", clearScreenToolClickHandler);
    }
    function keepWithinVisibleBounds(toolPanel) {
        var dimensions = ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance), toolPanelLeft = parseInt(toolPanel.css("left"), 10), toolPanelTop = parseInt(toolPanel.css("top"), 10), toolPanelWidth = toolPanel.outerWidth(), toolPanelHeight = toolPanel.outerHeight(), containerHeight = dimensions.availHeight, containerWidth = dimensions.availWidth;
        0 > toolPanelLeft && toolPanel.css("left", 0), toolPanelLeft + toolPanelWidth > containerWidth && toolPanel.css("left", containerWidth - toolPanelWidth), 
        0 > toolPanelTop && toolPanel.css("top", 0), toolPanelTop + toolPanelHeight > containerHeight && toolPanel.css("top", containerHeight - toolPanelHeight);
    }
    function onResize() {
        var toolPanel = getToolPanel();
        keepWithinVisibleBounds(toolPanel);
    }
    function init(initOptions) {
        options = initOptions, factory = new ActiveText.UI.DrawingToolsPanelFactory(), options && (options.activeTextInstance && (activeTextInstance = options.activeTextInstance), 
        ActiveText.CSSUtils.embedCSS(ActiveText.UI.DrawingToolsPanel.Style));
    }
    var toolPanelRef, factory, drawingToolsInstance, options, activeTextInstance, activePages, DEFAULT_COLOUR_CODE = "#0000CD", DEFAULT_COLOURS_PALETTE = [ "000000", "FFFFFF", "0000CD", "FF0000", "008000", "FF4500", "FF69B4", "ADFF2F", "FFFF00", "00BFFF" ];
    return {
        init: init,
        showToolPanel: showToolPanel,
        hideToolPanel: hideToolPanel
    };
}, /* globals ActiveText */
/**
 * @class DrawingToolsPanelFactory
 * @memberOf ActiveText.UI
 * @constructor
 */
ActiveText.UI.DrawingToolsPanelFactory = function() {
    "use strict";
    var panelTemplate = '<div class="iwbToolsPanel">';
    return panelTemplate += '<div class="gripper"></div>', panelTemplate += '<button class="btn pen-tool"><i class="pen-tool"></i>Pen Tool</button>', 
    panelTemplate += '<button class="btn highlighter-tool"><i class="highlighter-tool"></i>Highlighter</button>', 
    panelTemplate += '<button class="btn eraser-tool"><i class="eraser-tool"></i>Eraser</button>', 
    panelTemplate += '<button class="btn clear-tool"><i class="clear-tool"></i>Clear all</button>', 
    panelTemplate += '<div id="colourpicker-tool"></div>', panelTemplate += "</div>", 
    {
        panelTemplate: panelTemplate
    };
}, /* global ActiveText */
/**
 * @class Style
 * @memberOf ActiveText.UI.DrawingToolsPanel
 * @type string
 */
ActiveText.UI.DrawingToolsPanel.Style = function(ActiveText) {
    "use strict";
    var pathToResources = ActiveText.SkinUtils.getPathToGlobalResource(), buttonBackgroundHoverColour = "#434343", buttonBackgroundColour = "#707070", buttonWidth = 44;
    return "div.iwbToolsPanel{position:absolute;padding:4px 4px 4px 36px;background:white url('" + pathToResources + "img/gripper.png') 5px 5px no-repeat;border:1px solid #a0a0a0;width:226px;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-o-user-select:none;user-select:none;-webkit-box-shadow:0 1px 5px rgba(0, 0, 0, 0.5);-moz-box-shadow:0 1px 5px rgba(0, 0, 0, 0.5);box-shadow:0 1px 5px rgba(0, 0, 0, 0.5);-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;}div.iwbToolsPanel button.btn{display:inline-block;text-align:center;vertical-align:middle;border:1px solid #ccc;cursor:pointer;width:" + buttonWidth + "px;height:" + buttonWidth + "px;padding:0;margin:0 0 0 1px;background-color:" + buttonBackgroundColour + ";background-image:-moz-linear-gradient(top, " + buttonBackgroundColour + ", " + buttonBackgroundColour + ");background-image:-ms-linear-gradient(top, " + buttonBackgroundColour + ", " + buttonBackgroundColour + ");background-image:-webkit-gradient(linear, 0 0, 0 100%, from(" + buttonBackgroundColour + "), to(" + buttonBackgroundColour + "));background-image:-webkit-linear-gradient(top, " + buttonBackgroundColour + ", " + buttonBackgroundColour + ");background-image:-o-linear-gradient(top, " + buttonBackgroundColour + ", " + buttonBackgroundColour + ");background-image:linear-gradient(top, " + buttonBackgroundColour + ", " + buttonBackgroundColour + ");background-repeat:repeat-x;border-color:" + buttonBackgroundColour + " " + buttonBackgroundColour + " #4a4a4a;border-color:rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled = false);-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;overflow:hidden;color:white;text-shadow:0px 1px 0px rgba(0, 0, 0, 0.4);font-size:13px;line-height:18px;}div.iwbToolsPanel button.btn:hover, div.iwbToolsPanel button.btn:active, div.iwbToolsPanel button.btn.active, div.iwbToolsPanel button.btn.disabled, div.iwbToolsPanel button.btn[disabled]{background-color:" + buttonBackgroundColour + ";}div.iwbToolsPanel button.btn:active, div.iwbToolsPanel button.btn.active{background-color:#575757 \\9;}div.iwbToolsPanel button.btn:hover, div.iwbToolsPanel button.btn.hover{background-color:" + buttonBackgroundHoverColour + ";background-image:-moz-linear-gradient(top, " + buttonBackgroundHoverColour + ", " + buttonBackgroundHoverColour + ");background-image:-ms-linear-gradient(top, " + buttonBackgroundHoverColour + ", " + buttonBackgroundHoverColour + ");background-image:-webkit-gradient(linear, 0 0, 0 100%, from(" + buttonBackgroundHoverColour + "), to(" + buttonBackgroundHoverColour + "));background-image:-webkit-linear-gradient(top, " + buttonBackgroundHoverColour + ", " + buttonBackgroundHoverColour + ");background-image:-o-linear-gradient(top, " + buttonBackgroundHoverColour + ", " + buttonBackgroundHoverColour + ");background-image:linear-gradient(top, " + buttonBackgroundHoverColour + ", " + buttonBackgroundHoverColour + ");background-repeat:repeat-x;border-color:" + buttonBackgroundHoverColour + " " + buttonBackgroundHoverColour + " #1d1d1d;border-color:rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled = false);background-position:0 0;}div.iwbToolsPanel button.btn:hover:hover, div.iwbToolsPanel button.btn:hover:active, div.iwbToolsPanel button.btn:hover.active, div.iwbToolsPanel button.btn:hover.disabled, div.iwbToolsPanel button.btn:hover[disabled], div.iwbToolsPanel button.btn.hover:hover, div.iwbToolsPanel button.btn.hover:active, div.iwbToolsPanel button.btn.hover.active, div.iwbToolsPanel button.btn.hover.disabled, div.iwbToolsPanel button.btn.hover[disabled]{background-color:" + buttonBackgroundHoverColour + ";}div.iwbToolsPanel button.btn:hover:active, div.iwbToolsPanel button.btn:hover.active, div.iwbToolsPanel button.btn.hover:active, div.iwbToolsPanel button.btn.hover.active{background-color:#2a2a2a \\9;}div.iwbToolsPanel button.btn:active, div.iwbToolsPanel button.btn.active{background-color:" + buttonBackgroundHoverColour + ";background-image:-moz-linear-gradient(top, " + buttonBackgroundHoverColour + ", " + buttonBackgroundHoverColour + ");background-image:-ms-linear-gradient(top, " + buttonBackgroundHoverColour + ", " + buttonBackgroundHoverColour + ");background-image:-webkit-gradient(linear, 0 0, 0 100%, from(" + buttonBackgroundHoverColour + "), to(" + buttonBackgroundHoverColour + "));background-image:-webkit-linear-gradient(top, " + buttonBackgroundHoverColour + ", " + buttonBackgroundHoverColour + ");background-image:-o-linear-gradient(top, " + buttonBackgroundHoverColour + ", " + buttonBackgroundHoverColour + ");background-image:linear-gradient(top, " + buttonBackgroundHoverColour + ", " + buttonBackgroundHoverColour + ");background-repeat:repeat-x;border-color:" + buttonBackgroundHoverColour + " " + buttonBackgroundHoverColour + " #1d1d1d;border-color:rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);filter:progid:DXImageTransform.Microsoft.gradient(enabled = false); }div.iwbToolsPanel button.btn:active:hover, div.iwbToolsPanel button.btn:active:active, div.iwbToolsPanel button.btn:active.active, div.iwbToolsPanel button.btn:active.disabled, div.iwbToolsPanel button.btn:active[disabled], div.iwbToolsPanel button.btn.active:hover, div.iwbToolsPanel button.btn.active:active, div.iwbToolsPanel button.btn.active.active, div.iwbToolsPanel button.btn.active.disabled, div.iwbToolsPanel button.btn.active[disabled]{background-color:" + buttonBackgroundHoverColour + ";}div.iwbToolsPanel button.btn:active:active, div.iwbToolsPanel button.btn:active.active, div.iwbToolsPanel button.btn.active:active, div.iwbToolsPanel button.btn.active.active{background-color:#2a2a2a \\9;}div.iwbToolsPanel button.btn i{display:block; }div.iwbToolsPanel button.btn i.pen-tool{width:" + buttonWidth + "px;height:" + buttonWidth + "px;background:transparent url('" + pathToResources + "img/pen-tool.png') center center no-repeat; }div.iwbToolsPanel button.btn i.highlighter-tool{width:" + buttonWidth + "px;height:" + buttonWidth + "px;background:transparent url('" + pathToResources + "img/highlighter-tool.png') center center no-repeat;}div.iwbToolsPanel button.btn i.eraser-tool{width:" + buttonWidth + "px;height:" + buttonWidth + "px;background:transparent url('" + pathToResources + "img/eraser-tool.png') center center no-repeat;}div.colorPicker-picker{height:" + buttonWidth + "px;width:" + buttonWidth + "px;padding:0;margin:0 0 0 2px;background:url(" + pathToResources + "img/colour-picker/arrow.gif) no-repeat bottom right;cursor:pointer;display:inline-block;-webkit-box-shadow:inset 0 1px 5px rgba(0, 0, 0, 0.3);-moz-box-shadow:inset 0 1px 5px rgba(0, 0, 0, 0.3);box-shadow:inset 0 1px 5px rgba(0, 0, 0, 0.3);vertical-align:top;}div.colorPicker-picker.active{background-image:url(" + pathToResources + "img/colour-picker/arrow-active.gif);}div.colorPicker-palette{width:240px;position:absolute;background:white;border:1px solid #a0a0a0;-webkit-border-radius:3px;-moz-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 5px rgba(0, 0, 0, 0.5);-moz-box-shadow:0 1px 5px rgba(0, 0, 0, 0.5);box-shadow:0 1px 5px rgba(0, 0, 0, 0.5);padding:2px;z-index:9999;}div.colorPicker_hexWrap{width:100%;float:left;display:none;}div.colorPicker-swatch{height:" + buttonWidth + "px;width:" + buttonWidth + "px;margin:2px;float:left;cursor:pointer;-webkit-box-shadow:inset 0 1px 5px rgba(0, 0, 0, 0.3);-moz-box-shadow:inset 0 1px 5px rgba(0, 0, 0, 0.3);box-shadow:inset 0 1px 5px rgba(0, 0, 0, 0.3);-webkit-transition:all .2s ease-in-out;}div.colorPicker-swatch:hover{-webkit-transform:scale(1.1);-webkit-box-shadow:0 1px 3px rgba(0, 0, 0, 0.3);-moz-box-shadow:0 1px 3px rgba(0, 0, 0, 0.3);box-shadow:0 1px 3px rgba(0, 0, 0, 0.3);}.canvas-container{position:absolute;z-index:1010;top:0;left:0;bottom:0;right:0;background:transparent;filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#01000000,endColorstr=#01000000);background:rgba(0,0,0,0);zoom:1}";
}(ActiveText), /* global ActiveText, Modernizr */
ActiveText.Analytics = function() {
    "use strict";
    function init(instance) {
        if (instance && instance.options && instance.options.containerElement) {
            activeTextInstance = instance, $(activeTextInstance.options.containerElement).on("remove", teardown), 
            startTime = new Date().getTime();
            var $activeTextInstance = $(activeTextInstance);
            $activeTextInstance.on(ActiveText.Events.BOOK_STRUCTURE_LOADED, bookLoadEvent), 
            $activeTextInstance.on(ActiveText.Events.NAVMAP_LOADED, navMapLoaded), $activeTextInstance.on(ActiveText.Commands.GO_TO_PAGE, currentPageChanged), 
            $activeTextInstance.on(ActiveText.Hotspots.Events.CLICKED, hotspotClicked), $activeTextInstance.on(ActiveText.Events.FRAME_CONTENT_LOADED, frameLoad), 
            $activeTextInstance.on(ActiveText.Events.FRAME_CONTENT_ERROR, frameLoad), $activeTextInstance.on(ActiveText.Events.UI_ELEMENT_CLICKED, uiElementClicked), 
            window.onbeforeunload = beforeClose;
        }
    }
    function teardown() {
        $(activeTextInstance.options.containerElement).off("remove", teardown);
        var $activeTextInstance = $(activeTextInstance);
        $activeTextInstance.off(ActiveText.Events.BOOK_STRUCTURE_LOADED, bookLoadEvent), 
        $activeTextInstance.off(ActiveText.Events.NAVMAP_LOADED, navMapLoaded), $activeTextInstance.off(ActiveText.Commands.GO_TO_PAGE, currentPageChanged), 
        $activeTextInstance.off(ActiveText.Hotspots.Events.CLICKED, hotspotClicked), $activeTextInstance.off(ActiveText.Events.FRAME_CONTENT_LOADED, frameLoad), 
        $activeTextInstance.off(ActiveText.Events.FRAME_CONTENT_ERROR, frameLoad), $activeTextInstance.off(ActiveText.Events.UI_ELEMENT_CLICKED, uiElementClicked), 
        window.onbeforeunload = void 0;
    }
    function dispatchEventWithData(type, data) {
        var eventData = $.extend(data, {
            timestamp: new Date().getTime(),
            browser: window.navigator.userAgent,
            whichbook: activeTextInstance.options.pathToAssets,
            host: window.location.href
        });
        //        debug.log('Dispatching Event with type ', type, ' and data is ', eventData);
        $(activeTextInstance).trigger(type, eventData);
    }
    function navMapLoaded() {
        navHasLoaded = !0;
    }
    function bookLoadEvent() {
        if (navHasLoaded) {
            var timeToLoad = new Date().getTime() - startTime + "ms", capabilitiesArray = [];
            for (var prop in Modernizr) "boolean" == typeof Modernizr[prop] && capabilitiesArray.push(prop);
            var capabilitiesString = capabilitiesArray.toString(), extensionsString = "";
            if (activeTextInstance && activeTextInstance.options && activeTextInstance.options.extensions) {
                for (var extensions = [], i = 0, l = activeTextInstance.options.extensions.length; l > i; i++) extensions.push(activeTextInstance.options.extensions[i].key || "");
                extensionsString = extensions.toString();
            }
            var eventObject = {
                timetoload: timeToLoad,
                capabilities: capabilitiesString,
                extensions: extensionsString,
                screendimensions: window.screen.availWidth + "x" + window.screen.availHeight
            };
            dispatchEventWithData(ActiveText.Analytics.Events.BOOK_OPENED, eventObject);
        }
    }
    function frameLoad(event, data) {
        var ebookStructure = activeTextInstance.data.getFlatListOfNavigation(), visiblePages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance);
        if (_.contains(visiblePages, data.index) && ebookStructure[data.index]) {
            var startTime = parseInt(pageTimes[data.index], 10), loadTime = new Date().getTime() - startTime, eventObject = {
                pagetitle: ebookStructure[data.index].title,
                pageindex: data.index,
                pagenumber: ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, data.index),
                pageurl: activeTextInstance.utils.getSourcePathForIndex(data.index),
                viewmode: activeTextInstance.view.model.getScaleMode(),
                timetoload: loadTime + "ms"
            };
            dispatchEventWithData(ActiveText.Analytics.Events.PAGE_VIEW, eventObject);
        }
    }
    function uiElementClicked(event, data) {
        var eventObject = {
            elementname: data.which,
            interactiontype: "click"
        };
        dispatchEventWithData(ActiveText.Analytics.Events.UI_ACTIVATED, eventObject);
    }
    function currentPageChanged() {
        for (var startTime = new Date().getTime(), visiblePages = ActiveText.ViewUtils.getVisiblePages(activeTextInstance), i = 0, l = visiblePages.length; l > i; i++) pageTimes[visiblePages[i]] = startTime;
    }
    function hotspotClicked(event, data) {
        var uridata = "";
        data && data.data && (uridata = data.data.uri);
        var eventObject = {
            uridata: uridata,
            type: data.type
        };
        dispatchEventWithData(ActiveText.Analytics.Events.OVERLAY_ACTIVATED, eventObject);
    }
    function beforeClose() {
        var eventObject = {};
        dispatchEventWithData(ActiveText.Analytics.Events.BOOK_CLOSED, eventObject);
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, startTime, pageTimes = {}, navHasLoaded = !1;
    return {
        init: init,
        key: "analytics"
    };
}, /* global ActiveText */
ActiveText.Analytics.Events = {
    BOOK_OPENED: "bookopened.analytics.activetext",
    PAGE_VIEW: "pageview.analytics.activetext",
    PAGE_EXIT: "pageexit.analytics.activetext",
    BOOK_CLOSED: "bookclosed.analytics.activetext",
    UI_ACTIVATED: "uielementactivated.analytics.activetext",
    OVERLAY_ACTIVATED: "overlayactivated.analytics.activetext",
    WIDGET_CLOSED: "widgetclosed.analytics.activetext"
}, /* global ActiveText */
ActiveText.TinCanAdaptor = function(tincan) {
    "use strict";
    function init(instance) {
        function teardown() {
            $(instance.options.containerElement).off("remove", teardown), $(instance).off(ActiveText.Analytics.Events.BOOK_OPENED, transformBookOpened), 
            $(instance).off(ActiveText.Analytics.Events.BOOK_CLOSED, transformBookClosed), $(instance).off(ActiveText.Analytics.Events.PAGE_VIEW, transformPageView), 
            $(instance).off(ActiveText.Analytics.Events.PAGE_EXIT, transformPageExit), $(instance).off(ActiveText.Analytics.Events.OVERLAY_ACTIVATED, transformOverlayActivated), 
            $(instance).off(ActiveText.Analytics.Events.WIDGET_CLOSED, transformWidgetClosed), 
            activeTextInstance = void 0;
        }
        return tincan ? void (instance && instance.options && instance.options.containerElement && ($(instance.options.containerElement).on("remove", teardown), 
        $(instance).on(ActiveText.Analytics.Events.BOOK_OPENED, transformBookOpened), $(instance).on(ActiveText.Analytics.Events.BOOK_CLOSED, transformBookClosed), 
        $(instance).on(ActiveText.Analytics.Events.PAGE_VIEW, transformPageView), $(instance).on(ActiveText.Analytics.Events.PAGE_EXIT, transformPageExit), 
        $(instance).on(ActiveText.Analytics.Events.OVERLAY_ACTIVATED, transformOverlayActivated), 
        $(instance).on(ActiveText.Analytics.Events.WIDGET_CLOSED, transformWidgetClosed), 
        activeTextInstance = instance)) : void debug.warn("Unable to start TinCanAdaptor because existing TinCan API Adaptor was not supplied.");
    }
    function transformBookOpened(event, data) {
        var meta = activeTextInstance.data.getMetaData(), statementData = {};
        if (data) {
            var bookTitle, isbn;
            meta && (bookTitle = meta.title, isbn = meta.identifier), statementData = {
                verb: {
                    id: "http://activitystrea.ms/schema/1.0/access",
                    display: {
                        "en-US": "accessed"
                    }
                },
                object: {
                    id: data.whichbook,
                    definition: {
                        name: bookTitle,
                        type: "book",
                        extensions: {
                            "http://id.tincanapi.com/extension/isbn": isbn,
                            "http://id.tincanapi.com/extension/browser-info": data.browser
                        }
                    }
                },
                context: {
                    platform: data.host,
                    extensions: {
                        "http://id.tincanapi.com/extension/browser-info": data.browser
                    }
                }
            };
        }
        tincan.sendStatement(statementData);
    }
    function transformBookClosed(event, data) {
        var meta = activeTextInstance.data.getMetaData(), statementData = {};
        if (data) {
            var bookTitle, isbn;
            meta && (bookTitle = meta.title, isbn = meta.identifier), statementData = {
                verb: {
                    id: "http://adlnet.gov/expapi/verbs/exited",
                    display: {
                        "en-US": "exited"
                    }
                },
                object: {
                    id: data.whichbook,
                    definition: {
                        name: bookTitle,
                        type: "book",
                        extensions: {
                            "http://id.tincanapi.com/extension/isbn": isbn,
                            "http://id.tincanapi.com/extension/browser-info": data.browser
                        }
                    }
                },
                context: {
                    platform: data.host,
                    extensions: {
                        "http://id.tincanapi.com/extension/browser-info": data.browser
                    }
                }
            };
        }
        tincan.sendStatement(statementData);
    }
    function transformPageView(event, data) {
        var meta = activeTextInstance.data.getMetaData(), statementData = {};
        if (data) {
            var bookTitle, isbn;
            meta && (bookTitle = meta.title, isbn = meta.identifier), statementData = {
                verb: {
                    id: "http://activitystrea.ms/schema/1.0/read",
                    display: {
                        "en-US": "read"
                    }
                },
                object: {
                    id: data.pageurl,
                    definition: {
                        name: data.pagetitle,
                        type: "page",
                        extensions: {
                            "http://id.tincanapi.com/extension/browser-info": data.browser
                        }
                    }
                },
                context: {
                    contextActivities: {
                        parent: {
                            id: data.whichbook,
                            definition: {
                                name: bookTitle,
                                type: "book",
                                extensions: {
                                    "http://id.tincanapi.com/extension/isbn": isbn,
                                    "http://id.tincanapi.com/extension/browser-info": data.browser
                                }
                            }
                        }
                    },
                    platform: data.host,
                    extensions: {
                        "http://id.tincanapi.com/extension/browser-info": data.browser
                    }
                }
            };
        }
        tincan.sendStatement(statementData);
    }
    function transformPageExit(event, data) {
        var meta = activeTextInstance.data.getMetaData(), statementData = {};
        if (data) {
            var bookTitle, isbn;
            meta && (bookTitle = meta.title, isbn = meta.identifier), statementData = {
                verb: {
                    id: "http://adlnet.gov/expapi/verbs/exited",
                    display: {
                        "en-US": "exited"
                    }
                },
                object: {
                    id: data.pageurl,
                    definition: {
                        name: data.pagetitle,
                        type: "page",
                        extensions: {
                            "http://id.tincanapi.com/extension/browser-info": data.browser
                        }
                    }
                },
                context: {
                    contextActivities: {
                        parent: {
                            id: data.whichbook,
                            definition: {
                                name: bookTitle,
                                type: "book",
                                extensions: {
                                    "http://id.tincanapi.com/extension/isbn": isbn,
                                    "http://id.tincanapi.com/extension/browser-info": data.browser
                                }
                            }
                        }
                    },
                    platform: data.host,
                    extensions: {
                        "http://id.tincanapi.com/extension/browser-info": data.browser
                    }
                }
            };
        }
        tincan.sendStatement(statementData);
    }
    function transformOverlayActivated(event, data) {
        var meta = activeTextInstance.data.getMetaData(), statementData = {};
        if (data) {
            var bookTitle, isbn;
            meta && (bookTitle = meta.title, isbn = meta.identifier), statementData = {
                verb: {
                    id: "http://adlnet.gov/expapi/verbs/launched",
                    display: {
                        "en-US": "launched"
                    }
                },
                object: {
                    id: data.uridata,
                    definition: {
                        name: data.title,
                        type: "application"
                    }
                },
                context: {
                    contextActivities: {
                        parent: {
                            id: data.whichbook,
                            definition: {
                                name: bookTitle,
                                type: "book",
                                extensions: {
                                    "http://id.tincanapi.com/extension/isbn": isbn,
                                    "http://id.tincanapi.com/extension/browser-info": data.browser
                                }
                            }
                        }
                    },
                    platform: data.host,
                    extensions: {
                        "http://id.tincanapi.com/extension/browser-info": data.browser
                    }
                }
            };
        }
        tincan.sendStatement(statementData);
    }
    function transformWidgetClosed(event, data) {
        var meta = activeTextInstance.data.getMetaData(), statementData = {};
        if (data) {
            var bookTitle, isbn;
            meta && (bookTitle = meta.title, isbn = meta.identifier), statementData = {
                verb: {
                    id: "http://adlnet.gov/expapi/verbs/exited",
                    display: {
                        "en-US": "exited"
                    }
                },
                object: {
                    id: data.uridata,
                    definition: {
                        name: data.title,
                        type: "application"
                    }
                },
                context: {
                    contextActivities: {
                        parent: {
                            id: data.whichbook,
                            definition: {
                                name: bookTitle,
                                type: "book",
                                extensions: {
                                    "http://id.tincanapi.com/extension/isbn": isbn,
                                    "http://id.tincanapi.com/extension/browser-info": data.browser
                                }
                            }
                        }
                    },
                    platform: data.host,
                    extensions: {
                        "http://id.tincanapi.com/extension/browser-info": data.browser
                    }
                }
            };
        }
        tincan.sendStatement(statementData);
    }
    var activeTextInstance;
    return {
        init: init,
        key: "tincan"
    };
}, /* global ActiveText */
ActiveText.Controls = ActiveText.Controls || {}, ActiveText.Controls.TooltipHelper = function() {
    "use strict";
    function fixTooltipPosition() {
        var container = $(".activetext");
        $(".tooltip").each(function() {
            if ($(this).length && container.length) {
                var marginString, difference = container.offset().left + container.width() - ($(this).offset().left + $(this).width());
                0 > difference && (difference -= 10, marginString = ActiveText.BrowserUtils.isOldVersionOfInternetExplorer ? "0 " + -difference + "px 0 0" : "0 " + -difference + "px 0 " + difference + "px"), 
                difference = $(this).offset().left - container.offset().left, 0 > difference && (difference -= 10, 
                marginString = ActiveText.BrowserUtils.isOldVersionOfInternetExplorer ? "0 0 0 " + -difference + "px" : "0 " + difference + "px 0 " + -difference + "px"), 
                $(this).find(".tooltip-inner").css("margin", marginString);
            }
        });
    }
    function resetTooltipPositionFixes() {
        var tooltip = $(".tooltip");
        tooltip.find(".tooltip-inner").css("margin", "");
    }
    return {
        fixTooltipPosition: fixTooltipPosition,
        resetTooltipPositionFixes: resetTooltipPositionFixes
    };
}(), /* global ActiveText */
ActiveText.Controls = ActiveText.Controls || {}, ActiveText.Controls.ButtonHelper = function() {
    "use strict";
    function mouseOver(event) {
        /*jshint validthis:true */
        var button = $(event.currentTarget), styleOptions = button.data("hoverStyles"), hoverImageSrc = button.data("hoverImageSrc"), toggleButtonHoverImageSrc = button.data("toggleButtonHoverImageSrc");
        button.data("disabled") || (button.data("selected") === !0 ? $(this).find("img").attr("src", toggleButtonHoverImageSrc) : $(this).find("img").attr("src", hoverImageSrc)), 
        styleOptions && $(this).css(styleOptions), $(button).attr("has-tooltip") && ($(button).tooltip("hide").tooltip("show"), 
        ActiveText.Controls.TooltipHelper.fixTooltipPosition());
    }
    function mouseOut(event) {
        /*jshint validthis:true */
        var button = $(event.currentTarget), styleOptions = button.data("styles"), imageSrc = button.data("imageSrc"), toggleButtonImageSrc = button.data("toggleButtonImageSrc");
        button.removeClass("selected"), "blur" !== event.type && button.blur(), button.data("disabled") || (button.data("selected") === !0 ? button.find("img").attr("src", toggleButtonImageSrc) : button.find("img").attr("src", imageSrc)), 
        styleOptions && button.css(styleOptions), $(button).attr("has-tooltip") && (ActiveText.Controls.TooltipHelper.resetTooltipPositionFixes(), 
        $(button).tooltip("hide"));
    }
    function mouseDown(event) {
        /*jshint validthis:true */
        var button = $(event.currentTarget), downImageSrc = button.data("downImageSrc"), toggleButtonDownImageSrc = button.data("toggleButtonDownImageSrc");
        button.addClass("selected"), button.data("disabled") || (toggleButtonDownImageSrc && button.data("selected") === !0 ? button.find("img").attr("src", toggleButtonDownImageSrc) : button.find("img").attr("src", downImageSrc));
    }
    function setDisabled($this) {
        $this.blur().data("disabled", !0), $this.attr({
            "aria-disabled": !0
        });
    }
    function setEnabled($this) {
        $this.data("disabled", !1), $this.attr({
            "aria-disabled": !1
        });
    }
    function setDisabledImage($this) {
        var disabledImageSrc = $this.data("disabledImageSrc");
        $this.find("img").attr("src", disabledImageSrc);
    }
    function setUpImage($this) {
        if ($this.data("selected") === !0) {
            var toggleButtonImageSrc = $this.data("toggleButtonImageSrc");
            $this.find("img").attr("src", toggleButtonImageSrc);
        } else {
            var imageSrc = $this.data("imageSrc");
            $this.find("img").attr("src", imageSrc);
        }
    }
    function fadeDisable() {
        /* jshint validthis:true */
        var $this = $(this);
        $this.css({
            cursor: "pointer"
        }), setDisabled($this), $this.stop(!0, !0).fadeTo(500, .5);
    }
    function fadeEnable() {
        /* jshint validthis:true */
        var $this = $(this);
        $this.css({
            cursor: "pointer"
        }), setEnabled($this), $(this).stop(!0, !0).fadeTo(500, 1);
    }
    function basicDisable() {
        /* jshint validthis:true */
        var $this = $(this);
        $this.css({
            cursor: "not-allowed"
        }), setDisabledImage($this), setDisabled($this);
    }
    function basicEnable() {
        /* jshint validthis:true */
        var $this = $(this);
        $this.css({
            cursor: "pointer"
        }), setUpImage($this), setEnabled($this);
    }
    function hideDisable() {
        /* jshint validthis:true */
        var $this = $(this);
        $this.css({
            visibility: "hidden"
        }), setDisabled($this);
    }
    function showEnable() {
        /* jshint validthis:true */
        var $this = $(this);
        $this.css({
            visibility: "visible"
        }), setEnabled($this);
    }
    function focusAction() {
        /* jshint validthis:true */
        $(this).attr("has-tooltip") && (//            $(this).tooltip('hide').tooltip('show');
        $(this).tooltip("show"), ActiveText.Controls.TooltipHelper.fixTooltipPosition()), 
        mouseOver.apply(this, arguments);
    }
    function blurAction() {
        /* jshint validthis:true */
        $(this).attr("has-tooltip") && (ActiveText.Controls.TooltipHelper.resetTooltipPositionFixes(), 
        $(this).tooltip("hide")), mouseOut.apply(this, arguments);
    }
    function accessibleClick(event) {
        /* jshint validthis:true */
        var keycode = event.keyCode ? event.keyCode : event.which;
        keycode === ActiveText.Keymap.ENTER && $(this).click();
    }
    function getAccessKeyHTMLFor(title, accesskey) {
        var rtn = title;
        if (title && accesskey) {
            var i = title.indexOf(accesskey);
            -1 !== title.indexOf(accesskey) && (rtn = title.slice(0, i) + "<u>" + accesskey + "</u>" + title.slice(i + 1));
        }
        return rtn;
    }
    return {
        mouseOver: mouseOver,
        mouseOut: mouseOut,
        mouseDown: mouseDown,
        fadeEnable: fadeEnable,
        fadeDisable: fadeDisable,
        basicDisable: basicDisable,
        basicEnable: basicEnable,
        hideDisable: hideDisable,
        showEnable: showEnable,
        focusAction: focusAction,
        blurAction: blurAction,
        accessibleClick: accessibleClick,
        getAccessKeyHTMLFor: getAccessKeyHTMLFor
    };
}(), /* global ActiveText */
ActiveText.UI = ActiveText.UI || {}, ActiveText.UI.BasicControls = ActiveText.UI.BasicControls || {}, 
/**
 * @class SimpleButtonFactory
 * @memberOf ActiveText.UI.BasicControls
 * @type {{createSimpleButton:create}}
 */
ActiveText.UI.BasicControls.SimpleButtonFactory = function() {
    "use strict";
    function getButtonInner(configuration) {
        var rtn, isImageButton = Boolean(void 0 !== configuration.imageSrc);
        if (isImageButton) {
            var imageSrc = configuration.imageSrc;
            rtn = configuration.width && configuration.height ? "<img src='" + imageSrc + "' width='" + configuration.width + "' height='" + configuration.height + "' />" : "<img src='" + imageSrc + "' />";
        } else if (configuration.svgData) rtn = configuration.svgData; else {
            var icon = configuration.icon || configuration.icon_off;
            rtn = icon ? "<i class='button " + icon + "'></i>" : "<span>" + configuration.title + "</span>";
        }
        return rtn;
    }
    function create(configKeys, options) {
        function teardown() {
            newElement.off({
                mouseover: ActiveText.Controls.ButtonHelper.mouseOver,
                focus: ActiveText.Controls.ButtonHelper.focusAction,
                blur: ActiveText.Controls.ButtonHelper.blurAction,
                mouseout: ActiveText.Controls.ButtonHelper.mouseOut,
                mousedown: ActiveText.Controls.ButtonHelper.mouseDown,
                touchstart: ActiveText.Controls.ButtonHelper.mouseDown,
                touchend: ActiveText.Controls.ButtonHelper.mouseOut,
                touchcancel: ActiveText.Controls.ButtonHelper.mouseOut,
                remove: teardown,
                keyup: ActiveText.Controls.ButtonHelper.accessibleClick
            }), $(window).off({
                keydown: onKeyDown,
                keyup: onKeyUp
            });
        }
        function onKeyDown(e) {
            e.keyCode === buttonOptions.keyCode && $(newElement).mousedown();
        }
        function onKeyUp(e) {
            e.keyCode === buttonOptions.keyCode && $(newElement).mouseout();
        }
        function setupEnableDisableFunctions(buttonOptions, newElement) {
            switch (buttonOptions.enableBehaviour) {
              case "show":
                newElement.disable = ActiveText.Controls.ButtonHelper.basicDisable, newElement.enable = ActiveText.Controls.ButtonHelper.basicEnable;
                break;

              case "hide":
                newElement.disable = ActiveText.Controls.ButtonHelper.hideDisable, newElement.enable = ActiveText.Controls.ButtonHelper.showEnable;
                break;

              default:
                newElement.disable = ActiveText.Controls.ButtonHelper.fadeDisable, newElement.enable = ActiveText.Controls.ButtonHelper.fadeEnable;
            }
        }
        function setupKeyboardIntegration(buttonOptions) {
            void 0 !== buttonOptions.keyCode && $(window).keydown(onKeyDown).keyup(onKeyUp);
        }
        var buttonOptions = $.extend({}, options, configKeys);
        options && (buttonOptions = $.extend(buttonOptions, options.options));
        var newElement, buttonStyles = $.extend({}, buttonOptions, buttonOptions.styles, buttonOptions.style), buttonHoverStyles = $.extend({}, buttonOptions, buttonOptions.hoverStyles, buttonOptions.hoverStyle), elementContentStr = getButtonInner(buttonStyles), imageSrc = buttonOptions.imageSrc, downImageSrc = buttonOptions.downImageSrc, hoverImageSrc = buttonOptions.hoverImageSrc, disabledImageSrc = buttonOptions.disabledImageSrc, toggleButtonImageSrc = buttonOptions.toggleButtonImageSrc, toggleButtonDownImageSrc = buttonOptions.toggleButtonDownImageSrc, toggleButtonHoverImageSrc = buttonOptions.toggleButtonHoverImageSrc, barClass = "activetext-default";
        buttonOptions && buttonOptions.styles && buttonOptions.styles.barClass && (barClass = buttonOptions.styles.barClass), 
        newElement = $(imageSrc ? "<a class='button'></a>" : "<a class='" + barClass + " button'></a>");
        var buttonContents = $(elementContentStr).attr("role", "presentation");
        newElement.html(buttonContents), newElement.attr("data-original-title", configKeys.title), 
        configKeys.className && newElement.addClass(configKeys.className), newElement.css({
            borderRadius: buttonStyles && buttonStyles.height ? buttonStyles.height / 2 : "22px",
            cursor: "pointer",
            WebkitTouchCallout: "none",
            WebkitTapHighlightColor: "rgba(0,0,0,0)",
            outline: "none",
            display: "inline-block"
        }), buttonOptions.styles && newElement.css(buttonOptions.styles), buttonStyles.closeFunction = void 0, 
        newElement.data("styles", buttonStyles), buttonHoverStyles.closeFunction = void 0, 
        newElement.data("hover-styles", buttonHoverStyles);
        var toggleStyles = $.extend({}, buttonOptions.toggleStyles, buttonOptions.toggleStyle);
        toggleStyles.closeFunction = void 0, newElement.data("toggle-styles", toggleStyles);
        var toggleHoverStyles = $.extend({}, buttonOptions.toggleHoverStyles, buttonOptions.toggleHoverStyle);
        return toggleHoverStyles.closeFunction = void 0, newElement.data("toggle-hover-styles", toggleHoverStyles), 
        newElement.data("imageSrc", imageSrc), newElement.data("downImageSrc", downImageSrc), 
        newElement.data("hoverImageSrc", hoverImageSrc), newElement.data("toggleButtonImageSrc", toggleButtonImageSrc), 
        newElement.data("toggleButtonDownImageSrc", toggleButtonDownImageSrc), newElement.data("toggleButtonHoverImageSrc", toggleButtonHoverImageSrc), 
        newElement.data("disabledImageSrc", disabledImageSrc), newElement.on({
            mouseover: ActiveText.Controls.ButtonHelper.mouseOver,
            focus: ActiveText.Controls.ButtonHelper.focusAction,
            blur: ActiveText.Controls.ButtonHelper.blurAction,
            mouseout: ActiveText.Controls.ButtonHelper.mouseOut,
            mousedown: ActiveText.Controls.ButtonHelper.mouseDown,
            touchstart: ActiveText.Controls.ButtonHelper.mouseDown,
            touchend: ActiveText.Controls.ButtonHelper.mouseOut,
            touchcancel: ActiveText.Controls.ButtonHelper.mouseOut,
            remove: teardown,
            keyup: ActiveText.Controls.ButtonHelper.accessibleClick
        }), newElement.attr({
            role: "button",
            title: configKeys.title,
            "data-original-title": ActiveText.Controls.ButtonHelper.getAccessKeyHTMLFor(configKeys.title, configKeys.accesskey),
            "aria-label": configKeys.title,
            accesskey: configKeys.accesskey
        }), (void 0 === buttonStyles.tooltips || buttonStyles.tooltips) && (newElement.attr("has-tooltip", !0), 
        newElement.tooltip({
            html: !0,
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
        })), newElement.trigger("mouseout"), setupEnableDisableFunctions(buttonOptions, newElement), 
        setupKeyboardIntegration(buttonOptions), newElement;
    }
    return {
        createSimpleButton: create
    };
}(), /* global ActiveText */
ActiveText.UI = ActiveText.UI || {}, ActiveText.UI.BasicControls = ActiveText.UI.BasicControls || {}, 
/**
 * @class ToggleButtonFactory
 * @memberOf ActiveText.UI.BasicControls
 * @type {{createToggleButton:createToggleButton}}
 */
ActiveText.UI.BasicControls.ToggleButtonFactory = function() {
    "use strict";
    function getButtonInner(configuration, toggle) {
        var rtn, isImageButton = Boolean(void 0 !== configuration.imageSrc);
        if (isImageButton) {
            var imageSrc = configuration.imageSrc;
            toggle && (imageSrc = configuration.toggleButtonImageSrc), rtn = configuration.width && configuration.height ? '<img src="' + imageSrc + '" width="' + configuration.width + '" height="' + configuration.height + '" />' : '<img src="' + imageSrc + '" />';
        } else if (configuration.svgData) rtn = configuration.svgData; else {
            var icon = configuration.icon || configuration.icon_off;
            toggle && (icon = configuration.icon_on || configuration.icon_off || configuration.icon), 
            icon || (icon = "icon-undefined"), rtn = '<i class="button ' + icon + '"></i>';
        }
        return rtn;
    }
    /**
     * @param configKeys {{title:string, title_off:string, title_on:string, icon_on:string, icon_off:string, svgData:string, className:string}}
     * @param options
     * @returns {*}
     */
    function createToggleButton(configKeys, options) {
        var simpleButton = ActiveText.UI.BasicControls.SimpleButtonFactory.createSimpleButton(configKeys, options);
        return simpleButton.toggle_button = function(value) {
            var buttonOptions = $.extend({}, configKeys, options);
            options && options.options && (buttonOptions = $.extend(buttonOptions, options.options));
            var mergedStyles = $.extend({}, buttonOptions, buttonOptions.styles, buttonOptions.style), elementContentStr = getButtonInner(mergedStyles, value), buttonContents = $(elementContentStr).attr("role", "presentation");
            simpleButton.html(buttonContents).data("selected", value);
            var titleCodeRaw, titleCode;
            value ? (titleCodeRaw = configKeys.title_off || configKeys.title, simpleButton.attr({
                "aria-label": titleCodeRaw
            }), titleCode = ActiveText.Controls.ButtonHelper.getAccessKeyHTMLFor(titleCodeRaw, configKeys.accesskey), 
            simpleButton.attr("data-original-title", titleCode).attr("title", titleCodeRaw), 
            simpleButton.addClass("active")) : (titleCodeRaw = configKeys.title_on || configKeys.title, 
            simpleButton.attr({
                "aria-label": titleCodeRaw
            }), titleCode = ActiveText.Controls.ButtonHelper.getAccessKeyHTMLFor(titleCodeRaw, configKeys.accesskey), 
            simpleButton.attr("data-original-title", titleCode).attr("title", titleCodeRaw), 
            simpleButton.removeClass("active")), simpleButton.attr("aria-pressed", value), simpleButton.attr("has-tooltip") && simpleButton.tooltip("hide");
        }, simpleButton.toggle_state = function() {
            return simpleButton.data("selected");
        }, simpleButton.toggle_button(!1), simpleButton.trigger("mouseout"), simpleButton;
    }
    return {
        createToggleButton: createToggleButton
    };
}(), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        var factory = ActiveText.UI.BasicControls.ToggleButtonFactory, newElement = factory.createToggleButton(DEFAULT_BUTTON_SETTINGS, options);
        newElement.click(function() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            });
        });
        var width, popupController = new ActiveText.UI.StructurePopup();
        options && options.options && options.options.popupnavwidth && (width = options.options.popupnavwidth), 
        popupController.init(activeTextInstance, $(newElement), void 0, width);
        var container = $('<div class="contents-container control"></div>').css({
            display: "inline-block",
            position: "relative",
            width: newElement.outerWidth()
        });
        return container.append(newElement), container;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "contents", DEFAULT_BUTTON_SETTINGS = {
        title: "Contents",
        className: KEY,
        icon: "icon-list-ul",
        accesskey: "C"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText, Modernizr */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function supported() {
        return Modernizr.canvas;
    }
    function create(activeTextInstance, options) {
        function toggleControlsVisibility() {
            var isOpen = $(newElement).data("isopen");
            isOpen === !0 ? ($(newElement).data("isopen", !1), newElement.toggle_button(!1), 
            toolPanel.hideToolPanel()) : ($(newElement).data("isopen", !0), newElement.toggle_button(!0), 
            toolPanel.showToolPanel());
        }
        var factory = ActiveText.UI.BasicControls.ToggleButtonFactory, newElement = factory.createToggleButton(DEFAULT_BUTTON_STYLES, options);
        newElement.click(function() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            });
        });
        var toolPanel = new ActiveText.UI.DrawingToolsPanel();
        return toolPanel.init({
            activeTextInstance: activeTextInstance
        }), newElement.on("click tap", toggleControlsVisibility), $(newElement).data("isopen", !1), 
        newElement.toggle_button(!1), newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "drawing", DEFAULT_BUTTON_STYLES = {
        title: "Drawing Tools",
        icon: "icon-pencil",
        className: KEY,
        accesskey: "D"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create,
        supported: supported
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        function buttonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            }), //                if(confirm('Are you sure you want to close this window?'))
            //                {
            //                debug.log('Attempting to close the current window. If you can read this message, it failed.');
            window.open("", "_self", ""), window.close();
        }
        var factory = ActiveText.UI.BasicControls.SimpleButtonFactory, newElement = factory.createSimpleButton(DEFAULT_BUTTON_SETTINGS, options), hasCloseFunction = options && options.options && options.options.closeFunction && "function" == typeof options.options.closeFunction;
        return newElement.on(hasCloseFunction ? {
            click: options.options.closeFunction
        } : {
            click: buttonClickHandler
        }), newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "exit", DEFAULT_BUTTON_SETTINGS = {
        title: "Close eBook",
        icon: "icon-remove",
        className: KEY,
        accesskey: "B"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        function buttonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            });
            var extension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "controls");
            return extension.hideControls(), !1;
        }
        var factory = ActiveText.UI.BasicControls.SimpleButtonFactory, newElement = factory.createSimpleButton(DEFAULT_BUTTON_SETTINGS, options);
        return newElement.on({
            click: buttonClickHandler
        }), newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "minimise", DEFAULT_BUTTON_SETTINGS = {
        title: "Hide Controls",
        icon: "icon-angle-down",
        className: KEY,
        accesskey: "M"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        function buttonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            });
            var enabled = activeTextInstance.navigation.canGoToNextPage();
            return enabled && activeTextInstance.navigation.gotoNextPage(), !1;
        }
        function updateButtonState() {
            var enabled = activeTextInstance.navigation.canGoToNextPage();
            enabled ? newElement.enable() : newElement.disable();
        }
        var newElement = ActiveText.UI.BasicControls.SimpleButtonFactory.createSimpleButton(DEFAULT_BUTTON_STYLES, options);
        return newElement.on({
            click: buttonClickHandler
        }), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, updateButtonState), 
        newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "next", DEFAULT_BUTTON_STYLES = {
        title: "Next Page",
        icon: "icon-caret-right",
        className: KEY,
        keyCode: 39,
        accesskey: "N"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param options {object}
     * @return {object}
     */
    function create(activeTextInstance, options) {
        function buttonClickHandler() {
            if ($(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            }), notesController) {
                var newNote = noteFactory.renderNoteFromData({
                    point: [ 66, 32 ],
                    relativePoint: [ .1, .1 ],
                    text: "this is my note"
                }), convertedIndex = activeTextInstance.model.getCurrentIndex(), overlayWrapperElement = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, convertedIndex, "annotations");
                overlayWrapperElement.append(newNote);
            }
            return !1;
        }
        function teardown() {
            newElement.off({
                click: buttonClickHandler,
                remove: teardown
            }), notesController = void 0, factory = void 0;
        }
        var notesController = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "notes"), factory = ActiveText.UI.BasicControls.SimpleButtonFactory, newElement = factory.createSimpleButton(DEFAULT_BUTTON_STYLES, options), noteFactory = new ActiveText.NoteFactory(activeTextInstance);
        return newElement.on({
            click: buttonClickHandler,
            remove: teardown
        }), newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "note", DEFAULT_BUTTON_STYLES = {
        title: "Annotations",
        icon: "icon-file",
        className: KEY,
        accesskey: "A"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param options {object}
     * @returns {jQuery}
     */
    function create(activeTextInstance, options) {
        function buttonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            }), recordAndPlayExtension.togglePlay();
        }
        function updateButtonState(event) {
            newElement.toggle_button("play" === event.type || "resume" === event.type ? !0 : !1);
        }
        function enableButton() {
            newElement.enable();
        }
        function attachEventListeners(buttonElement) {
            buttonElement.on("click", buttonClickHandler), $(activeTextInstance).on("play pause resume finish", updateButtonState), 
            $(activeTextInstance).on("stop", enableButton);
        }
        /**
         * @type {ActiveText.RecordAndPlay}
         */
        var recordAndPlayExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "recordandplay"), factory = ActiveText.UI.BasicControls.ToggleButtonFactory, newElement = factory.createToggleButton(DEFAULT_BUTTON_STYLES, options);
        return recordAndPlayExtension && attachEventListeners(newElement), recordAndPlayExtension && recordAndPlayExtension.hasRecorded() && recordAndPlayExtension.hasFlash() || newElement.disable(), 
        newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "play", DEFAULT_BUTTON_STYLES = {
        title: "Play",
        icon: "icon-play",
        className: KEY,
        accesskey: "L"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        function buttonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            });
            var enabled = activeTextInstance.navigation.canGoToPreviousPage();
            return enabled && activeTextInstance.navigation.gotoPrevPage(), !1;
        }
        function updateButtonState() {
            var enabled = activeTextInstance.navigation.canGoToPreviousPage();
            enabled ? newElement.enable() : newElement.disable();
        }
        var newElement = ActiveText.UI.BasicControls.SimpleButtonFactory.createSimpleButton(DEFAULT_BUTTON_STYLES, options);
        return newElement.on({
            click: buttonClickHandler
        }), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, updateButtonState), 
        newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "previous", DEFAULT_BUTTON_STYLES = {
        title: "Previous Page",
        icon: "icon-caret-left",
        className: KEY,
        keyCode: 37,
        accesskey: "P"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText, Modernizr */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    //function to separate text from quickNav text box:
    // eg:
    // Expects similar to: 'page 1' and should return 1 for changePage to navigate to page 1
    function getQuickNavPageNumber(quickNavText) {
        for (var separatedString = quickNavText.replace(/\s+/g, "").split(/\D+/), pages = [], pagescount = 0, i = 0; i < separatedString.length; i++) isNaN(parseInt(separatedString[i], 10)) || (pages[pagescount] = separatedString[i], 
        pagescount++);
        return pages[0];
    }
    function create(activeTextInstance, options) {
        function changePageOnEnterKey(event) {
            event.which === ENTER_KEY && (changePage(), newElement.blur()), resizeInput.apply(newElement);
        }
        function getQuickNavPageText(quickNavText) {
            for (var flatNavigation = activeTextInstance.data.getFlatListOfNavigation(), quickNavTextLower = quickNavText.toLowerCase().replace(/\s+/g, "").replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g, ""), i = 0; i < flatNavigation.length; i++) if (flatNavigation[i].title) {
                var title = flatNavigation[i].title.toLowerCase().replace(/\s+/g, "").replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g, "");
                if (title === quickNavTextLower) return i;
            }
            return !1;
        }
        function changePage() {
            var quickNavText = newElement.val(), pageToNav = getQuickNavPageText(quickNavText);
            pageToNav = pageToNav ? ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, getQuickNavPageText(quickNavText)) : getQuickNavPageNumber(quickNavText), 
            activeTextInstance.navigation.gotoPage(pageToNav);
        }
        function updateDisplay() {
            var pageNumber = activeTextInstance.model.getCurrentPageNumber(), stringToDisplay = ActiveText.FormattingUtils.formatPageLabel(activeTextInstance, singlePageFormat, multiPageFormat, pageNumber);
            newElement.val(stringToDisplay), container.find(".max-page-number").text(ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, ActiveText.NavigationUtils.getMaximumValidPageIndex(activeTextInstance))), 
            newElement.attr({
                "aria-valuemax": ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, ActiveText.NavigationUtils.getMaximumValidPageIndex(activeTextInstance)),
                "aria-valuemin": ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, ActiveText.NavigationUtils.getMinimumValidPageIndex(activeTextInstance)),
                "aria-valuenow": activeTextInstance.model.getCurrentPageNumber(),
                "aria-valuetext": stringToDisplay
            }), resizeInput.apply(newElement);
        }
        function clearInput() {
            newElement.val("");
        }
        function resizeInput() {
            /* jshint validthis:true */
            var length = $(this).val().length;
            1 > length ? length = 1 : length > 19 && (length = 20), $(this).attr("size", length);
        }
        var singlePageFormat;
        singlePageFormat = options.options && options.options.textFormatSinglePage ? options.options.textFormatSinglePage : DEFAULT_SINGLE_PAGE_FORMAT;
        var multiPageFormat;
        multiPageFormat = options.options && options.options.textFormatMultiPage ? options.options.textFormatMultiPage : DEFAULT_MULTI_PAGE_FORMAT;
        var newElement = $('<input type="text" aria-live="polite" aria-label="Page Number" accesskey="N" />');
        Modernizr.touch && newElement.focus(clearInput), newElement.blur(updateDisplay), 
        newElement.click(clearInput), newElement.keyup(changePageOnEnterKey);
        var container = $('<div class="quicknav control" style="display:inline-block;position:relative;width:auto"> of <span class="max-page-number">0</span></div>').prepend(newElement);
        return container.css({
            verticalAlign: "top",
            padding: "0 1em"
        }), options.options && options.options.style && options.options.style.background && (container.css("background", options.options.style.background), 
        container.css("background-position", "center")), options.options && options.options.style && container.css(options.options.style), 
        resizeInput.apply(newElement), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, updateDisplay), 
        $(activeTextInstance).on(ActiveText.Events.RESIZE, updateDisplay), $(activeTextInstance).on(ActiveText.Events.BOOK_STRUCTURE_LOADED, updateDisplay), 
        container;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "pagenumber", ENTER_KEY = 13, DEFAULT_SINGLE_PAGE_FORMAT = "%%1", DEFAULT_MULTI_PAGE_FORMAT = "%%1  %%2";
    /**
     * @type {{create: Function, test: {getQuickNavPageNumber: Function}}}
     */
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create,
        test: {
            getQuickNavPageNumber: getQuickNavPageNumber
        }
    };
}(ActiveText), /* global ActiveText, Modernizr */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    //function to separate text from quickNav text box:
    // eg:
    // Expects similar to: 'page 1' and should return 1 for changePage to navigate to page 1
    function getQuickNavPageNumber(quickNavText) {
        for (var separatedString = quickNavText.replace(/\s+/g, "").split(/\D+/), pages = [], pagescount = 0, i = 0; i < separatedString.length; i++) isNaN(parseInt(separatedString[i], 10)) || (pages[pagescount] = separatedString[i], 
        pagescount++);
        return pages[0];
    }
    function create(activeTextInstance, options) {
        function changePageOnEnterKey(event) {
            event.which === ENTER_KEY && (changePage(), newElement.blur()), resizeInput.apply(newElement);
        }
        function getQuickNavPageText(quickNavText) {
            for (var flatNavigation = activeTextInstance.data.getFlatListOfNavigation(), quickNavTextLower = quickNavText.toLowerCase().replace(/\s+/g, "").replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g, ""), i = 0; i < flatNavigation.length; i++) {
                var title = flatNavigation[i].title.toLowerCase().replace(/\s+/g, "").replace(/[\.,-\/#!$%\^&\*;:{}=\-_`~()]/g, "");
                if (title === quickNavTextLower) return i;
            }
            return !1;
        }
        function changePage() {
            var quickNavText = newElement.val(), pageToNav = getQuickNavPageText(quickNavText);
            pageToNav = pageToNav ? ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, getQuickNavPageText(quickNavText)) : getQuickNavPageNumber(quickNavText), 
            activeTextInstance.navigation.gotoPage(pageToNav);
        }
        function updateDisplay() {
            var pageNumber = activeTextInstance.model.getCurrentPageNumber(), stringToDisplay = ActiveText.FormattingUtils.formatPageLabel(activeTextInstance, singlePageFormat, multiPageFormat, pageNumber);
            newElement.val(stringToDisplay), newElement.attr({
                "aria-valuemax": ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, ActiveText.NavigationUtils.getMaximumValidPageIndex(activeTextInstance)),
                "aria-valuemin": ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, ActiveText.NavigationUtils.getMinimumValidPageIndex(activeTextInstance)),
                "aria-valuenow": activeTextInstance.model.getCurrentPageNumber(),
                "aria-valuetext": stringToDisplay
            }), resizeInput.apply(newElement);
        }
        function clearInput() {
            newElement.val("");
        }
        function resizeInput() {
            /* jshint validthis:true */
            var length = $(this).val().length;
            10 > length ? length = 10 : length > 19 && (length = 20), $(this).attr("size", length);
        }
        var singlePageFormat;
        singlePageFormat = options.options && options.options.textFormatSinglePage ? options.options.textFormatSinglePage : DEFAULT_SINGLE_PAGE_FORMAT;
        var multiPageFormat;
        multiPageFormat = options.options && options.options.textFormatMultiPage ? options.options.textFormatMultiPage : DEFAULT_MULTI_PAGE_FORMAT;
        var newElement = $('<input type="text" aria-live="polite" aria-label="Quick Navigation" accesskey="N" />').css({
            width: 140,
            borderRadius: "25px",
            fontSize: 16,
            padding: "6px 12px",
            verticalAlign: "middle",
            border: "4px solid",
            outline: "none",
            fontWeight: "bold",
            textAlign: "center",
            textOverflow: "ellipsis"
        });
        options.options && options.options.style && newElement.css(options.options.style), 
        Modernizr.touch && newElement.focus(clearInput), newElement.blur(updateDisplay), 
        newElement.click(clearInput), newElement.keyup(changePageOnEnterKey);
        var container = $('<div class="quicknav" style="display:inline-block;position:relative;width:auto"></div>').append(newElement);
        return options.options && options.options.style && options.options.style.background && (container.css("background", options.options.style.background), 
        container.css("background-position", "center")), resizeInput.apply(newElement), 
        $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, updateDisplay), $(activeTextInstance).on(ActiveText.Events.RESIZE, updateDisplay), 
        $(activeTextInstance).on(ActiveText.Events.BOOK_STRUCTURE_LOADED, updateDisplay), 
        container;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "quicknav", ENTER_KEY = 13, DEFAULT_SINGLE_PAGE_FORMAT = "Page %%1 of %%2", DEFAULT_MULTI_PAGE_FORMAT = "Pages %%1%%2 of %%3";
    /**
     * @type {{create: Function, test: {getQuickNavPageNumber: Function}}}
     */
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create,
        test: {
            getQuickNavPageNumber: getQuickNavPageNumber
        }
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        var width, parentClass = ActiveText.UI.BasicControls.AvailableControls.quicknav, baseObject = parentClass.create(activeTextInstance, options), newElement = baseObject.get().firstChild, popupController = new ActiveText.UI.StructurePopup();
        return options && options.options && options.options.popupnavwidth && (width = options.options.popupnavwidth), 
        popupController.init(activeTextInstance, $(newElement), void 0, width), baseObject;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "quicknav-popup";
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param options {object}
     * @returns {jQuery}
     */
    function create(activeTextInstance, options) {
        function buttonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            }), readToMeExtension.getState().playing() ? readToMeExtension.pause() && newElement.toggle_button(!1) : readToMeExtension.play() && newElement.toggle_button(!0);
        }
        function updateButtonState(event) {
            newElement.toggle_button("onplay" === event.type || "onresume" === event.type ? !0 : !1);
        }
        function hasMediaOverlayForDPSByIndex(pageIndex) {
            for (var currentPage, hasAudio = !1, smilLoader = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildataloader"), i = 0, l = activeTextInstance.view.model.getDisplayedPages(); l > i; i++) currentPage = pageIndex + i, 
            smilLoader && smilLoader.hasSMILForPage(currentPage) && (hasAudio = !0);
            return hasAudio;
        }
        function onPageChange(event, data) {
            var hasAudio, isDPSView = 2 === activeTextInstance.view.model.getDisplayedPages(), leftPageIndex = ActiveText.NavigationUtils.calculateLeftmostPageIndexFromIndex(activeTextInstance, data.toPage), pageIndex = leftPageIndex;
            isDPSView === !1 && leftPageIndex !== data.toPage && (pageIndex = data.toPage), 
            newElement.toggle_button(!1), hasAudio = hasMediaOverlayForDPSByIndex(pageIndex), 
            hasAudio ? newElement.enable() : newElement.disable();
        }
        function attachEventListeners(buttonElement) {
            buttonElement.on({
                click: buttonClickHandler
            }), $(readToMeExtension).on({
                onplay: updateButtonState,
                onresume: updateButtonState,
                onpause: updateButtonState,
                onfinish: updateButtonState
            }), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, onPageChange);
        }
        function attachReadToMeExtension() {
            readToMeExtension = new ActiveText.ReadToMe(), readToMeExtension.init(activeTextInstance), 
            activeTextInstance.extensions.push(readToMeExtension);
        }
        /**
         * @type {ActiveText.ReadToMe}
         */
        var readToMeExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "readtome");
        readToMeExtension || "function" != typeof ActiveText.ReadToMe || attachReadToMeExtension();
        var factory = ActiveText.UI.BasicControls.ToggleButtonFactory, newElement = factory.createToggleButton(DEFAULT_BUTTON_STYLES, options);
        return readToMeExtension ? attachEventListeners(newElement) : newElement.disable(), 
        newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "readtome", DEFAULT_BUTTON_STYLES = {
        title: "Read to Me",
        icon: "icon-volume-up",
        className: KEY,
        accesskey: "R"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param options {object}
     * @returns {jQuery}
     */
    function create(activeTextInstance, options) {
        function doneButtonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            });
            var rtn = !1;
            return doneButton.toggle_state() === !0 && (doneButton.toggle_button(!1), readToMeExtension.skip(), 
            readToMeExtension.play(), rtn = !0), rtn;
        }
        function readToMeButtonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            }), readToMeExtension.getState().playing() ? readToMeExtension.pause() && readToMeButton.toggle_button(!1) : readToMeExtension.play() && readToMeButton.toggle_button(!0);
        }
        function updateButtonState(event) {
            "onplay" === event.type || "onresume" === event.type ? (readToMeButton.toggle_button(!0), 
            doneButton.toggle_button(!1)) : (readToMeButton.toggle_button(!1), doneButton.toggle_button(!0)), 
            "onpause" === event.type && doneButton.toggle_button(!0), "onfinish" === event.type && doneButton.toggle_button(!1);
        }
        function hasMediaOverlayForDPSByIndex(pageIndex) {
            for (var currentPage, hasAudio = !1, smilLoader = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "smildataloader"), i = 0, l = activeTextInstance.view.model.getDisplayedPages(); l > i; i++) currentPage = pageIndex + i, 
            smilLoader && smilLoader.hasSMILForPage(currentPage) && (hasAudio = !0);
            return hasAudio;
        }
        function onPageChange(event, data) {
            var hasAudio, leftPageIndex = ActiveText.NavigationUtils.calculateLeftmostPageIndexFromIndex(activeTextInstance, data.toPage), isDPSView = 2 === activeTextInstance.view.model.getDisplayedPages(), JDPlayer = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "jdplays"), RapidPlayer = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "rapidplays"), plays = JDPlayer || RapidPlayer, inPerformanceMode = plays.isInPerformanceMode(activeTextInstance), pageIndex = leftPageIndex;
            isDPSView === !1 && leftPageIndex !== data.toPage && (pageIndex = data.toPage), 
            hasAudio = hasMediaOverlayForDPSByIndex(pageIndex), inPerformanceMode === !0 ? (readToMeButton.hide(), 
            doneButton.show(), doneButton.toggle_button(!1)) : inPerformanceMode === !1 && (readToMeButton.show(), 
            doneButton.hide(), readToMeButton.toggle_button(!1), hasAudio ? readToMeButton.enable() : readToMeButton.disable());
        }
        function attachEventListeners(read, done) {
            read.on({
                click: readToMeButtonClickHandler
            }), done.on({
                click: doneButtonClickHandler
            }), $(readToMeExtension).on({
                onplay: updateButtonState,
                onresume: updateButtonState,
                onpause: updateButtonState,
                onfinish: updateButtonState
            }), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, onPageChange), $(activeTextInstance).on(ActiveText.Commands.RESIZE, onPageChange);
        }
        function attachReadToMeExtension() {
            readToMeExtension = new ActiveText.ReadToMe(), readToMeExtension.init(activeTextInstance), 
            activeTextInstance.extensions.push(readToMeExtension);
        }
        /**
         * @type {ActiveText.ReadToMe}
         */
        var readToMeButton, doneButton, readToMeExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "readtome");
        readToMeExtension || "function" != typeof ActiveText.ReadToMe || attachReadToMeExtension();
        var factory = ActiveText.UI.BasicControls.ToggleButtonFactory;
        readToMeButton = factory.createToggleButton(READTOME_BUTTON_STYLES, options.options.readtome), 
        doneButton = factory.createToggleButton(DONE_BUTTON_STYLES, options.options.done), 
        doneButton.css("display", "none");
        // use display none here because show/hide defaults to block style instead of inline-block
        var newElement = $('<span class="playAPart"></span>');
        return $(newElement).append(readToMeButton), $(newElement).append(doneButton), readToMeExtension ? attachEventListeners(readToMeButton, doneButton) : readToMeButton.disable(), 
        newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "readtomeExtended", READTOME_BUTTON_STYLES = {
        title: "Read to Me",
        className: "readToMeButton",
        accesskey: "R"
    }, DONE_BUTTON_STYLES = {
        title: "Done",
        className: "doneButton",
        accesskey: "R"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param options {object}
     * @returns {jQuery}
     */
    function create(activeTextInstance, options) {
        function buttonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            }), recordAndPlayExtension.toggleRecord();
        }
        function updateButtonState(event) {
            newElement.toggle_button("stop" === event.type ? !1 : !0);
        }
        function attachEventListeners(buttonElement) {
            buttonElement.on("click", buttonClickHandler), $(activeTextInstance).on("record stop", updateButtonState);
        }
        /**
         * @type {ActiveText.RecordAndPlay}
         */
        var recordAndPlayExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "recordandplay"), factory = ActiveText.UI.BasicControls.ToggleButtonFactory, newElement = factory.createToggleButton(DEFAULT_BUTTON_STYLES, options);
        return recordAndPlayExtension && recordAndPlayExtension.hasFlash() ? attachEventListeners(newElement) : newElement.disable(), 
        newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "record", DEFAULT_BUTTON_STYLES = {
        title: "Record",
        icon: "icon-record",
        className: KEY,
        accesskey: "O"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        var width, factory = ActiveText.UI.BasicControls.SimpleButtonFactory, newElement = factory.createSimpleButton(DEFAULT_SETTINGS, options), popupController = new ActiveText.UI.StructurePopup();
        return options && options.options && options.options.popupnavwidth && (width = options.options.popupnavwidth), 
        popupController.init(activeTextInstance, $(newElement), void 0, width), newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "structure", DEFAULT_SETTINGS = {
        title: "eBook Structure",
        icon: "icon-reorder",
        className: KEY,
        accesskey: "C"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        function switchToDPSView() {
            $(activeTextInstance).trigger(ActiveText.Commands.SWITCH_TO_DPS_VIEW);
        }
        function switchToSinglePageView() {
            $(activeTextInstance).trigger(ActiveText.Commands.SWITCH_TO_SPS_VIEW);
        }
        function buttonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            }), ActiveText.ViewUtils.isSinglePageView(activeTextInstance) ? (newElement.toggle_button(!0), 
            switchToDPSView()) : (newElement.toggle_button(!1), switchToSinglePageView());
        }
        var factory = ActiveText.UI.BasicControls.ToggleButtonFactory, newElement = factory.createToggleButton(DEFAULT_OBJECT, options);
        return newElement.toggle_button(!0), newElement.on({
            click: buttonClickHandler
        }), newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "settings", DEFAULT_OBJECT = {
        title_on: "Double Page View",
        title_off: "Single Page View",
        icon_on: "icon-columns",
        icon_off: "icon-file",
        className: KEY,
        accesskey: "S"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        function switchToDPSView() {
            $(activeTextInstance).trigger(ActiveText.Commands.SWITCH_TO_DPS_VIEW);
        }
        function switchToSinglePageView() {
            $(activeTextInstance).trigger(ActiveText.Commands.SWITCH_TO_SPS_VIEW);
        }
        function buttonClickHandler() {
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            }), ActiveText.ViewUtils.isSinglePageView(activeTextInstance) ? (newElement.toggle_button(!0), 
            switchToDPSView()) : (newElement.toggle_button(!1), switchToSinglePageView());
        }
        function updateButtonState() {
            var isCardMode = ActiveText.ViewUtils.isCardMode(activeTextInstance);
            isCardMode === !1 ? newElement.enable() : newElement.remove();
        }
        var factory = ActiveText.UI.BasicControls.ToggleButtonFactory, newElement = factory.createToggleButton(DEFAULT_OBJECT, options);
        return newElement.toggle_button(!0), newElement.on({
            click: buttonClickHandler
        }), $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, updateButtonState), 
        newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "viewtoggle", DEFAULT_OBJECT = {
        title_on: "Double Page View",
        title_off: "Single Page View",
        icon_on: "icon-file",
        icon_off: "icon-columns",
        className: KEY,
        accesskey: "V"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        function zoomOut() {
            activeTextInstance.view.getContainer().css({
                top: 0,
                left: 0
            });
            try {
                activeTextInstance.view.getContainer().parent().draggable("destroy"), activeTextInstance.view.getContainer().draggable("destroy");
            } catch (e) {}
            activeTextInstance.view.model.setMagnificationValue(1), activeTextInstance.view.model.setScaleMode("fth"), 
            newElement.toggle_button(!0);
        }
        function zoomIn() {
            activeTextInstance.view.model.setMagnificationValue(2), $(activeTextInstance).trigger(ActiveText.Commands.SWITCH_TO_ZOOM_MODE), 
            newElement.toggle_button(!1);
        }
        function onSwitchToDps() {
            $(activeTextInstance).off(ActiveText.Commands.SWITCH_TO_DPS_VIEW, onSwitchToDps).on(ActiveText.Commands.SWITCH_TO_SPS_VIEW, onSwitchToSps), 
            newElement.toggle_state() || zoomIn();
        }
        function onSwitchToSps() {
            $(activeTextInstance).off(ActiveText.Commands.SWITCH_TO_SPS_VIEW, onSwitchToSps).on(ActiveText.Commands.SWITCH_TO_DPS_VIEW, onSwitchToDps), 
            activeTextInstance.view.model.setMagnificationValue(1), newElement.toggle_state() || "ftw" === activeTextInstance.view.model.getScaleMode() || $(activeTextInstance).trigger(ActiveText.Commands.SWITCH_TO_SPS_FTW_VIEW);
        }
        function buttonClickHandler() {
            $(activeTextInstance).off(ActiveText.Commands.SWITCH_TO_DPS_VIEW, onSwitchToDps), 
            $(activeTextInstance).off(ActiveText.Commands.SWITCH_TO_SPS_VIEW, onSwitchToSps), 
            $(activeTextInstance).trigger(ActiveText.Events.UI_ELEMENT_CLICKED, {
                which: KEY
            }), "zoom" === activeTextInstance.view.model.getScaleMode() ? zoomOut() : zoomIn();
        }
        var newElement = ActiveText.UI.BasicControls.ToggleButtonFactory.createToggleButton(DEFAULT_BUTTON_STYLES, options);
        return newElement.on({
            click: buttonClickHandler
        }), zoomOut(), newElement;
    }
    function supported() {
        //        var userAgent = navigator.userAgent;
        //        var isMobileDevice = /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/.test(userAgent);
        return !0;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "zoom", DEFAULT_BUTTON_STYLES = {
        title_off: "Zoom In",
        title_on: "Zoom Out",
        icon_off: "icon-zoom-out",
        icon_on: "icon-zoom-in",
        className: KEY,
        accesskey: "Z"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create,
        supported: supported
    };
}(ActiveText), /* global ActiveText, requestAnimationFrame */
ActiveText.UI = ActiveText.UI || {}, /**
 * @class StructurePopupDisplayHelper
 * @memberOf ActiveText.UI
 * @returns {{init: init, highlightLinksForIndex: highlightLinksForIndex, removeHighlightFromAllLinks: removeHighlightFromAllLinks, showPopup: showPopup, hidePopup: hidePopup}}
 * @constructor
 */
ActiveText.UI.StructurePopupDisplayHelper = function() {
    "use strict";
    function init(instance, element, callback) {
        activeTextInstance = instance, buttonElement = element, createPopupCallback = callback, 
        attachButtonEventHandlers();
    }
    function buttonClickHandler() {
        return createOrShowPopup(), !1;
    }
    function attachButtonEventHandlers() {
        buttonElement.click(buttonClickHandler);
    }
    function createOrShowPopup() {
        var containerElement = buttonElement.parent();
        containerElement && $.fn.atPopover && (popoverCreated ? togglePopupVisibility() : createPopup());
    }
    function togglePopupVisibility() {
        var containerElement = buttonElement.parent(), isOpen = containerElement.find(".at-popover").length > 0;
        isOpen ? hidePopup() : showPopup();
    }
    function hidePopup() {
        var containerElement = buttonElement.parent();
        setTimeout(detachOutsideClickListener, 0), containerElement.atPopover("hide"), buttonElement.removeClass("open"), 
        buttonElement.toggle_button && buttonElement.toggle_button(!1), popoverCreated = !1;
    }
    function showPopup() {
        var containerElement = buttonElement.parent();
        setTimeout(attachOutsideClickListener, 0), containerElement.atPopover("show"), buttonElement.toggle_button && buttonElement.toggle_button(!0), 
        buttonElement.attr("aria-activedescendant", "activetext-contents");
    }
    function attachOutsideClickListener() {
        $(document).on("click", outsideClickListener);
    }
    function detachOutsideClickListener() {
        $(document).off("click", outsideClickListener);
    }
    function outsideClickListener(event) {
        var containerElement = buttonElement.parent();
        didNotClickInsideAnActivePopover(event) && (containerElement.atPopover("hide"), 
        buttonElement.removeClass("open"), buttonElement.toggle_button && buttonElement.toggle_button(!1), 
        popoverCreated = !1, detachOutsideClickListener());
    }
    /**
     * @param event {object}
     * @return {Boolean}
     */
    function didNotClickInsideAnActivePopover(event) {
        var containerElement = buttonElement.parent(), eventTarget = $(event.target);
        return !(0 === eventTarget.parents(containerElement).length && 0 === eventTarget.parents(".at-popover").length);
    }
    function createPopup() {
        createPopupCallback(), popoverCreated = !0, togglePopupVisibility();
    }
    function highlightChapterFor(pageNumber) {
        for (var i = pageNumber; i >= 0; i--) if (getContentsElementByPageNumber(i).length > 0) {
            getContentsElementByPageNumber(i).addClass(ACTIVE_CLASS);
            break;
        }
    }
    function getContentsElementByPageNumber(pageNumber) {
        var popupContents = buttonElement.parent().find(".at-popover-content");
        return popupContents.find('a[data-page="' + pageNumber + '"]');
    }
    /**
     * @param rowHeight {number}
     * @param pageIndex {number}
     * @param scrollSpeed {number}
     */
    function highlightLinksForIndex(rowHeight, pageIndex, scrollSpeed) {
        var popupContents = buttonElement.parent().find(".at-popover-content");
        /* istanbul ignore else */
        if (popupContents) {
            var pageNumber = ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, pageIndex), hasLinkForLeftPage = getContentsElementByPageNumber(pageNumber).length > 0;
            if (ActiveText.ViewUtils.isSinglePageView(activeTextInstance)) /* istanbul ignore else */
            0 === getContentsElementByPageNumber(pageNumber).length && highlightChapterFor(pageNumber); else if (!hasLinkForLeftPage) {
                var siblingPageNumber = ActiveText.NavigationUtils.getSiblingPageNumberForPage(activeTextInstance, pageNumber), hasLinkForRightPage = getContentsElementByPageNumber(siblingPageNumber).length > 0;
                hasLinkForRightPage ? getContentsElementByPageNumber(siblingPageNumber).addClass(ACTIVE_CLASS).focus() : highlightChapterFor(pageNumber);
            }
            hasLinkForLeftPage && getContentsElementByPageNumber(pageNumber).addClass(ACTIVE_CLASS).focus();
            var index = popupContents.find("a").index($("." + ACTIVE_CLASS)), listContainer = popupContents.find(".list-container"), convertedPos = index * rowHeight - listContainer.height() / 2 + rowHeight;
            void 0 === scrollSpeed && (scrollSpeed = 300), requestAnimationFrame(function() {
                listContainer.animate({
                    scrollTop: convertedPos
                }, {
                    duration: scrollSpeed,
                    queue: !1
                });
            });
        }
    }
    function removeHighlightFromAllLinks() {
        var popupContents = buttonElement.parent().find(".at-popover-content");
        /* istanbul ignore else */
        popupContents && popupContents.find("a." + ACTIVE_CLASS).removeClass(ACTIVE_CLASS);
    }
    /**
     * @type {string}
     */
    var activeTextInstance, createPopupCallback, buttonElement, ACTIVE_CLASS = "active", popoverCreated = !1;
    return {
        init: init,
        highlightLinksForIndex: highlightLinksForIndex,
        removeHighlightFromAllLinks: removeHighlightFromAllLinks,
        showPopup: showPopup,
        hidePopup: hidePopup
    };
}, /* global ActiveText, requestAnimationFrame, ScrollFix */
ActiveText.namespace("ActiveText.UI.StructurePopup"), ActiveText.UI.StructurePopup = function() {
    "use strict";
    function init(instance, element, scopePrefix, width) {
        activeTextInstance = instance, buttonElement = element, factory = ActiveText.UI.StructurePopupFactory, 
        helper = new ActiveText.UI.StructurePopupDisplayHelper(), helper.init(activeTextInstance, buttonElement, createPopupCallback), 
        embedCSSStyleTag(scopePrefix, width), attachEventHandlers();
    }
    /**
     * Embeds the CSS necessary to render the structure popup.
     *
     * @param scopePrefix {string}
     * @param popupWidth {number}
     */
    function embedCSSStyleTag(scopePrefix, popupWidth) {
        var scope;
        scope = "string" == typeof scopePrefix ? scopePrefix + " " : activeTextInstance.options.containerElement.selector + " ";
        var cssString = ActiveText.UI.StructurePopup.Style.getStyle(scope, activeTextInstance.theme, popupWidth);
        ActiveText.CSSUtils.embedCSS(cssString, scope + "structure-popup");
    }
    /**
     * @param obj {object|array}
     * @return {string}
     */
    function convertNavigationStructureToHTMLList(obj) {
        var output = "";
        if (obj && $.isArray(obj) && obj.length > 0) {
            output += '<ul role="navigationlist">';
            for (var i = 0, len = obj.length; len > i; i++) output += convertNavigationStructureToHTMLList(obj[i]);
            output += "</ul>";
        } else output += obj && void 0 !== obj.number && void 0 !== obj.title ? '<li><a href="#" data-page="' + (obj.number - 0) + '" role="navigation">' + obj.title + "</a></li>" : "";
        return output;
    }
    function generateInitialContentForPopover(data) {
        var content = convertNavigationStructureToHTMLList(data), jQueryRtn = $("<div></div>").html(content);
        return jQueryRtn.find("li:first").addClass("first"), jQueryRtn.find("li:last").addClass("last"), 
        '<div class="structured-navigation-popup"><div id="activetext-contents" class="list-container scrollable">' + jQueryRtn.html() + "</div></div>";
    }
    function createPopupCallback() {
        buttonElement.addClass("open"), buttonElement.toggle_button && buttonElement.toggle_button(!0);
        var data = activeTextInstance.data.getNavigationStructure(), containerElement = buttonElement.parent(), popup = factory.createPopup(containerElement, generateInitialContentForPopover(data));
        popup.css({
            visibility: "hidden"
        }), setTimeout(function() {
            function teardown() {
                activeTextInstance.options.containerElement.off("remove", teardown), $(window).off({
                    keydown: onKeyDown
                });
            }
            popup.css({
                visibility: "visible"
            }), // timeouts are nasty, but jQuery can't re-select things until one cycle post creation of the popup.
            popupContents = containerElement.find(".at-popover-content"), popupContents.attr("tabindex", buttonElement.attr("tabindex")), 
            popupContents.on({
                click: linkClickHandler
            }), helper.highlightLinksForIndex(ROW_HEIGHT, activeTextInstance.model.getCurrentIndex(), 0);
            new ScrollFix(popupContents.find(".scrollable").get(0));
            activeTextInstance.options.containerElement.on("remove", teardown), $(window).on({
                keydown: onKeyDown
            });
        }, 0);
    }
    function onKeyDown(e) {
        var code = e.which;
        return code === ActiveText.Keymap.UP ? ($(".at-popover-content a:focus").parent().prev().find("a").focus(), 
        scrollToPos(), !1) : code === ActiveText.Keymap.DOWN ? ($(".at-popover-content a:focus").parent().next().find("a").focus(), 
        scrollToPos(), !1) : void (code === ActiveText.Keymap.ESCAPE ? helper.hidePopup() : code === ActiveText.Keymap.TAB && scrollToPos());
    }
    function scrollToPos() {
        var index = popupContents.find("a").index($("a:focus")), listContainer = popupContents.find(".list-container"), convertedPos = index * ROW_HEIGHT - listContainer.height() / 2 + ROW_HEIGHT;
        requestAnimationFrame(function() {
            listContainer.animate({
                scrollTop: convertedPos
            }, {
                duration: 300,
                queue: !1
            });
        });
    }
    /**
     * @param event {object}
     * @return {Boolean}
     */
    function linkClickHandler(event) {
        var targetPageNumber = $(event.target).attr("data-page");
        return activeTextInstance.navigation.gotoPage(targetPageNumber), $(event.target).blur(), 
        !1;
    }
    function attachEventHandlers() {
        $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, updateCurrentPageMarkerOnPageChange);
    }
    function updateCurrentPageMarkerOnPageChange(event, data) {
        helper.removeHighlightFromAllLinks(), helper.highlightLinksForIndex(ROW_HEIGHT, data.toPage);
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, popupContents, buttonElement, factory, helper, ROW_HEIGHT = 32;
    return {
        init: init,
        createPopup: attachEventHandlers
    };
}, /* global ActiveText */
ActiveText.namespace("ActiveText.UI.StructurePopup.Style"), ActiveText.UI.StructurePopup.Style = function() {
    "use strict";
    /**
     * @param scope {string}
     * @param theme {ActiveText.Theme}
     * @param width {number}
     * @returns {string}
     */
    function getStyle(scope, theme, width) {
        var indent = 20;
        scope || (scope = ""), theme || (theme = new ActiveText.Theme()), width || (width = 480);
        var controlsOutlineColor = theme.getControlsOutlineColor(), popupBackgroundColor = theme.getPopupBackgroundColor(), controlsForegroundColor = theme.getControlsForegroundColor(), linkBackgroundActiveHoverColor = theme.getControlsForegroundHoverColor(), linkBackgroundActiveColor = theme.getControlsForegroundHoverColor(.66), linkBackgroundHoverColor = theme.getControlsForegroundHoverColor(.33), scrollbarFillColor = theme.getControlsOutlineColor(.5), isMac = /(Mac|iPad|iPhone|iPod)/g.test(navigator.userAgent), useHoverStyles = !ActiveText.BrowserUtils.isMobileDevice, scrollbarStyles = "";
        return isMac || (scrollbarStyles = scope + ".at-popover ::-webkit-scrollbar {width: 8px;height: 10px;}" + scope + ".at-popover ::-webkit-scrollbar-button:start:decrement { display: block; width: 5px; height: 5px; background-color: transparent;}" + scope + ".at-popover ::-webkit-scrollbar-button:end:increment {display: block; width: 5px; height: 5px; background-color: transparent;}" + scope + ".at-popover ::-webkit-scrollbar-track:enabled {background-color: transparent;}" + scope + ".at-popover ::-webkit-scrollbar-track-piece {background-color: transparent; border: none; margin: 0;}" + scope + ".at-popover ::-webkit-scrollbar-thumb:vertical {height: 30px;background-color:" + scrollbarFillColor + ";-webkit-border-radius: 5px;-webkit-box-shadow: 0 1px 1px rgba(255,255,255,0.2)}" + scope + ".at-popover ::-webkit-scrollbar-thumb:horizontal {width: 30px;background-color:" + scrollbarFillColor + ";-webkit-border-radius: 5px;}"), 
        scope + ".at-popover {position: absolute;top: 0;left: 0;z-index: 1040;display: none;padding: 5px;}" + scope + ".at-popover.top {margin-top: -5px; }" + scope + ".at-popover.top .arrow {bottom: 0;left: 50%;margin-left: -5px;border-left: 5px solid transparent;border-right: 5px solid transparent;border-top: 5px solid " + controlsOutlineColor + "; }" + scope + ".at-popover .arrow {position: absolute;width: 0;height: 0; }" + scope + ".at-popover-inner {padding: 3px;overflow: hidden;background: " + controlsOutlineColor + ";background: " + theme.getControlsOutlineColor(.8) + ";-webkit-border-radius: 6px;-moz-border-radius: 6px;border-radius: 6px;-webkit-box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);-moz-box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3); }" + scope + ".at-popover-content {padding: 0;background-color: " + popupBackgroundColor + ";-webkit-border-radius: 3px;-moz-border-radius: 3px;border-radius: 3px;-webkit-background-clip: padding-box;-moz-background-clip: padding-box;background-clip: padding-box;width:" + width + "px;}" + scope + ".at-popover-content p," + scope + ".at-popover-content ul," + scope + ".at-popover-content ol {margin-bottom: 0; }.structured-navigation-popup ul {font-size:16px;line-height:2em;margin:0;padding:0}" + scope + ".list-container {overflow: scroll;-webkit-overflow-scrolling: touch;overflow-x:hidden;overflow-y:auto;height:250px;padding:3px 0 4px;margin:0 4px;}" + scope + ".structured-navigation-popup ul li {margin:0;text-align:left;list-style: none;line-height: 32px;}" + scope + ".structured-navigation-popup ul ul li a {padding-left:30px !important;width:" + (width - 3 * indent) + "px !important;}" + scope + ".structured-navigation-popup ul ul ul li a {padding-left:50px !important;width:" + (width - 4 * indent) + "px !important;}" + scope + ".structured-navigation-popup ul ul ul ul li a {padding-left:70px !important;width:" + (width - 5 * indent) + "px !important;}" + scope + ".structured-navigation-popup ul ul ul ul ul li a {padding-left:90px !important;width:" + (width - 6 * indent) + "px !important;}" + scope + ".structured-navigation-popup ul li a," + scope + ".structured-navigation-popup ul li a:link," + scope + ".structured-navigation-popup ul li a:visited{text-decoration:none;white-space: nowrap;text-overflow: ellipsis;display:inline-block;padding:0 10px;width:" + (width - 2 * indent) + "px;-webkit-border-radius: 3px;-moz-border-radius: 3px;border-radius: 3px;color:" + theme.getTextColor() + ";-webkit-transition: background .3s;-moz-transition: background .3s;-ms-transition: background .3s;-o-transition: background .3s;transition: background .3s;-webkit-touch-callout: none;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;}" + (useHoverStyles ? scope + ".structured-navigation-popup ul li a:hover," : "") + scope + ".structured-navigation-popup ul li a:active," + scope + ".structured-navigation-popup ul li a:focus{background:" + linkBackgroundHoverColor + ";-webkit-tap-highlight-color:" + linkBackgroundHoverColor + ";outline:none;}" + scope + ".structured-navigation-popup ul li a.active{font-weight:bold;background:" + linkBackgroundActiveColor + ";color:" + controlsForegroundColor + ";}" + (useHoverStyles ? scope + ".structured-navigation-popup ul li a.active:hover," : "") + scope + ".structured-navigation-popup ul li a.active:active," + scope + ".structured-navigation-popup ul li a.active:focus{background:" + linkBackgroundActiveHoverColor + ";}" + scrollbarStyles;
    }
    return {
        getStyle: getStyle
    };
}(), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.StructurePopupFactory"), ActiveText.UI.StructurePopupFactory = function() {
    "use strict";
    /**
     * @param containerElement
     * @param content {string}
     * @returns {object}
     */
    function createPopupOnElementWithContent(containerElement, content) {
        return containerElement.atPopover({
            placement: "in top",
            trigger: "manual",
            html: !0,
            content: content,
            template: getPopoverTemplate()
        });
    }
    /**
     * @returns {string}
     */
    function getPopoverTemplate() {
        return $('<div><div class="at-popover"><div class="arrow"></div><div class="at-popover-inner"><div class="at-popover-content"><div></div></div></div></div></div>').html();
    }
    return {
        createPopup: createPopupOnElementWithContent
    };
}(), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.FontInjection"), ActiveText.UI.FontInjection = function(ActiveText) {
    "use strict";
    function injectFontTag() {
        var pathToResources = ActiveText.SkinUtils.getPathToGlobalResource();
        $('<link rel="stylesheet" href="' + pathToResources + 'font/font-awesome.min.css">').appendTo("head"), 
        $('<link rel="stylesheet" href="' + pathToResources + 'font/general_enclosed_foundicons.css">').appendTo("head"), 
        $.browser.msie && parseInt($.browser.version, 10) < 8 && ($('<link rel="stylesheet" href="' + pathToResources + 'font/font-awesome-ie7.min.css">').appendTo("head"), 
        $('<link rel="stylesheet" href="' + pathToResources + 'font/general_enclosed_foundicons_ie7.css">').appendTo("head")), 
        added = !0;
    }
    /**
     * @return {Boolean}
     */
    function hasBeenAdded() {
        return added;
    }
    /**
     * @type {Boolean}
     */
    var added = !1;
    return {
        injectFontTag: injectFontTag,
        hasBeenAdded: hasBeenAdded
    };
}(ActiveText), /* global ActiveText */
/**
 * @const
 * @type {{SPACE: number, ENTER: number, TAB: number, BACKSPACE: number, SHIFT: number, CTRL: number, ALT: number, CAPS_LOCK: number, NUM_LOCK: number, SCROLL_LOCK: number, LEFT: number, UP: number, RIGHT: number, DOWN: number, PAGE_UP: number, PAGE_DOWN: number, HOME: number, END: number, INSERT: number, DELETE: number, ESCAPE: number, PAUSE: number}}
 */
ActiveText.Keymap = {
    SPACE: 32,
    ENTER: 13,
    TAB: 9,
    BACKSPACE: 8,
    SHIFT: 16,
    CTRL: 17,
    ALT: 18,
    CAPS_LOCK: 20,
    NUM_LOCK: 144,
    SCROLL_LOCK: 145,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    PAGE_UP: 33,
    PAGE_DOWN: 34,
    HOME: 36,
    END: 35,
    INSERT: 45,
    DELETE: 46,
    ESCAPE: 27,
    PAUSE: 19
}, /* global ActiveText */
/**
 * @class KeyboardIntegration
 * @memberOf ActiveText
 * @param options {*} A Dictionary of Keycode values and functions to execute when they are pressed. Defaults to left
 * & right keypress triggering previous/next page turns.
 * @returns {{init: init, key: string}}
 * @constructor
 */
ActiveText.KeyboardIntegration = function(options) {
    "use strict";
    function init(activeTextInstance) {
        function teardown() {
            activeTextInstance.options.containerElement.off("remove", teardown), $(window).off({
                keydown: onKeyDown
            });
        }
        activeTextInstance && (keyConfiguration = options, keyConfiguration || (keyConfiguration = {}, 
        keyConfiguration[ActiveText.Keymap.LEFT] = activeTextInstance.navigation.gotoPrevPage, 
        keyConfiguration[ActiveText.Keymap.RIGHT] = activeTextInstance.navigation.gotoNextPage), 
        activeTextInstance.options.containerElement.on("remove", teardown), $(window).on({
            keydown: onKeyDown
        }));
    }
    function onKeyDown(e) {
        var code = e.which;
        null !== keyConfiguration[code] && "function" == typeof keyConfiguration[code] && keyConfiguration[code]();
    }
    /**
     * @type {object}
     */
    var keyConfiguration;
    return {
        init: init,
        key: "keyboardintegration"
    };
}, /* global ActiveText, GenericAPIAdaptor */
/**
 * @class SCORMIntegration
 * @memberOf ActiveText
 * @param externalSCORMAPI {*}
 * @returns {{init: init, key: string, getSCORMData: getSCORMData, gotSCORMData: gotSCORMData, setSCORMData: setSCORMData}}
 * @constructor
 */
ActiveText.SCORMIntegration = function(externalSCORMAPI) {
    "use strict";
    /**
     * @private
     * @param instance {ActiveText}
     */
    function init(instance) {
        if (activeTextInstance = instance, externalSCORMAPI && externalSCORMAPI.callAjax && "function" == typeof externalSCORMAPI.callAjax) {
            /*jshint validthis:true */
            var context = this, originalCallAjax = externalSCORMAPI.callAjax;
            externalSCORMAPI.callAjax = function(getOrSetOrBulkOp, n, field, dataToSend) {
                var result = originalCallAjax.apply(externalSCORMAPI, arguments);
                if ("bulkSet" === getOrSetOrBulkOp) "true" === String(result) && context.gotSCORMData(condenseSCORMMessage(dataToSend)); else if ("bulkGet" === getOrSetOrBulkOp) {
                    var parsedResult = condenseSCORMMessage(result);
                    context.gotSCORMData(parsedResult);
                } else debug.log("ActiveText.SCORMIntegration instance does not know how to handle operation " + getOrSetOrBulkOp + ".");
            };
        } else debug.log("ActiveText.SCORMIntegration instance was not passed an object with a method callAjax to extend.", externalSCORMAPI);
    }
    function parseArray(array) {
        for (var obj = {}, i = 0, l = array.length; l > i; i++) {
            var property = array[i];
            void 0 === obj[property.n] && (obj[property.n] = {}), obj[property.n][property.field] = property.fieldVal;
        }
        return obj;
    }
    function parseObject(input) {
        var rtn = {};
        for (var key in input) {
            var property = input[key];
            rtn[key] = $.isArray(property) ? parseArray(property) : "object" == typeof property ? parseObject(property) : property;
        }
        return rtn;
    }
    function condenseSCORMMessage(data) {
        var input, rtn = {};
        return input = "string" == typeof data ? JSON.parse(data) : data, rtn = $.isArray(input) ? parseArray(input) : "object" == typeof input ? parseObject(input) : input;
    }
    function getSCORMData() {
        externalSCORMAPI.callAjax("bulkGet", null, null, null);
    }
    function gotSCORMData(data) {
        $(activeTextInstance).trigger(ActiveText.SCORMIntegration.SCORM_DATA_UPDATED, data);
    }
    function setSCORMData(data) {
        externalSCORMAPI.callAjax("bulkSet", null, null, data);
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance;
    return {
        init: init,
        key: "scorm",
        getSCORMData: getSCORMData,
        gotSCORMData: gotSCORMData,
        setSCORMData: setSCORMData
    };
}, /* global ActiveText */
/**
 * @const
 * @type {string}
 */
ActiveText.SCORMIntegration.SCORM_DATA_UPDATED = "activetext.scorm.data_updated", 
/* global ActiveText, ActiveText */
ActiveText.namespace("ActiveText.CustomSettingsParser"), ActiveText.CustomSettingsParser = function() {
    "use strict";
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        activeTextInstance = instance, $(activeTextInstance).one(ActiveText.Events.CONTAINER_XML_LOADED, loadCustomSettings);
    }
    function loadCustomSettings() {
        var url = activeTextInstance.loader.getDataProvider().getPathToMETA() + "custom.json";
        $.ajax({
            url: url,
            dataType: "json",
            localCache: ActiveText.Constants.USE_LOCAL_CACHE,
            success: onSettingsLoaded,
            error: onSettingsLoadError
        });
    }
    /**
     * Sets the dimensions for the book from the custom.json file.
     * @param data {{width: number, height: number}}
     */
    function setDimensionsFromData(data) {
        if (void 0 !== data.width && void 0 !== data.height) {
            var width = parseInt(data.width, 10), height = parseInt(data.height, 10), aspectRatio = width / height;
            activeTextInstance.view.model.setPageDimensions({
                width: width,
                height: height,
                aspectRatio: aspectRatio
            }), // legacy code from ActiveTeach where zoom area dimensions
            // could be different to the actual page dimensions
            activeTextInstance.view.model.setZoomAreaDimensions({
                width: width,
                height: height
            });
        }
    }
    /**
     * Sets the firstPageIsLeft and numberingOffset parameters from the custom.json file.
     * @param data {{versoStart: number|boolean, numberingOffset: number}}
     */
    function setPageNumberingFromData(data) {
        var firstPageIsLeftOptionNotSet = !activeTextInstance.options || activeTextInstance.options && void 0 === activeTextInstance.options.firstPageIsLeft;
        if (firstPageIsLeftOptionNotSet && void 0 !== data.versoStart) {
            var firstPageIsLeft = Boolean(data.versoStart);
            activeTextInstance.settings.setFirstPageIsLeft(firstPageIsLeft);
        }
        if (data.versoStart !== numberingOffset) {
            var numberingOffset = parseInt(-data.numberingOffset + 1, 10);
            activeTextInstance.settings.setNumberingOffset(numberingOffset);
        }
    }
    function setManifestReferenceFromData(data) {
        var hasShortManifest = Boolean(parseInt(data.shortManifest, 10));
        if (hasShortManifest) {
            var currentOPFURL = activeTextInstance.loader.getDataProvider().getOPFURL(), re = new RegExp(".opf", "gi"), newOPFURL = currentOPFURL.replace(re, "-short.opf");
            activeTextInstance.loader.getDataProvider().setOPFURL(newOPFURL);
        }
    }
    function setCardMode(data) {
        var cardMode = !1;
        window.hasOwnProperty = window.hasOwnProperty || function(obj) {
            return this[obj] ? !0 : !1;
        }, data.hasOwnProperty("cardMode") && (cardMode = Boolean(data.cardMode), cardMode && $(activeTextInstance).trigger(ActiveText.Commands.SWITCH_TO_SPS_VIEW)), 
        activeTextInstance.view.model.setCardMode(cardMode);
    }
    /**
     * Fires when the custom.json file has been loaded and the contents successfully JSON-decoded.
     * @param data {{width: number, height: number, versoStart: number|boolean, numberingOffset: number}}
     */
    function onSettingsLoaded(data) {
        setDimensionsFromData(data), setPageNumberingFromData(data), setManifestReferenceFromData(data), 
        setCardMode(data), $(activeTextInstance).trigger(ActiveText.Settings.Events.LOADED, [ data ]);
    }
    function onSettingsLoadError() {
        $(activeTextInstance).trigger(ActiveText.Settings.Events.LOAD_ERROR);
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance;
    return {
        init: init
    };
}, /* global ActiveText, ActiveText, _ */
/**
 * @class OverlayData
 * @memberOf ActiveText
 * @returns {{init: init, loadDataForIndex: loadDataForIndex, loadDataForPageIndex: loadDataForPageIndex, getDataForIndex: getDataForIndex, hasOverlayDataForIndex: hasOverlayDataForIndex, key: string}}
 * @constructor
 */
ActiveText.OverlayData = function() {
    "use strict";
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        /* jshint validthis:true */
        activeTextInstance = instance, context = this, cachedData = [], $(activeTextInstance).one(ActiveText.Events.CONTAINER_XML_LOADED, loadOverlayDataManifest), 
        $(activeTextInstance).on(ActiveText.Commands.LOAD_RESOURCE_FOR_CURRENT_INDEX, loadOverlayDataForVisiblePages);
    }
    function loadOverlayDataManifest() {
        var url = activeTextInstance.loader.getDataProvider().getPathToMETA() + "overlay-files.json";
        $.ajax({
            url: url,
            dataType: "json",
            localCache: ActiveText.Constants.USE_LOCAL_CACHE,
            success: onManifestLoaded,
            error: onManifestLoadError
        });
    }
    function onManifestLoaded(data) {
        $.isArray(data) ? (availableFileNames = data, hasManifest = !0) : debug.log("JSON overlay manifest loaded but data was not an array", data);
    }
    function onManifestLoadError() {}
    function loadOverlayDataForVisiblePages() {
        for (var numberOfPagesToLoadDataFor = activeTextInstance.view.model.getDisplayedPages(), i = 0; numberOfPagesToLoadDataFor > i; i++) context.loadDataForIndex(i);
    }
    function loadDataForIndex(dpsIndex) {
        var pageIndex = activeTextInstance.model.getCurrentIndex() + dpsIndex;
        loadDataForPageIndex(pageIndex);
    }
    function loadDataForPageIndex(index) {
        var path = activeTextInstance.loader.getDataProvider().getPathToMETA(), sourceURL = getOverlayURLForPageByIndex(index);
        hasOverlayDataForIndex(index) && (activeTextInstance.loader.addItemToQueue({
            index: index
        }), fetchDataForURL(path + sourceURL, index));
    }
    function hasOverlayDataForIndex(index) {
        var sourceURL = getOverlayURLForPageByIndex(index);
        return !hasManifest || hasManifest && _.contains(availableFileNames, sourceURL);
    }
    function getOverlayURLForPageByIndex(index) {
        //            var path = activeTextInstance.loader.getDataProvider().getPathToMETA();
        var pagesPath = activeTextInstance.loader.getDataProvider().getPathToPages();
        if (-1 === activeTextInstance.utils.getSourcePathForIndex(index).indexOf("about:blank")) {
            var pathToPageArray = activeTextInstance.utils.getSourcePathForIndex(index).split(pagesPath).join("").split(".");
            pathToPageArray.pop();
            var pathToPage = pathToPageArray.join(".") + ".json";
            return pathToPage;
        }
        return activeTextInstance.utils.getSourcePathForIndex(index);
    }
    function getDataForIndex(index) {
        return cachedData[index];
    }
    function fetchDataForURL(sourceURL, pageIndex) {
        function handleAPIResponse(result, status) {
            activeTextInstance.loader.removeItemFromQueue({
                index: pageIndex
            });
            var eventData = {
                index: pageIndex,
                data: result
            };
            cachedData[pageIndex] = result, "error" === status ? $(activeTextInstance).trigger(ActiveText.Events.OVERLAY_DATA_FAIL, eventData) : $(activeTextInstance).trigger(ActiveText.Events.LOADED_OVERLAY_DATA, eventData);
        }
        "about:blank" !== sourceURL && $.ajax({
            url: sourceURL,
            dataType: "json",
            localCache: ActiveText.Constants.USE_LOCAL_CACHE,
            success: handleAPIResponse,
            error: handleAPIResponse
        });
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, context, cachedData, availableFileNames, hasManifest = !1;
    return {
        init: init,
        loadDataForIndex: loadDataForIndex,
        loadDataForPageIndex: loadDataForPageIndex,
        getDataForIndex: getDataForIndex,
        hasOverlayDataForIndex: hasOverlayDataForIndex,
        key: "overlaydataloader"
    };
}, /* global ActiveText */
ActiveText.PageRangeHelper = function() {
    "use strict";
    function isAllowedPageNumber(activeTextInstance, pageNumber) {
        var rtn = !1, pageRangeIsDefined = activeTextInstance.options && void 0 !== activeTextInstance.options.pageRange && activeTextInstance.options.pageRange.toString().length;
        if (pageRangeIsDefined) {
            var pageRange = activeTextInstance.options.pageRange, valueType = typeof pageRange;
            if ("number" === valueType) rtn = pageNumber === pageRange; else if ("string" === valueType) for (var groups = pageRange.split(","), i = 0, l = groups.length; l > i; i++) if (-1 === groups[i].indexOf("-")) rtn = rtn || parseInt(groups[i], 10) === pageNumber; else {
                var range = groups[i].split("-"), rangeMin = parseInt(range.shift(), 10), rangeMax = parseInt(range.pop(), 10);
                pageNumber >= rangeMin && rangeMax >= pageNumber && (rtn = !0);
            }
        } else rtn = !0;
        return rtn;
    }
    return {
        isAllowedPageNumber: isAllowedPageNumber
    };
}();

/* global ActiveText, ActiveText, requestAnimationFrame */
/**
 * @const
 * @type {string}
 */
var INVALID_EPUB_SPINE_MESSAGE = "No valid ePub spine", ERROR_LOADING_STRUCTURE = "An Error Occurred loading the eBook structure";

/**
 * @class DataProvider
 * @memberOf ActiveText
 * @param activeTextInstance {ActiveText}
 * @returns {{getSpineData: loadLocalSpineFile, getOPFURL: getOPFURL, setOPFURL: setOPFURL, getNCXURL: getNCXURL, setNCXURL: setNCXURL, getPathToPages: getPathToPages, getPathToMETA: getPathToMETA}}
 * @constructor
 */
ActiveText.DataProvider = function(activeTextInstance) {
    "use strict";
    function throwInvalidSpineError() {
        $(activeTextInstance).trigger(ActiveText.Commands.DISPLAY_ERROR, INVALID_EPUB_SPINE_MESSAGE);
    }
    function throwStructureLoadError(jqXHR, textStatus, errorThrown) {
        phantom || debug.log("An Error Occurred", jqXHR, textStatus, errorThrown), //        debug.error('Unable to load epub structure from ' + cachedOPFURL);
        $(activeTextInstance).trigger(ActiveText.Events.RESOURCES_ERROR), $(activeTextInstance).trigger(ActiveText.Commands.DISPLAY_ERROR, errorThrown);
    }
    /**
     * @param status {string}
     * @return {Boolean}
     */
    function isValidResponse(status) {
        return "error" !== status;
    }
    function parseNCXFile(result, status) {
        if ($(activeTextInstance).trigger(ActiveText.Commands.SHOW_LOADER), isValidResponse(status)) {
            var navmapData = extractNavMapFromNCX(result);
            $(activeTextInstance).trigger(ActiveText.Events.NAVMAP_LOADED, [ navmapData ]), 
            $(activeTextInstance).trigger(ActiveText.Commands.HIDE_LOADER);
        } else //            debug.error('NCX is not a valid response.');
        throwStructureLoadError();
    }
    function extractStructureFromOPF(result, status) {
        if ($(activeTextInstance).trigger(ActiveText.Commands.SHOW_LOADER), $(activeTextInstance).trigger(ActiveText.Events.OPF_DATA_LOADED, result), 
        isValidResponse(status)) {
            var url = parseNCXReference(result), resultPromise = convertOPFToAPIResponse(result);
            resultPromise.done(function(results) {
                if (void 0 !== results) {
                    $(activeTextInstance).trigger(ActiveText.Events.BOOK_STRUCTURE_LOADED, [ results ]), 
                    "" !== url && loadNCXFile(url);
                    var existingVar = activeTextInstance.settings.getNumberingOffset();
                    activeTextInstance.settings.setNumberingOffset(existingVar + numberingOffsetIncrement), 
                    numberingOffsetIncrement % 2 && activeTextInstance.settings.setFirstPageIsLeft(!activeTextInstance.settings.getFirstPageIsLeft()), 
                    1 === results.length && (activeTextInstance.options.defaults = activeTextInstance.options.defaults || {}, 
                    activeTextInstance.options.defaults.pagesToDisplay = 1, $(activeTextInstance).trigger(ActiveText.Commands.SWITCH_TO_SPS_VIEW));
                }
            });
        } else debug.error("OPF Structure is not valid."), throwStructureLoadError();
    }
    function loadNCXFile(url) {
        //            debug.log('Attempting to Load: ' + url);
        return url ? (setNCXURL(url), $.ajax({
            url: url,
            dataType: "text xml",
            localCache: shouldCacheTheseFiles,
            success: parseNCXFile,
            error: throwStructureLoadError
        })) : debug.error("Unable to load NCX data file for ActiveText instance, because path was ", url), 
        url;
    }
    function loadOPFFile(url) {
        url ? (setOPFURL(url), //            debug.log('Attempting to Load: ' + url);
        $.ajax({
            url: url,
            dataType: "text xml",
            localCache: shouldCacheTheseFiles,
            success: extractStructureFromOPF,
            error: throwStructureLoadError
        })) : debug.error("Unable to load OPF data file for ActiveText instance, because path was ", url);
    }
    function loadLocalSpineFile() {
        var validSpine = !1;
        return activeTextInstance && activeTextInstance.options ? ($(document).ready(function() {
            loadMetaInfContainer();
        }), validSpine = !0) : throwInvalidSpineError(), validSpine;
    }
    function loadOPFFileOnEvent() {
        var opfurl = getOPFURL();
        loadOPFFile(opfurl);
    }
    function parseContainerXML(containerFileData) {
        if ($(activeTextInstance).trigger(ActiveText.Commands.SHOW_LOADER), containerFileData) {
            var nodes = $(containerFileData).find("container > rootfiles > rootfile");
            if ("application/oebps-package+xml" === nodes.attr("media-type")) {
                var pathToOPF = activeTextInstance.options.pathToAssets + nodes.attr("full-path");
                setOPFURL(pathToOPF), $(activeTextInstance).one(ActiveText.Settings.Events.LOADED + " " + ActiveText.Settings.Events.LOAD_ERROR, loadOPFFileOnEvent);
            } else throwInvalidSpineError();
            $(activeTextInstance).trigger(ActiveText.Events.CONTAINER_XML_LOADED, containerFileData);
        } else debug.error("Unable to load container.xml file for title.");
    }
    function loadMetaInfContainer() {
        var url = activeTextInstance.options.pathToAssets + "META-INF/container.xml";
        //        debug.log('Attempting to Load: ' + url);
        $.ajax({
            url: url,
            dataType: "text xml",
            localCache: shouldCacheTheseFiles,
            success: parseContainerXML,
            error: throwStructureLoadError
        });
    }
    function extractNavPointDataFromNode(node, pages) {
        for (var currentNavPoint, currentNavPointSource, pageNumber, numberingOffset = activeTextInstance.settings.getNumberingOffset(), navPoints = $(node).find("> navPoint"), rtn = [], i = 0, l = navPoints.length; l > i; i++) currentNavPoint = $(navPoints[i]), 
        currentNavPointSource = currentNavPoint.find("> content").attr("src"), pageNumber = parseInt(pages.find('> pageTarget content[src="' + currentNavPointSource + '"]').parent().attr("playOrder"), 10) + (numberingOffset - 1), 
        isNaN(pageNumber) && (pageNumber = parseInt(currentNavPoint.attr("playOrder"), 10) + (numberingOffset - 1)), 
        rtn.push({
            id: i,
            title: currentNavPoint.find("> navLabel text").text(),
            html_location: currentNavPointSource,
            number: pageNumber,
            children: extractNavPointDataFromNode(navPoints[i], pages)
        });
        return rtn;
    }
    /**
     * @param ncxFileData {XMLDocument}
     * @returns {Array}
     */
    function extractNavMapFromNCX(ncxFileData) {
        ncxFileCache = ncxFileData;
        var nodes = $(ncxFileData).find("navMap"), pages = $(ncxFileData).find("pageList");
        return extractNavPointDataFromNode(nodes, pages);
    }
    /**
     * @param opfFileData {XMLDocument}
     * @returns {string}
     */
    function parseNCXReference(opfFileData) {
        var rtn = "", parsedOPFData = $(opfFileData), ncxItem = parsedOPFData.find("spine").attr("toc");
        return void 0 !== ncxItem ? (hasNCXFile = !0, rtn = getPathToPages() + parsedOPFData.find('manifest item[id="' + ncxItem + '"]').attr("href")) : hasNCXFile = !1, 
        rtn;
    }
    function convertOPFToAPIResponse(opfFileData) {
        function handleData(data, offset) {
            var idRef = $(spineNodes[offset]).attr("idref"), node = manifest.find('item[id="' + idRef + '"]'), pageEntry = {
                id: offset,
                index: offset,
                title: hasNCXFile ? "" : idRef,
                html_location: node.attr("href")
            };
            if (ActiveText.PageRangeHelper.isAllowedPageNumber(activeTextInstance, ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, offset)) ? results.push(pageEntry) : // if nothing is allowed in yet, and we haven't had an initial page, we need to start incrementing the
            // starting page number.
            0 === results.length && numberingOffsetIncrement++, offset += 1, offset < data.length) {
                var loopFunction = function() {
                    handleData(data, offset);
                };
                phantom || !ActiveText.BrowserUtils.isOldVersionOfInternetExplorer ? loopFunction() : requestAnimationFrame(loopFunction);
            } else rtn.resolve(results);
        }
        var rtn = $.Deferred(), parsedOPFData = $(opfFileData), spine = parsedOPFData.find("spine"), manifest = parsedOPFData.find("manifest"), metadata = parsedOPFData.find("metadata"), spineNodes = spine.find('itemref[linear!="no"]'), opfMeta = {}, results = [];
        return metadata = $(metadata).find(":not(meta)"), metadata.each(function(i) {
            var nodeName = metadata[i].nodeName;
            /* Strip DC namespace from tags */
            nodeName = nodeName.replace(/(\/?)([^:>\s]*:)?([^>]+)/g, "$1$3"), /* Check if the tag has content, if not return empty string */
            opfMeta[nodeName] = metadata[i].childNodes[0] ? metadata[i].childNodes[0].nodeValue : "";
        }), $(activeTextInstance).trigger(ActiveText.Events.OPF_META_LOADED, [ opfMeta ]), 
        handleData(spineNodes, 0), rtn;
    }
    function getOPFURL() {
        return cachedOPFURL || "";
    }
    function setOPFURL(url) {
        cachedOPFURL = url;
    }
    function getNCXURL() {
        return cachedNCXURL || "";
    }
    function setNCXURL(url) {
        cachedNCXURL = url;
    }
    function getPathToPages() {
        var splitPath = getOPFURL().split("/");
        return splitPath.pop(), splitPath.join("/") + "/";
    }
    function getPathToMETA() {
        return activeTextInstance.options.pathToAssets + "META-INF/";
    }
    function init() {
        var customSettingsParser = new ActiveText.CustomSettingsParser();
        customSettingsParser.init(activeTextInstance), $(activeTextInstance).on(ActiveText.Events.NAVMAP_LOADED, replacePageTitleWithPageNumber);
    }
    /**
     * Merges the NCX navLabel elements with the flat list of content from the OPF, and fires out an updated
     * list of content that includes information from both files.
     *
     * @param event {Event=}
     */
    function replacePageTitleWithPageNumber() {
        for (var opfPageList = activeTextInstance.data.getFlatListOfNavigation(), navLabels = $(ncxFileCache).find("pageList > pageTarget > navLabel > text"), i = 0; i < opfPageList.length; i++) opfPageList[i].title = $(navLabels[i]).text();
        $(activeTextInstance).trigger(ActiveText.Events.BOOK_STRUCTURE_LOADED, [ opfPageList ]), 
        ncxFileCache = null;
    }
    /**
     * @type {string}
     */
    var cachedNCXURL, cachedOPFURL, hasNCXFile, ncxFileCache, ua = navigator.userAgent, phantom = /phantom/i.test(ua), shouldCacheTheseFiles = ActiveText.Constants.USE_LOCAL_CACHE, numberingOffsetIncrement = 0;
    return ua.match(/mozilla/i) && (shouldCacheTheseFiles = !1), init(), {
        getSpineData: loadLocalSpineFile,
        getOPFURL: getOPFURL,
        setOPFURL: setOPFURL,
        getNCXURL: getNCXURL,
        setNCXURL: setNCXURL,
        getPathToPages: getPathToPages,
        getPathToMETA: getPathToMETA
    };
}, /* global ActiveText, ActiveText */
ActiveText.namespace("ActiveText.Hotspots"), ActiveText.Hotspots = function(hotspotFactory, options) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     */
    function init(activeTextInstance) {
        function teardown() {
            $(activeTextInstance.options.containerElement).off("remove", teardown), controller.teardown();
        }
        var controller = ActiveText.Hotspots.Controller(activeTextInstance, hotspotFactory, options);
        controller.init();
        var clickToPromptController = new ActiveText.ClickToPrompt();
        clickToPromptController.init(activeTextInstance), activeTextInstance.extensions.push(clickToPromptController), 
        activeTextInstance.options && activeTextInstance.options.containerElement && $(activeTextInstance.options.containerElement).on("remove", teardown);
    }
    return {
        init: init,
        key: "hotspots"
    };
}, /* global ActiveText, ActiveText, requestAnimationFrame, Modernizr */
ActiveText.Hotspots = ActiveText.Hotspots || {}, /**
 * @class Controller
 * @memberOf ActiveText.Hotspots
 * @param activeTextInstance {ActiveText}
 * @param hotspotFactory {Function}
 * @param options {*}
 * @returns {{}}
 * @constructor
 */
ActiveText.Hotspots.Controller = function(activeTextInstance, hotspotFactory, options) {
    "use strict";
    function init() {
        widgetController = new ActiveText.Widget.Controller(activeTextInstance), $(activeTextInstance).on(ActiveText.Events.LOADED_OVERLAY_DATA, addIconsToOverlay);
        var resizeFunction = ActiveText.ResizeUtils.getProportionalResizeBehaviour(activeTextInstance, LAYER_KEY);
        $(activeTextInstance).on(ActiveText.Events.RESIZE, resizeFunction), hotspotFactory && "function" == typeof hotspotFactory || (hotspotFactory = ActiveText.Hotspots.Factory.createHotspotIcon);
        var autoLaunchingWidgetController = new ActiveText.Hotspots.AutoLoadingWidgetsController(activeTextInstance, options);
        autoLaunchingWidgetController.init(api);
    }
    function teardown() {
        $(activeTextInstance).off(ActiveText.Events.LOADED_OVERLAY_DATA, addIconsToOverlay);
        var resizeFunction = ActiveText.ResizeUtils.getProportionalResizeBehaviour(activeTextInstance, LAYER_KEY);
        $(activeTextInstance).off(ActiveText.Events.RESIZE, resizeFunction);
    }
    function checkIfURILinksToAWidget(uri) {
        return -1 !== uri.indexOf("wdgt");
    }
    function accessibleClick(event) {
        /* jshint validthis:true */
        var keycode = event.keyCode ? event.keyCode : event.which;
        keycode === ActiveText.Keymap.ENTER && $(this).click();
    }
    /**
     * @param event {event}
     * @param overlayData {object}
     */
    function addIconsToOverlay(event, overlayData) {
        var overlayWrapperElement, newIcon, item, data = overlayData.data, index = overlayData.index, dimensions = activeTextInstance.view.model.getZoomAreaDimensions(), newIcons = [], len = data.length, uri = "";
        (1 !== data.length || "description" !== data[0].type) && (overlayWrapperElement = ActiveText.LayerUtils.getOverlayForIndexByKey(activeTextInstance, index, LAYER_KEY), 
        overlayWrapperElement.empty());
        for (var i = 0; len > i; i++) {
            if (item = data[i], item.data && item.data.uri && (uri = item.data.uri, item.data.parsedUri = ActiveText.DataUtils.parseURI(uri)), 
            item.widget = checkIfURILinksToAWidget(uri), //$.extend(item.data, dataParsedFromURI);
            item.type && ("hotspot" === item.type.toLowerCase() || "audio" === item.type.toLowerCase() ? newIcon = hotspotFactory(activeTextInstance, item, dimensions, options) : "target-area" === item.type.toLowerCase() && (newIcon = ActiveText.Hotspots.TargetAreaFactory.createTarget(item))), 
            newIcon && null !== newIcon) {
                if ($.browser.msie && !Modernizr.svg) {
                    var img = $(newIcon), src = img.attr("src");
                    img.attr("src", "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7").css("filter", 'progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled="true",sizingMethod="crop",src="' + src + '")');
                }
                newIcon.data(item), $(activeTextInstance).trigger("activetext.hotspot.created", {
                    hotspot: newIcon,
                    uri: uri
                }), newIcon.on({
                    click: _.debounce(hotspotClickHandler, 500, !0),
                    // debounce catches double clicks and turns them into single clicks
                    keypress: accessibleClick
                }), 0 === newIcon.find("polygon").length ? newIcon.attr({
                    tabindex: 100,
                    role: "button",
                    "aria-label": item.type
                }) : newIcon.find("polygon").attr({
                    tabindex: 100,
                    role: "button",
                    "aria-label": item.type
                }), newIcons.push(newIcon);
            }
            newIcon = null;
        }
        newIcons.length > 0 && (Modernizr.csstransforms ? $(newIcons).appendTo(overlayWrapperElement) : $(newIcons).each(function() {
            var wrapper = $('<div style="position:absolute;zoom:1;z-index:1;width:100%;filter:inherit"></div>');
            $(this).appendTo(wrapper), wrapper.appendTo(overlayWrapperElement);
        }), $(activeTextInstance).trigger(ActiveText.Events.RESIZE));
    }
    function callHotspotClickActionWithData(event, data) {
        options && options.hotspotClickFunction && "function" == typeof options.hotspotClickFunction ? /* jshint validthis:true */
        options.hotspotClickFunction(event, data) : debug.log("HotspotController click action called but no valid function attached.");
    }
    function widgetClickHandler(e, data) {
        return activeTextInstance.options.containerElement.css({
            zIndex: -1
        }), widgetController.openWidgetPopoverFromData(data);
    }
    function characterSelectClickHandler(e, data) {
        var uri = data.data.uri.toString(), characterName = ActiveText.Hotspots.Helper.returnCharacterFromUri(uri), $charTarget = $(e.target);
        $charTarget.hasClass("charSelect") && ($charTarget = $charTarget.children(":first")), 
        "character-selected" !== $charTarget.attr("class") && ActiveText.CharacterSelection.getCharacter() !== characterName ? ActiveText.CharacterSelection.setCharacter($charTarget, characterName) : "character-selected" === $charTarget.attr("class") && ActiveText.CharacterSelection.getCharacter() === characterName && ActiveText.CharacterSelection.deselectCharacter($charTarget, characterName);
    }
    function hotspotWithURISchemeClickHandler(e, data) {
        for (var rtn, src, pageIndex, target = data.data.uri, flatNavigation = activeTextInstance.data.getFlatListOfNavigation(), flatNavigationLength = flatNavigation.length, i = 0; flatNavigationLength > i; i++) src = flatNavigation[i].src, 
        -1 !== src.indexOf(target) && (pageIndex = i);
        if (pageIndex) {
            var pageNumber = ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, pageIndex);
            rtn = activeTextInstance.navigation.gotoPage(pageNumber);
        } else rtn = callHotspotClickActionWithData(e, data);
        return rtn;
    }
    /**
     * @param e {event}
     * @returns {boolean}
     */
    function hotspotClickHandler(e) {
        var rtn, uriString, clickToPrompt, data = $(this).data();
        if (data.widget === !0) $(activeTextInstance).trigger(ActiveText.Hotspots.Events.CLICKED, data), 
        rtn = widgetClickHandler(e, data); else if (data.data && data.data.uri) if (uriString = data.data.uri.toLowerCase(), 
        -1 !== uriString.indexOf("type=prompt")) clickToPrompt = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "clicktoprompt"), 
        clickToPrompt ? rtn = clickToPrompt.hotspotClickFunction(e, data) : debug.log("Click To Prompt Hotspot was clicked, but no ClickToPrompt controller was found."); else if (-1 !== uriString.indexOf("type=audio")) {
            //use click to promopt to serve hotspot audio
            clickToPrompt = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "clicktoprompt");
            var audioPlayback = ActiveText.ExtensionUtils.getAudioPlayback(activeTextInstance);
            clickToPrompt && audioPlayback.playing() === !1 ? rtn = clickToPrompt.hotspotClickFunction(e, data) : debug.log("Click To Prompt Hotspot was clicked, but no ClickToPrompt controller was found.");
        } else -1 !== uriString.indexOf("character") ? rtn = characterSelectClickHandler(e, data) : ($(activeTextInstance).trigger(ActiveText.Hotspots.Events.CLICKED, data), 
        rtn = hotspotWithURISchemeClickHandler(e, data)); else $(activeTextInstance).trigger(ActiveText.Hotspots.Events.CLICKED, data), 
        rtn = callHotspotClickActionWithData(e, data);
        return rtn;
    }
    /**
     * @const
     * @type {string}
     */
    var widgetController, LAYER_KEY = "standalone_hotspots", api = {
        init: init,
        teardown: teardown,
        hotspotClickHandler: hotspotClickHandler
    };
    return api;
}, /* global ActiveText */
ActiveText.Hotspots.Events = {
    CLICKED: "hotspot.clicked"
}, /* global ActiveText, ActiveText */
ActiveText.namespace("ActiveText.Hotspots.Factory"), ActiveText.Hotspots.Factory = function() {
    "use strict";
    /**
     * @param activeTextInstance {object}
     * @param hotspotDataObject {object}
     * @param containerDimensions {object}
     * @returns {*|jQuery}
     */
    function createHotspotIcon(activeTextInstance, hotspotDataObject, containerDimensions) {
        var iconWidth = 64, hotspotImageFilename = ActiveText.Hotspots.Helper.getDefaultFilenameFromHotspotData(hotspotDataObject, "amiga"), htmlString = "<img class='hotspot_icon noSwipe' src='" + ActiveText.SkinUtils.getPathToGlobalResource() + "img/" + hotspotImageFilename + "' width='" + iconWidth + "' height='" + iconWidth + "' />";
        return $(htmlString).css(ActiveText.Hotspots.Helper.getHotspotPositioningStyles(hotspotDataObject, iconWidth, containerDimensions));
    }
    return {
        createHotspotIcon: createHotspotIcon
    };
}(), /* global ActiveText, Modernizr */
ActiveText.Hotspots.TargetAreaFactory = function() {
    "use strict";
    function createTarget(item) {
        var uriString, targetArea, selectedCharName = ActiveText.CharacterSelection.getCharacter(), uriCharName = "", charIDString = 'id=""', classNameString = 'class=""', targetAreaClass = "";
        if (item.data.uri && (uriString = item.data.uri.toString(), -1 !== uriString.indexOf("type=prompt") ? (targetAreaClass = "ctp noSwipe", 
        charIDString = 'id="' + uriCharName + '"') : -1 !== uriString.indexOf("character") ? (uriCharName = ActiveText.Hotspots.Helper.returnCharacterFromUri(uriString), 
        charIDString = 'id="' + uriCharName + '"', targetAreaClass = "charSelect") : targetAreaClass = "otherTA"), 
        "" !== selectedCharName && selectedCharName === uriCharName && (classNameString = 'class="character-selected"'), 
        "polygon" === item.data.shape) {
            var svgData = $('<svg class="target-area noSwipe ' + targetAreaClass + '" version="1.1" xmlns="http://www.w3.org/2000/svg" width="' + item.data.width + '" height="' + item.data.height + '" viewBox="0 0 ' + item.data.width + " " + item.data.height + '"><polygon ' + charIDString + " " + classNameString + ' fill-opacity="0.5" fill="' + item.data.fill + '" stroke="' + item.data.stroke + '" points="' + item.data.points + '" visibility="visible" style="cursor:pointer;pointer-events:visible;"/></svg>');
            targetArea = svgData, targetArea.css({
                width: parseInt(item.data.width, 10),
                height: parseInt(item.data.height, 10),
                position: ActiveText.BrowserUtils.isOldVersionOfInternetExplorer ? "relative" : "absolute",
                marginTop: parseInt(item.data.y, 10),
                marginLeft: parseInt(item.data.x, 10),
                cursor: "default",
                pointerEvents: "none",
                overflow: "hidden"
            });
        } else targetArea = $('<div class="target-area noSwipe ' + targetAreaClass + '"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" width="' + item.data.width + '"  height="' + item.data.height + '" ' + charIDString + " " + classNameString + " /></div>"), 
        targetArea.css({
            width: parseInt(item.data.width, 10),
            height: parseInt(item.data.height, 10),
            position: ActiveText.BrowserUtils.isOldVersionOfInternetExplorer ? "relative" : "absolute",
            marginTop: parseInt(item.data.y, 10),
            marginLeft: parseInt(item.data.x, 10),
            cursor: "pointer",
            pointerEvents: "all",
            overflow: "hidden"
        });
        return item.data && item.data.id && targetArea.attr("id", item.data.id), targetArea;
    }
    return {
        createTarget: createTarget
    };
}(), /* global ActiveText */
ActiveText.Hotspots.Helper = function() {
    "use strict";
    function getHotspotPositioningStyles(hotspotDataObject, iconWidth) {
        var xPos = hotspotDataObject.data.point[0], yPos = hotspotDataObject.data.point[1], position = "absolute";
        return ActiveText.BrowserUtils.isOldVersionOfInternetExplorer && (position = "relative"), 
        {
            marginLeft: xPos - iconWidth / 2,
            marginTop: yPos - iconWidth / 2,
            pointerEvents: "all",
            position: position,
            zIndex: 1010,
            cursor: "pointer"
        };
    }
    /**
     * @param hotspotDataObject
     * @param defaultValue {string}
     * @returns {string}
     */
    function getDefaultFilenameFromHotspotData(hotspotDataObject, defaultValue) {
        var icon = defaultValue;
        return hotspotDataObject && hotspotDataObject.data && hotspotDataObject.data.icon && (icon = hotspotDataObject.data.icon), 
        icon + "-default.png";
    }
    function returnCharacterFromUri(uri) {
        return uri.replace(/[\bcharacter\b]*[^\w-]/gi, "");
    }
    return {
        getHotspotPositioningStyles: getHotspotPositioningStyles,
        getDefaultFilenameFromHotspotData: getDefaultFilenameFromHotspotData,
        returnCharacterFromUri: returnCharacterFromUri
    };
}(), /* global ActiveText, ActiveText, requestAnimationFrame, Modernizr */
ActiveText.Hotspots.AutoLoadingWidgetsController = function(activeTextInstance, options) {
    "use strict";
    function init(parent) {
        if (controller = parent, options && options.autoPop && "function" == typeof options.autoPop) {
            /*jshint validthis: true */
            var newData = options.autoPop.call(this);
            Modernizr.csstransitions && Modernizr.csstransforms3d ? activeTextInstance.options.allowAnimation ? $(activeTextInstance).on(ActiveText.Events.ANIMATE_PAGE_END, function() {
                handleAutoPop(newData);
            }) : $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, function() {
                handleAutoPop(newData);
            }) : //ie<10 needs to trigger the FRAME_CONTENT_LOADED event as will never see ANIMATE_PAGE_END event.
            $(activeTextInstance).on(ActiveText.Events.FRAME_CONTENT_LOADED, function() {
                handleAutoPop(newData);
            });
        }
    }
    function checkIfURILinksToAWidget(uri) {
        return -1 !== uri.indexOf("wdgt");
    }
    /**
     * @param popData {object}
     */
    function handleAutoPop(popData) {
        var pageIndex = activeTextInstance.model.getCurrentIndex();
        if (pageIndex === popData.index && haveShownPopUp === !1) {
            var uri, item = popData.data[0];
            item.data && item.data.uri && (uri = item.data.uri, item.data.parsedUri = ActiveText.DataUtils.parseURI(uri)), 
            item.widget = checkIfURILinksToAWidget(uri);
            var hotspot = ActiveText.Hotspots.TargetAreaFactory.createTarget(item);
            hotspot.data(item), controller.hotspotClickHandler.apply(hotspot, [ {
                type: "click",
                currentTarget: hotspot
            } ]), haveShownPopUp = !0;
        }
    }
    var controller, haveShownPopUp = !1;
    return options = options || activeTextInstance.options, {
        init: init
    };
}, /* global ActiveText, ActiveText, requestAnimationFrame */
ActiveText.Widget = ActiveText.Widget || {}, /**
 * @class Controller
 * @memberOf ActiveText.Widget
 * @param activeTextInstance {ActiveText}
 * @returns {{openWidgetPopoverFromData: openWidgetPopoverFromData, getWidgetById: getWidgetById}}
 * @constructor
 */
ActiveText.Widget.Controller = function(activeTextInstance) {
    "use strict";
    function openWidgetPopoverFromData(data) {
        var hotspotId = getUniqueIdentifierFromData(data), existingDialog = existingDialogs[hotspotId];
        if (void 0 === existingDialog) {
            var newWidget = widgetFactory.createWidgetFromData(activeTextInstance, data.data);
            newWidget.dialog().dialog("widget").css({
                opacity: 0,
                transform: "scale(0.8)"
            }).on("dialogbeforeclose", function() {
                existingDialogs[hotspotId] = void 0;
            }), setTimeout(function() {
                newWidget.dialog().dialog("widget").css({
                    transform: "scale(1)",
                    opacity: 1
                });
            }, 100), existingDialogs[hotspotId] = newWidget;
        } else existingDialog.dialog("open"), requestAnimationFrame(function() {
            existingDialog.dialog().dialog("widget").css({
                transform: "scale(1.1)"
            }), setTimeout(function() {
                existingDialog.dialog().dialog("widget").css({
                    transform: "scale(1)"
                });
            }, 300);
        });
        return !1;
    }
    function getWidgetById(id) {
        return existingDialogs[id];
    }
    function getUniqueIdentifierFromData(data) {
        var rtn = data.data.id;
        return rtn || (rtn = data.data.uri), rtn;
    }
    /**
     * @type {ActiveText.Widget.Factory}
     */
    var widgetFactory = ActiveText.Widget.Factory;
    widgetFactory.insertCSS(activeTextInstance);
    /**
     * This is a dictionary object which uses the data object as a key to reference dialogs
     * which have been opened by clicking on a hotspot.
     *
     * @type {object}
     */
    var existingDialogs = {};
    return {
        openWidgetPopoverFromData: openWidgetPopoverFromData,
        getWidgetById: getWidgetById
    };
}, /* global ActiveText, ActiveText */
ActiveText.Widget = ActiveText.Widget || {}, ActiveText.Widget.Helper = function(ActiveText) {
    "use strict";
    /**
     * If supplied a number-as-a-string, we need to add 'px' to the value,
     * unless of course, the value is already a px value or a percentage.
     *
     * @param value {string|number}
     * @returns {string|number}
     */
    function fixCoordinateValue(value) {
        return "string" == typeof value && -1 === value.indexOf("px") && -1 === value.indexOf("%") && (value += "px"), 
        value;
    }
    function attachBehavioursToAllowSmoothResizeWithIFrameToDialog(dialog) {
        dialog.bind("dialogdragstart dialogresizestart", function() {
            var overlay, modal;
            ActiveText.BrowserUtils.isOldVersionOfInternetExplorer === !0 && (modal = $('<div class="dialog-resize-modal"></div>'), 
            modal.fadeTo(0, 0), $(this).parent().before(modal)), overlay = $(this).find(".hidden-dialog-overlay"), 
            0 === overlay.length ? (overlay = $('<div class="hidden-dialog-overlay"></div>'), 
            overlay.appendTo(this)) : overlay.show();
        }).bind("dialogdragstop dialogresizestop", function() {
            var data = dialog.data();
            data.position = "absolute", data.x = dialog.css("left"), data.y = dialog.css("top"), 
            data.w = data.width = dialog.css("width"), data.h = data.height = dialog.css("height"), 
            dialog.data(data), ActiveText.BrowserUtils.isOldVersionOfInternetExplorer === !0 && $(this).parent().parent().find(".dialog-resize-modal").remove(), 
            $(this).find(".hidden-dialog-overlay").hide();
        });
    }
    function parseResizeValue(parsedUri) {
        var canResize = !0;
        return void 0 !== parsedUri.resizable && parsedUri.resizable === !1 && (canResize = !1), 
        void 0 !== parsedUri.size && (canResize = !1), canResize;
    }
    function parseModalValue(parsedUri) {
        var isModal = !1;
        return void 0 !== parsedUri.modal && Boolean(parsedUri.modal) === !0 && (isModal = !0), 
        isModal;
    }
    function parseChromelessValue(parsedUri) {
        var isChromeLess = parsedUri.chromeless && "true" === parsedUri.chromeless.toString() || parsedUri.transparent && "true" === parsedUri.transparent.toString();
        return isChromeLess;
    }
    function parseCustomCloseValue(parsedUri) {
        var hasCustomClose = parsedUri.customClose && "true" === parsedUri.customClose.toString();
        return hasCustomClose;
    }
    function parsePositionValue(parsedUri) {
        var dialogPosition = "center";
        return (parsedUri.x || parsedUri.y) && (dialogPosition = [ parsedUri.x, parsedUri.y ]), 
        dialogPosition;
    }
    /**
     * @param data {object}
     * @returns {{width: number, height: number}}
     */
    function calculateWidgetSize(container, data) {
        var width = DEFAULT_DIALOG_WIDTH, height = DEFAULT_DIALOG_HEIGHT, plist = data.plist, parsedUri = data.parsedUri || {};
        //        if(width === DEFAULT_DIALOG_WIDTH && height === DEFAULT_DIALOG_HEIGHT)
        //        {
        //            parsedUri.size = '100%';
        //        }
        if (plist && (plist.Height && (height = parseInt(plist.Height, 10)), plist.Width && (width = parseInt(plist.Width, 10))), 
        parsedUri.height ? height = parseInt(parsedUri.height, 10) : parsedUri.h && (height = parseInt(parsedUri.h, 10)), 
        parsedUri.width ? width = parseInt(parsedUri.width, 10) : parsedUri.w && (width = parseInt(parsedUri.w, 10)), 
        parsedUri.size) {
            var ratio = width / height, size = parseInt(parsedUri.size, 10) / 100, heightOfToolbar = HEIGHT_OF_TITLEBAR;
            ("true" === parsedUri.chromeless || "true" === parsedUri.transparent) && (heightOfToolbar = 0), 
            height = ($(container).height() - heightOfToolbar) * size, width = height * ratio, 
            width > $(container).width() && (width = $(container).width() * size, height = width / ratio);
        }
        return {
            width: width,
            height: height
        };
    }
    /**
     * @const
     * @type {number}
     */
    var DEFAULT_DIALOG_WIDTH = 480, DEFAULT_DIALOG_HEIGHT = 320, HEIGHT_OF_TITLEBAR = 31;
    return {
        fixCoordinateValue: fixCoordinateValue,
        attachBehavioursToAllowSmoothResizeWithIFrameToDialog: attachBehavioursToAllowSmoothResizeWithIFrameToDialog,
        parseResizeValue: parseResizeValue,
        parseModalValue: parseModalValue,
        parseChromelessValue: parseChromelessValue,
        parsePositionValue: parsePositionValue,
        calculateWidgetSize: calculateWidgetSize,
        parseCustomCloseValue: parseCustomCloseValue
    };
}(ActiveText), /* global ActiveText, ActiveText, Modernizr */
ActiveText.Widget = ActiveText.Widget || {}, ActiveText.Widget.CloseButtonFactory = function() {
    "use strict";
    function createCloseButton(pathToResources) {
        function touchDown() {
            closeButton.attr("src", downState);
        }
        function mouseOver() {
            closeButton.attr("src", hoverState);
        }
        function mouseOut() {
            closeButton.attr("src", upState);
        }
        var closeButton, cssString = ".chromeless-closebutton{-webkit-tap-highlight-color:rgba(0,0,0,0);width: 30px;height: 30px;margin-left: -15px;margin-right: -15px;margin-top: -15px;}";
        if (Modernizr.svg) {
            cssString += ".chromeless-closebutton svg:hover circle {fill:#666666;}.chromeless-closebutton svg:active circle {fill:#ff0000;}";
            var svgSource = '<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px"width="30.202px" height="30.201px" viewBox="0 0 30.202 30.201" enable-background="new 0 0 30.202 30.201" xml:space="preserve"><circle fill="#010101" stroke="#FFFFFF" stroke-width="2" stroke-miterlimit="10" cx="15.101" cy="15.101" r="14.101"/><g><path fill="#FFFFFF" d="M10.654,20.815L9.58,19.74c-0.451-0.454-0.451-0.866-0.039-1.279l3.389-3.391L9.541,11.68C9.129,11.267,9.129,10.855,9.58,10.4l1.074-1.076c0.455-0.453,0.891-0.475,1.303-0.061l3.391,3.391l3.391-3.391c0.412-0.414,0.824-0.414,1.28,0.041l1.072,1.075c0.477,0.476,0.477,0.888,0.061,1.3l-3.39,3.391l3.39,3.391c0.414,0.412,0.393,0.845-0.061,1.3l-1.074,1.076c-0.455,0.455-0.869,0.455-1.281,0.041l-3.39-3.39l-3.391,3.39C11.544,21.291,11.132,21.291,10.654,20.815z"/></g></svg>';
            closeButton = $('<div class="chromeless-closebutton">' + svgSource + "</div>");
        } else {
            var upState = pathToResources + "img/close_button.png", hoverState = pathToResources + "img/close_button_hover.png", downState = pathToResources + "img/close_button_down.png";
            closeButton = $('<img src="' + upState + '" width="30" height="30" class="chromeless-closebutton" />'), 
            closeButton.on({
                mouseover: mouseOver,
                mouseout: mouseOut,
                mousedown: touchDown,
                touchstart: touchDown,
                touchend: mouseOut
            });
        }
        return ActiveText.CSSUtils.embedCSS(cssString, "chromeless-closebutton"), closeButton;
    }
    return {
        createCloseButton: createCloseButton
    };
}(), /* global ActiveText, ActiveText */
/**
 * @class PListObject
 * @type {{Width:number, Height:number, CloseBoxInsetX:number, CloseBoxInsetY:number, CFBundleDisplayName:string}}
 */
ActiveText.Widget = ActiveText.Widget || {}, /**
 * @class Factory
 * @memberOf ActiveText.Widget
 * @type {{insertCSS:function, createWidgetFromData:function}}
 */
ActiveText.Widget.Factory = function() {
    "use strict";
    function insertCSS(activeTextInstance) {
        ActiveText.CSSUtils.embedCSS(ActiveText.DialogStyleText.getStyle(activeTextInstance), "standalone-widget");
    }
    function onPListLoadError() {}
    function createWidgetFromData(activeTextInstance, hotspotData, cssClass) {
        /**
         * @param event {event}
         * @param ui {object}
         */
        function createHandler() {
            try {
                /* jshint validthis:true */
                var dialog = $(this).dialog("widget"), data = $(this).data();
                setDialogPosition(dialog, data), sendMessageToParent(), dialog.find(".ui-dialog-titlebar").removeClass("ui-corner-all").addClass("ui-corner-top"), 
                dialog.removeClass("ui-corner-all").addClass("ui-corner-top"), dialog.find(".ui-widget-content").css("overflow", "hidden");
            } catch (err) {}
        }
        function resizeDialog(dialog, containerElement, data) {
            var css = {}, dialogContainer = $(dialog), dialogElement = $(".ui-dialog");
            dialogContainer.availHeight = ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance).availHeight, 
            // always resize if it's core widget - ratio is set above
            (dialogElement.height() > dialogContainer.availHeight || data.coreWidget) && (ActiveText.ViewUtils.scaleHTMLElement(activeTextInstance, dialog, dialog.ratio.height), 
            dialog.css("transformOrigin", "50% 50%")), (dialogElement.width() > containerElement.width() || data.coreWidget) && (ActiveText.ViewUtils.scaleHTMLElement(activeTextInstance, dialog, dialog.ratio.width), 
            dialog.css("transformOrigin", "50% 50%")), ("center" === data.position || void 0 === data.position) && (dialog.position.top = dialog.offset.top + (containerElement.height() - dialog.height()) / 2 - 1, 
            dialog.position.left = dialog.offset.left + (containerElement.width() - dialog.width()) / 2), 
            dialog.position.left && (css.left = helper.fixCoordinateValue(dialog.position.left) + "px"), 
            dialog.position.top && (dialog.position.top < 0 && dialogContainer.hasClass("chromeless") && (dialog.position.top += 20), 
            css.top = helper.fixCoordinateValue(dialog.position.top) + "px"), dialogContainer.css(css);
        }
        function sendMessageToParent() {
            window.parent.postMessage("widget-opened", "*");
        }
        function setDialogPosition(dialog, hotspotData) {
            var containerElement = $(window);
            activeTextInstance && (containerElement = activeTextInstance.options.containerElement.find(".whiteboard-container")), 
            dialog.offset = containerElement.offset(), closeButton && positionTheCloseButtonBasedOnThePList(hotspotData);
            var data = hotspotData || {};
            dialog.position = {}, data.hasOwnProperty("parsedUri") && (dialog.position.left = data.parsedUri.x, 
            dialog.position.top = data.parsedUri.y);
            var dimensions = helper.calculateWidgetSize(containerElement, data), elementToScaleHeight = data.coreWidget ? dialog : dialog.find(".ui-widget-content");
            dialog.width(dimensions.width), elementToScaleHeight.height(dimensions.height), 
            data.coreWidget = void 0 !== data.coreWidget ? data.coreWidget : !0, // set default resizing ratios
            dialog.ratio = {
                width: containerElement.width() / dialog.width(),
                height: containerElement.height() / dialog.height()
            }, // tweak in case it's a core widget
            data.coreWidget && (dialog.ratio.width = Math.min(dialog.ratio.width, 1), dialog.ratio.height = Math.min(dialog.ratio.height, 1)), 
            ("center" === data.position || void 0 === data.position) && (dialog.position.top = dialog.offset.top + (containerElement.height() - dialog.height()) / 2 - 1, 
            dialog.position.left = dialog.offset.left + (containerElement.width() - dialog.width()) / 2);
            var css = {}, dialogContainer = $(dialog);
            dialog.position.left && (css.left = helper.fixCoordinateValue(dialog.position.left) + "px"), 
            dialog.position.top && (dialog.position.top < 0 && dialogContainer.hasClass("chromeless") && (dialog.position.top += 20), 
            css.top = helper.fixCoordinateValue(dialog.position.top) + "px"), dialogContainer.css(css), 
            setTimeout(function() {
                resizeDialog(dialog, containerElement, data);
            }, 500);
        }
        function loadPListFile(basePath) {
            var path = basePath.split("/");
            path.pop();
            var baseURL = path.join("/");
            $.ajax({
                url: baseURL + "/Info.plist",
                dataType: "text xml",
                success: onPListLoadSuccess,
                error: onPListLoadError
            });
        }
        /**
         * @param hotspotData {{plist:PListObject}}
         */
        function positionTheCloseButtonBasedOnThePList(hotspotData) {
            if (hotspotData && hotspotData.plist) {
                /**
                 * The offset needed to find the centre of the image (width/2)
                 *
                 * @type {number}
                 * @const
                 */
                var closePosX, closePosY, scale, CLOSE_BUTTON_CENTREPOINT_OFFSET = 15;
                void 0 !== hotspotData.plist.CloseBoxInsetX && (closePosX = parseInt(hotspotData.plist.CloseBoxInsetX, 10) + CLOSE_BUTTON_CENTREPOINT_OFFSET, 
                closeButton.css("left", closePosX - 2 * CLOSE_BUTTON_CENTREPOINT_OFFSET + "px")), 
                void 0 !== hotspotData.plist.CloseBoxInsetY && (closePosY = parseInt(hotspotData.plist.CloseBoxInsetY, 10) + CLOSE_BUTTON_CENTREPOINT_OFFSET, 
                closeButton.css("top", closePosY - 2 * CLOSE_BUTTON_CENTREPOINT_OFFSET + "px"));
                var actualDimensions = helper.calculateWidgetSize(activeTextInstance.options.containerElement.find(".whiteboard-container"), hotspotData), plistWidth = parseInt(hotspotData.plist.Width, 10), plistHeight = parseInt(hotspotData.plist.Height, 10);
                void 0 !== plistWidth && void 0 !== closePosX && actualDimensions.width !== plistWidth && (scale = actualDimensions.width / plistWidth, 
                closeButton.css("left", (closePosX - CLOSE_BUTTON_CENTREPOINT_OFFSET) * scale + "px")), 
                void 0 !== plistHeight && void 0 !== closePosY && actualDimensions.height !== plistHeight && (scale = actualDimensions.height / plistHeight, 
                // - (30 / scale)
                closeButton.css("top", (closePosY - CLOSE_BUTTON_CENTREPOINT_OFFSET) * scale + "px"));
            }
        }
        function onPListLoadSuccess(xmlData) {
            for (var dict = $(xmlData).find("dict").children(), keyPairs = {}, i = 0, l = dict.length; l > i; i++) keyPairs[$(dict[i]).text()] = $(dict[i + 1]).text(), 
            i++;
            if (hotspotData.plist = keyPairs, dialog) {
                hotspotData.coreWidget = -1 !== keyPairs.CFBundleIdentifier.indexOf("com.Pearson"), 
                dialog.data(hotspotData);
                var isAChromelessDialog = "true" !== hotspotData.parsedUri.transparent && "true" !== hotspotData.parsedUri.chromeless, aTitleIsDefinedInThePList = void 0 !== keyPairs.CFBundleDisplayName;
                isAChromelessDialog && aTitleIsDefinedInThePList && dialog.dialog("option", "title", keyPairs.CFBundleDisplayName);
                try {} catch (err) {}
            }
        }
        function onWindowResize(event) {
            var dialog = event.data.dialog, dialogData = dialog.data();
            if ("absolute" !== dialogData.position) try {
                var widget = dialog.dialog("widget");
                setTimeout(function() {
                    setDialogPosition(widget, dialogData);
                }, 500);
            } catch (err) {}
        }
        function closeHandler() {
            /* jshint validthis:true */
            //                        try
            //                        {
            activeTextInstance.options.containerElement.css({
                zIndex: 1
            }), $(this).empty().dialog().dialog("destroy").remove();
        }
        function makeTheContentVisible() {
            /* jshint validthis:true */
            $(this).css("visibility", "");
        }
        var pathToSourcePages = activeTextInstance.loader.getDataProvider().getPathToPages(), pathToWidgetContents = hotspotData.widgetpath, widgetPath = pathToSourcePages + pathToWidgetContents;
        pathToWidgetContents || void 0 === hotspotData.uri || (pathToWidgetContents = hotspotData.uri, 
        widgetPath = "ATX-autoPop" === hotspotData.id ? pathToWidgetContents : pathToSourcePages + pathToWidgetContents);
        var iframeString = '<iframe id="widget-iframe" frameborder="0" allowtransparency="true" scrolling="no" width="100%" height="100%" seamless></iframe>', iframeElement = $(iframeString).load(makeTheContentVisible).attr("src", widgetPath);
        ActiveText.BrowserUtils.isOldVersionOfInternetExplorer || iframeElement.css("visibility", "hidden");
        var template = $('<div class="activetext-widget" />');
        iframeElement.appendTo(template);
        var closeButton, parsedUri = hotspotData.parsedUri, isResizable = helper.parseResizeValue(parsedUri), isModal = helper.parseModalValue(parsedUri), isChromeLess = helper.parseChromelessValue(parsedUri), hasCustomClose = helper.parseCustomCloseValue(parsedUri), dialogPosition = helper.parsePositionValue(parsedUri), dialogClass = cssClass || "widget-dialog";
        isChromeLess && (dialogClass += " chromeless", isResizable = !1);
        var dimensions = helper.calculateWidgetSize(activeTextInstance.options.containerElement.find(".whiteboard-container"), hotspotData), dialog = template.dialog({
            width: dimensions.width,
            height: dimensions.height,
            title: parsedUri.title || void 0,
            modal: isModal,
            dialogClass: dialogClass,
            position: dialogPosition,
            resizable: isResizable,
            close: closeHandler,
            open: createHandler,
            autoOpen: !1,
            closeOnEscape: isChromeLess
        }).data(hotspotData);
        if (isChromeLess && !hasCustomClose) {
            var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance);
            closeButton = ActiveText.Widget.CloseButtonFactory.createCloseButton(pathToResources), 
            closeButton.click(function() {
                dialog.dialog("close");
            }), dialog.parent().append(closeButton);
        }
        return dialog.css({
            boxShadow: "none"
        }), helper.attachBehavioursToAllowSmoothResizeWithIFrameToDialog(dialog), dialog.dialog("open"), 
        loadPListFile(widgetPath), $(activeTextInstance).on(ActiveText.Events.RESIZE, {
            dialog: dialog
        }, onWindowResize), dialog;
    }
    /**
     * @type {ActiveText.Widget.Helper}
     */
    var helper = ActiveText.Widget.Helper;
    return {
        insertCSS: insertCSS,
        createWidgetFromData: createWidgetFromData
    };
}();

/* global ActiveText, ActiveText */
var ActiveLearn = ActiveLearn || {};

ActiveLearn.HotspotsFactory = function() {
    "use strict";
    /**
     * @param activeTextInstance {object}
     * @param hotspotDataObject {object}
     * @param containerDimensions {object}
     * @returns {*|jQuery}
     */
    function createResourceIcon(activeTextInstance, hotspotDataObject, containerDimensions) {
        ActiveText.CSSUtils.embedCSS(".hotspot_icon div{cursor:pointer !important;}", "activelearn-hotspots");
        var iconWidth = 60, hotspotImageFilename = ActiveText.Hotspots.Helper.getDefaultFilenameFromHotspotData(hotspotDataObject, "activelearn-doc"), htmlString = '<div class="hotspot_icon"><img class="hotspot_icon" src="' + ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/activelearn/hotspots/" + hotspotImageFilename + '" width="' + iconWidth + '" height="' + iconWidth + '" /></div>', newElement = $(htmlString), dimensionsData = ActiveText.Hotspots.Helper.getHotspotPositioningStyles(hotspotDataObject, iconWidth, containerDimensions);
        return newElement.css(dimensionsData), newElement;
    }
    return {
        createResourceIcon: createResourceIcon
    };
}();

/* global ActiveText, Modernizr */
var ActiveLearn = ActiveLearn || {};

ActiveLearn.Controls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        var controls = new ActiveText.UI.BasicControls(activeTextInstance, {
            leftButtons: leftButtons,
            rightButtons: rightButtons,
            openByDefault: !0,
            overlay: !1,
            barHeight: 50,
            barStyles: {
                background: "#FCFCFC",
                lineHeight: "50px",
                fontSize: 0,
                borderTop: "1px solid #E6E5E5",
                borderBottom: "1px solid #E6E5E5"
            },
            buttonStyles: {
                background: "#FCFCFC",
                borderRadius: 0,
                barClass: "activelearn",
                borderBottom: "1px solid #E6E5E5"
            },
            hoverStyles: {
                background: "white"
            },
            options: {
                contents: {
                    popupnavwidth: 300,
                    style: {
                        width: 50,
                        height: 49
                    }
                },
                pagenumber: {
                    style: {
                        borderLeft: "1px solid #E6E5E5"
                    }
                }
            }
        });
        return activeTextInstance.extensions.push(controls), $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, function() {
            var fullWindowScalingMode = activeTextInstance.utils.isFullWindowScalingMode(), mobileDevice = ActiveText.BrowserUtils.isMobileDevice;
            if (fullWindowScalingMode && mobileDevice) {
                var rotationControl = new ActiveText.ViewOrientationDetection();
                rotationControl.init(activeTextInstance), activeTextInstance.extensions.push(rotationControl);
            }
        }), void 0 === activeTextInstance.options.allowOverlap && (activeTextInstance.options.allowOverlap = !1), 
        activeTextInstance.options.containerCoordinates = {
            top: 10,
            right: 0,
            bottom: 10,
            left: 0
        }, ActiveLearn.StylesHelper.embedStyles(activeTextInstance), controls;
    }
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "drawing,note,viewtoggle,zoom", rightButtons = options.rightButtons ? options.rightButtons : "contents,pagenumber,previous,next";
    return {
        init: init,
        key: "activelearncontrols"
    };
};

/* global ActiveText, Modernizr */
var ActiveLearn = ActiveLearn || {};

ActiveLearn.LegacyControls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        var pathPrefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/activelearn/", controls = new ActiveText.UI.BasicControls(activeTextInstance, {
            leftButtons: leftButtons,
            rightButtons: rightButtons,
            leftButtonOptions: {
                left: "10px"
            },
            rightButtonOptions: {
                right: "10px"
            },
            openByDefault: !0,
            overlay: !1,
            barHeight: 39,
            barStyles: {
                backgroundColor: "#4885A2",
                backgroundImage: "url(" + pathPrefix + "bar_bg.png)",
                backgroundRepeat: "repeat-x",
                lineHeight: "30px"
            },
            minWidth: 380,
            scaleMode: "scale",
            buttonStyles: {
                width: 32,
                height: 32,
                background: "transparent"
            },
            hoverStyles: {
                background: "transparent"
            },
            options: {
                drawing: {
                    imageSrc: pathPrefix + "drawing-up.png",
                    hoverImageSrc: pathPrefix + "drawing-over.png",
                    downImageSrc: pathPrefix + "drawing-down.png",
                    toggleButtonImageSrc: pathPrefix + "drawing-down.png",
                    toggleButtonHoverImageSrc: pathPrefix + "drawing-over.png",
                    toggleButtonDownImageSrc: pathPrefix + "drawing-down.png"
                },
                note: {
                    imageSrc: pathPrefix + "note-up.png",
                    hoverImageSrc: pathPrefix + "note-over.png",
                    downImageSrc: pathPrefix + "note-down.png",
                    toggleButtonImageSrc: pathPrefix + "note-down.png",
                    toggleButtonHoverImageSrc: pathPrefix + "note-over.png",
                    toggleButtonDownImageSrc: pathPrefix + "note-down.png"
                },
                viewtoggle: {
                    imageSrc: pathPrefix + "double-page-up.png",
                    hoverImageSrc: pathPrefix + "double-page-over.png",
                    downImageSrc: pathPrefix + "double-page-down.png",
                    toggleButtonImageSrc: pathPrefix + "single-page-up.png",
                    toggleButtonHoverImageSrc: pathPrefix + "single-page-over.png",
                    toggleButtonDownImageSrc: pathPrefix + "single-page-down.png"
                },
                zoom: {
                    imageSrc: pathPrefix + "zoom-out-up.png",
                    hoverImageSrc: pathPrefix + "zoom-out-over.png",
                    downImageSrc: pathPrefix + "zoom-out-down.png",
                    toggleButtonImageSrc: pathPrefix + "zoom-in-up.png",
                    toggleButtonHoverImageSrc: pathPrefix + "zoom-in-over.png",
                    toggleButtonDownImageSrc: pathPrefix + "zoom-in-down.png"
                },
                contents: {
                    style: {
                        width: 76,
                        height: 32
                    },
                    width: 76,
                    height: 32,
                    imageSrc: pathPrefix + "contents-up.png",
                    hoverImageSrc: pathPrefix + "contents-over.png",
                    downImageSrc: pathPrefix + "contents-down.png",
                    toggleButtonImageSrc: pathPrefix + "contents-down.png",
                    toggleButtonHoverImageSrc: pathPrefix + "contents-over.png",
                    toggleButtonDownImageSrc: pathPrefix + "contents-down.png"
                },
                quicknav: {
                    style: {
                        border: "none",
                        background: "transparent url(" + pathPrefix + "quicknav.png) 0 3px no-repeat",
                        width: 108,
                        padding: "11px 0 8px 0",
                        "vertical-align": "middle"
                    },
                    popupnavwidth: 293,
                    textFormatSinglePage: "%%1 of %%2",
                    textFormatMultiPage: "%%1/%%2 of %%3"
                },
                previous: {
                    style: {
                        width: 33,
                        height: 32
                    },
                    imageSrc: pathPrefix + "prev-up.png",
                    hoverImageSrc: pathPrefix + "prev-over.png",
                    downImageSrc: pathPrefix + "prev-down.png"
                },
                next: {
                    style: {
                        width: 33,
                        height: 32
                    },
                    imageSrc: pathPrefix + "next-up.png",
                    hoverImageSrc: pathPrefix + "next-over.png",
                    downImageSrc: pathPrefix + "next-down.png"
                }
            }
        });
        activeTextInstance.extensions.push(controls), $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, function() {
            if (activeTextInstance.utils.isFullWindowScalingMode()) {
                var rotationControl = new ActiveText.ViewOrientationDetection();
                rotationControl.init(activeTextInstance), activeTextInstance.extensions.push(rotationControl);
            }
        }), void 0 === activeTextInstance.options.allowOverlap && (activeTextInstance.options.allowOverlap = !1), 
        activeTextInstance.options.containerCoordinates = {
            top: 10,
            right: 0,
            bottom: 10,
            left: 0
        }, activeTextInstance.options.containerElement.css(Modernizr.multiplebgs ? {
            backgroundColor: "white",
            backgroundImage: "url(" + ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/activelearn/page-left.png), url(" + ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/activelearn/page-right.png)",
            backgroundPosition: "left top, right top",
            backgroundRepeat: "no-repeat"
        } : {
            backgroundColor: "white",
            backgroundImage: "url(" + ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/activelearn/page-left.png)",
            backgroundPosition: "left top",
            backgroundRepeat: "no-repeat"
        });
        var cssStr;
        return cssStr = Modernizr.boxshadow ? ".whiteboard-container{-webkit-box-shadow: 0px 4px 7px 2px #999999;-moz-box-shadow: 0px 4px 7px 2px #999999;box-shadow: 0px 4px 7px 2px #999999}" : ".whiteboard-container{outline : 1px solid #ccc}", 
        ActiveText.CSSUtils.embedCSS(cssStr, "activelearn-styles"), controls;
    }
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "drawing,note,viewtoggle,zoom", rightButtons = options.rightButtons ? options.rightButtons : "contents,quicknav,previous,next";
    return {
        init: init,
        key: "activelearncontrols"
    };
};

/* global ActiveText, ActiveText, Modernizr */
var ActiveLearn = ActiveLearn || {};

/**
 * @class ActiveLearn.Player
 * @memberOf ActiveLearn
 * @param {*} options
 * @returns {{init: init, key: string}}
 * @constructor
 */
ActiveLearn.Player = function(options) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param dependencyKey {String}
     */
    function checkDependency(activeTextInstance, dependencyKey, options) {
        var newClass, hasExtensionForDependency = Boolean(ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, dependencyKey));
        if (!hasExtensionForDependency) switch (dependencyKey) {
          case "overlaydataloader":
            newClass = new ActiveText.OverlayData(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "hotspots":
            newClass = new ActiveText.Hotspots(ActiveLearn.HotspotsFactory.createResourceIcon, options), 
            newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "notes":
            newClass = new ActiveText.Notes(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "activelearncontrols":
            newClass = new ActiveLearn.Controls(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "keyboardintegration":
            newClass = new ActiveText.KeyboardIntegration(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "drawingtools":
            newClass = new ActiveText.DrawingTools(), newClass.supported() && (newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass));
        }
    }
    /**
     * @param activeTextInstance {ActiveText}
     */
    function init(activeTextInstance) {
        ActiveText.BrowserUtils.isMobileDevice && (activeTextInstance.options.allowAnimation = !1);
        for (var dependencyKey, dependencies = [ "overlaydataloader", "hotspots", "notes", "activelearncontrols", "keyboardintegration", "drawingtools" ], i = 0, l = dependencies.length; l > i; i++) dependencyKey = dependencies[i], 
        checkDependency(activeTextInstance, dependencyKey, options);
        $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, function() {
            var rotationControl = new ActiveText.ViewOrientationDetection();
            rotationControl.init(activeTextInstance), activeTextInstance.extensions.push(rotationControl);
        });
    }
    return {
        init: init,
        key: "activelearn"
    };
};

/* global ActiveText, Modernizr */
var ActiveLearn = ActiveLearn || {};

ActiveLearn.StylesHelper = function() {
    "use strict";
    function embedStyles(activeTextInstance) {
        activeTextInstance.options.scheme = {
            color: "#E6E5E5",
            textColor: "#C95116",
            controlColor: "#777E7D",
            controlHoverColor: "#C95116"
        }, activeTextInstance.options.containerElement.css({
            background: "#E6E5E5"
        });
        var cssStr;
        cssStr = Modernizr.boxshadow ? ".whiteboard-container{-webkit-box-shadow: 0px 4px 7px #777E7D;-moz-box-shadow: 0px 4px 7px #777E7D;box-shadow: 0px 4px 7px #777E7D}" : ".whiteboard-container{outline : 1px solid #777E7D}";
        var useHoverStyles = !ActiveText.BrowserUtils.isMobileDevice, scope = activeTextInstance.options.containerElement.selector + " .controls-bar ";
        cssStr += ".controls-bar,.controls-bar *{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;}.controls-bar .activelearn.button{width:50px;height:49px;border:0 solid #E6E5E5;border-left-width:1px;-webkit-border-radius:0;-moz-border-radius:0;-ms-border-radius:0;border-radius:0;font-size:22px;color:#777E7D;text-decoration:none;}.controls-bar .activelearn.button.active.viewtoggle,.controls-bar .activelearn.button.active.zoom{color:#777E7D;}.controls-bar .activelearn.button.active.viewtoggle:hover,.controls-bar .activelearn.button.active.zoom:hover{color:#C95116;}" + (useHoverStyles ? ".controls-bar .activelearn.button:hover," : "") + ".controls-bar .activelearn.button:focus,.controls-bar .activelearn.button.selected.next,.controls-bar .activelearn.button.selected.previous,.controls-bar .activelearn.button:active,.controls-bar .activelearn.button.active{color:#C95116;}.controls-bar .activelearn.button.contents.open{background:white;}.controls-bar .activelearn.button:active i{-webkit-transition: all .3s;-moz-transition: all .3s;-ms-transition: all .3s;-o-transition: all .3s;transition: all .3s;-webkit-transform:scale(0.8);-moz-transform:scale(0.8);transform:scale(0.8);}.controls-bar .control{font-size:12px;}.controls-bar .activelearn.button.next i,.controls-bar .activelearn.button.previous i{font-size:32px;vertical-align:middle;}.controls-bar .activelearn.button.note i{-webkit-transform:scaleY(-0.9);-moz-transform:scaleY(-0.9);-ms-transform:scaleY(-0.9);transform:scaleY(-0.9);}.controls-bar .activelearn.button.last{border-right-width:1px;}" + scope + ".at-popover.top .arrow{border-left:none;border-right:none;width:49px;margin-left:-24px;border-top:7px solid #fff;}" + scope + ".at-popover," + scope + ".at-popover *{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;}" + scope + ".list-container{margin:0;padding:0;}" + scope + ".at-popover{padding:1px;padding-bottom:7px;}" + scope + ".at-popover.top{margin-top:6px;}" + scope + ".at-popover-inner{background:white;-webkit-border-radius:2px;-moz-border-radius:2px;border-radius:2px;padding:0;-webkit-box-shadow: 0 -2px 7px rgba(0,0,0,.3);-moz-box-shadow: 0 -2px 7px rgba(0,0,0,.3);-ms-box-shadow: 0 -2px 7px rgba(0,0,0,.3);box-shadow: 0 -2px 7px rgba(0,0,0,.3);}" + scope + ".structured-navigation-popup ul li{border-bottom:1px solid #E6E5E5;font-size:12px;}" + scope + ".structured-navigation-popup ul li.last{border-bottom:none;}" + // list item styles
        scope + ".structured-navigation-popup ul li{margin:0;line-height: 26px;padding:3px 0;}" + scope + ".structured-navigation-popup ul li a," + scope + ".structured-navigation-popup ul li a:link," + scope + ".structured-navigation-popup ul li a:visited{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;white-space: inherit;padding:0 10px;width:100%;-webkit-border-radius: 0;-moz-border-radius: 0;border-radius: 0;color:#333;}" + (useHoverStyles ? scope + ".structured-navigation-popup ul li a:hover," : "") + scope + ".structured-navigation-popup ul li a:active," + scope + ".structured-navigation-popup ul li a:focus{color:#C95116;background:white;outline:none;}" + scope + ".structured-navigation-popup ul li a.active{font-weight:normal;background:white;color:#C95116;}" + (useHoverStyles ? scope + ".structured-navigation-popup ul li a.active:hover," : "") + scope + ".structured-navigation-popup ul li a.active:active," + scope + ".structured-navigation-popup ul li a.active:focus{background:white;}.quicknav.control{color:#777E7D;}.quicknav.control input{-webkit-appearance: none;-webkit-border-radius:2px;-moz-border-radius:2px;border-radius:2px;color:#333;background:#EAEAEA;padding:6px 0;border:1px solid #CFCECE;outline:none;text-align:center;}.list-container::-webkit-scrollbar-track{background-color: #F7F6F5;width:12px;border-top-left-radius:6px;}.list-container::-webkit-scrollbar{width: 12px;background-color: #F7F6F5;}.list-container::-webkit-scrollbar-thumb{border-radius:6px;background-color: #CFCECE;border:3px solid #F7F6F5;width: 6px;margin:3px 0;}.list-container::-webkit-scrollbar-thumb:hover{background-color: #000;}", 
        ActiveText.CSSUtils.embedCSS(cssStr, "activelearn-styles");
    }
    return {
        embedStyles: embedStyles
    };
}();

/* global ActiveText */
var Innovation = Innovation || {};

/**
 * @class Player
 * @memberOf Innovation
 * @param options {{ hotspotClickFunction: function }}
 * @returns {{init: init, key: string}}
 * @constructor
 */
Innovation.Player = function(options) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param dependencyKey {String}
     * @param options {{ hotspotClickFunction: function }}
     */
    function checkDependency(activeTextInstance, dependencyKey) {
        var newClass, hasExtensionForDependency = Boolean(ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, dependencyKey));
        if (!hasExtensionForDependency) switch (dependencyKey) {
          case "keyboardintegration":
            newClass = new ActiveText.KeyboardIntegration(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
        }
    }
    function setDefaultPropertiesFor(activeTextInstance) {
        activeTextInstance.options.allowAnimation = !1, activeTextInstance.options.pageEdgeStyle = "none";
    }
    /**
     * @param activeTextInstance {ActiveText}
     */
    function init(activeTextInstance) {
        if (activeTextInstance && activeTextInstance.options && activeTextInstance.options.containerElement) {
            setDefaultPropertiesFor(activeTextInstance), Innovation.StylesHelper.injectCSS(activeTextInstance);
            for (var dependencyKey, dependencies = [ "keyboardintegration" ], i = 0, l = dependencies.length; l > i; i++) dependencyKey = dependencies[i], 
            checkDependency(activeTextInstance, dependencyKey, options);
            $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, function() {
                if (activeTextInstance.utils.isFullWindowScalingMode()) {
                    var rotationControl = new ActiveText.ViewOrientationDetection();
                    rotationControl.init(activeTextInstance), activeTextInstance.extensions.push(rotationControl);
                }
                var edges = new Innovation.PageEdgeFactory(activeTextInstance);
                edges.generateEdges(activeTextInstance.options.containerElement);
            });
        }
    }
    return {
        init: init,
        key: "innovation"
    };
}, /* global ActiveText, Innovation */
Innovation.StylesHelper = function() {
    "use strict";
    function injectCSS(activeTextInstance) {
        var colorOne = "#FB2B69", colorTwo = "#FF5B37";
        try {
            colorOne = activeTextInstance.options.scheme.colors[1], colorTwo = activeTextInstance.options.scheme.colors[0];
        } catch (err) {}
        var svgFill = '<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="0" height="0" viewBox="0 0 10 10" enable-background="new 0 0 10 10" xml:space="preserve"><linearGradient id="SVGID_1_" gradientUnits="userSpaceOnUse" x1="3.1816" y1="11.2905" x2="3.1816" y2="-1.091394e-10"><stop offset="0" style="stop-color:' + colorOne + '"/><stop offset="1" style="stop-color:' + colorTwo + '"/></linearGradient></svg>';
        $("body").append(svgFill), activeTextInstance.options.scheme = {
            textColor: "#000000",
            controlColor: "#000000",
            controlHoverColor: "" + colorTwo
        };
        var topColorHover = ActiveText.ColourUtils.convertHexToRGB(colorOne, .75), bottomColorHover = ActiveText.ColourUtils.convertHexToRGB(colorTwo, .75), topColor = ActiveText.ColourUtils.convertHexToRGB(colorOne, 1), bottomColor = ActiveText.ColourUtils.convertHexToRGB(colorTwo, 1), useHoverStyles = !ActiveText.BrowserUtils.isMobileDevice, scope = activeTextInstance.options.containerElement.selector + " ", cssString = ".page-edge,.whiteboard-container{-webkit-transition: all .3s ease-in-out;-moz-transition: all .3s ease-in-out;-o-transition: all .3s ease-in-out;transition: all .3s ease-in-out;-webkit-touch-callout: none;-moz-user-select: none;-khtml-user-select: none;-webkit-user-select: none;-o-user-select: none; }" + (useHoverStyles ? scope + ".page-edge a:hover," + scope + ".controls-bar a.button:hover{background-image: -webkit-gradient(linear,left top,left bottom,color-stop(0, " + bottomColorHover + "),color-stop(1, " + topColorHover + "));background-image: -o-linear-gradient(bottom, " + bottomColorHover + " 0%, " + topColorHover + " 100%);background-image: -moz-linear-gradient(bottom, " + bottomColorHover + " 0%, " + topColorHover + " 100%);background-image: -webkit-linear-gradient(bottom, " + bottomColorHover + " 0%, " + topColorHover + " 100%);background-image: -ms-linear-gradient(bottom, " + bottomColorHover + " 0%, " + topColorHover + " 100%);background-image: linear-gradient(to bottom, " + bottomColorHover + " 0%, " + topColorHover + " 100%);}" : "") + scope + ".page-edge a:active," + scope + ".page-edge a:focus," + scope + ".controls-bar a.button.active," + scope + ".controls-bar a.button:active," + scope + ".controls-bar a.button:focus{background-image: -webkit-gradient(linear,left top,left bottom,color-stop(0, " + bottomColor + "),color-stop(1, " + topColor + "));background-image: -o-linear-gradient(bottom, " + bottomColor + " 0%, " + topColor + " 100%);background-image: -moz-linear-gradient(bottom, " + bottomColor + " 0%, " + topColor + " 100%);background-image: -webkit-linear-gradient(bottom, " + bottomColor + " 0%, " + topColor + " 100%);background-image: -ms-linear-gradient(bottom, " + bottomColor + " 0%, " + topColor + " 100%);background-image: linear-gradient(to bottom, " + bottomColor + " 0%, " + topColor + " 100%);}" + (useHoverStyles ? scope + ".page-edge a:hover svg polygon," + scope + ".controls-bar a.button:hover svg path," + scope + ".controls-bar a.button:hover svg polygon," : "") + scope + ".page-edge a:active svg polygon," + scope + ".page-edge a:focus svg polygon," + scope + ".controls-bar a.button:active svg polygon," + scope + ".controls-bar a.button:focus svg polygon," + scope + ".controls-bar a.button.active svg polygon," + scope + ".page-edge a:active svg path," + scope + ".page-edge a:focus svg path," + scope + ".controls-bar a.button.active svg path," + scope + ".controls-bar a.button:focus svg path," + scope + ".controls-bar a.button:active svg path{fill:white;}" + scope + "a.innovation-2014," + scope + "a.innovation-2014:link," + scope + "a.innovation-2014:visited," + scope + "a.innovation-2014 svg polygon," + scope + "a.innovation-2014:link svg polygon," + scope + "a.innovation-2014:visited svg polygon {text-decoration:none;cursor:pointer;-webkit-touch-callout: none;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;-webkit-border-radius: 21px;-moz-border-radius: 21px;-ms-border-radius: 21px;-o-border-radius: 21px;border-radius: 21px;margin: 4px 0;width: 42px;height: 42px;line-height: 1.3em !important;display:inline-block}" + scope + "a.innovation-2014:hover," + scope + "a.innovation-2014:focus," + scope + "a.innovation-2014:active," + scope + "a.innovation-2014:hover svg polygon," + scope + "a.innovation-2014:focus svg polygon," + scope + "a.innovation-2014:active svg polygon {text-decoration:none;}.pull-right {float:right;}" + scope + "a.innovation-2014.active," + scope + "a.innovation-2014.active:link," + scope + "a.innovation-2014.active:visited {background: red;}" + scope + "a.innovation-2014.active:hover," + scope + "a.innovation-2014.active:focus," + scope + "a.innovation-2014.active:active {color:red;}" + scope + "a.innovation-2014 i {position:absolute}" + scope + ".controls-bar img {vertical-align:middle;}";
        ActiveText.CSSUtils.embedCSS(cssString, "page-edges");
    }
    return {
        injectCSS: injectCSS
    };
}(), /* global ActiveText, Innovation */
/**
 * @class PageEdgeFactory
 * @memberOf Innovation
 * @param activeTextInstance {ActiveText}
 * @returns {{generateEdges: generateEdges, removeEdges: removeEdges, minimumWidth: number}}
 * @constructor
 */
Innovation.PageEdgeFactory = function(activeTextInstance) {
    "use strict";
    function refreshAllButtons() {
        $(nextButtons).each(function(index, element) {
            var canGoAgain = activeTextInstance.navigation.canGoToNextPage();
            canGoAgain ? $(element).removeClass("disabled").attr("aria-disabled", !1).fadeIn() : $(element).addClass("disabled").attr("aria-disabled", !0).fadeOut();
        }), $(prevButtons).each(function(index, element) {
            var canGoAgain = activeTextInstance.navigation.canGoToPreviousPage();
            canGoAgain ? $(element).removeClass("disabled").attr("aria-disabled", !1).fadeIn() : $(element).addClass("disabled").attr("aria-disabled", !0).fadeOut();
        });
    }
    function rightEdgeClickHandler() {
        activeTextInstance.navigation.gotoNextPage(), refreshAllButtons();
    }
    function leftEdgeClickHandler() {
        activeTextInstance.navigation.gotoPrevPage(), refreshAllButtons();
    }
    function onResize() {
        var dimensions = ActiveText.ViewUtils.getUnscaledDPSTargetDimensions(activeTextInstance), buttonWidth = -(dimensions.width - dimensions.availWidth) / 2, edges = $(leftEdge).add(rightEdge), horizontalMargins = 10;
        MINIMUM_OVERFLOW_WIDTH > buttonWidth ? (buttonWidth = MINIMUM_OVERFLOW_WIDTH, edges.addClass("overlap")) : edges.removeClass("overlap");
        var containerCoordinates = ActiveText.ViewUtils.getContainerCoordinates(activeTextInstance), controlsExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "controls"), barHeight = 0;
        controlsExtension && (barHeight = controlsExtension.getBarHeight()), edges.css({
            width: buttonWidth,
            height: dimensions.availHeight + containerCoordinates.top + (containerCoordinates.bottom - barHeight)
        }), buttonWidth > MAX_FONT_ICON_SIZE && (horizontalMargins = (buttonWidth - MAX_FONT_ICON_SIZE) / 2, 
        buttonWidth = MAX_FONT_ICON_SIZE), buttonWidth === MINIMUM_OVERFLOW_WIDTH && (leftEdge.width(buttonWidth + 2 * horizontalMargins), 
        rightEdge.width(buttonWidth + 2 * horizontalMargins));
    }
    function generateEdges(container) {
        activeTextInstance.utils.isFullWindowScalingMode() || container.css({
            position: "relative"
        });
        var leftTemplate = '<div class="left-edge page-edge" role="button" tabindex="0" title="Previous Page" aria-label="Previous Page"><a><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="33%" height="100%" viewBox="0 0 6.363 11.29" enable-background="new 0 0 6.363 11.29" xml:space="preserve" style="max-width:22px"><polygon fill="url(#SVGID_1_)" points="0.707,4.926 0,5.633 0.707,6.34 1.883,7.517 5.655,11.29 6.363,10.583 1.414,5.633 6.34,0.707 5.632,0 2.809,2.824 "/></svg></a></div>';
        leftEdge = $(leftTemplate).css({
            left: 0,
            position: activeTextInstance.utils.isFullWindowScalingMode() ? "fixed" : "absolute",
            top: 0,
            zIndex: 1e3,
            cursor: "pointer"
        }), leftEdge.find("a").css({
            left: 0,
            right: 0,
            position: "absolute",
            top: 0,
            bottom: 0,
            textAlign: "center"
        }), leftEdge.find("i").css({
            display: "inline-block"
        }), prevButtons.push(leftEdge);
        var template = '<div class="right-edge page-edge" role="button" tabindex="1" title="Next Page" aria-label="Next Page"><a><svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="33%" height="100%" viewBox="0 0 6.364 11.29" enable-background="new 0 0 6.364 11.29" xml:space="preserve" style="max-width:22px"><polygon fill="url(#SVGID_1_)" points="5.657,6.364 6.364,5.657 5.657,4.95 4.48,3.773 0.707,0 0,0.707 4.95,5.657 0.023,10.583 0.73,11.29 3.554,8.467 "/></svg></a></div>';
        rightEdge = $(template).css({
            right: 0,
            position: activeTextInstance.utils.isFullWindowScalingMode() ? "fixed" : "absolute",
            top: 0,
            zIndex: 1e3,
            cursor: "pointer"
        }), rightEdge.find("a").css({
            left: 0,
            right: 0,
            position: "absolute",
            top: 0,
            bottom: 0,
            textAlign: "center"
        }), rightEdge.find("i").css({
            display: "inline-block"
        }), nextButtons.push(rightEdge), activeTextInstance.navigation.canGoToNextPage() || rightEdge.addClass("disabled").attr("aria-disabled", !0), 
        activeTextInstance.navigation.canGoToPreviousPage() || leftEdge.addClass("disabled").attr("aria-disabled", !0), 
        onResize();
        var whiteboardContainer = container.find(".whiteboard-container");
        leftEdge.insertAfter(whiteboardContainer), rightEdge.insertAfter(whiteboardContainer), 
        rightEdge.click(rightEdgeClickHandler), leftEdge.click(leftEdgeClickHandler), $(activeTextInstance).one(ActiveText.Events.BOOK_STRUCTURE_LOADED, refreshAllButtons), 
        $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, refreshAllButtons), $(activeTextInstance).on(ActiveText.Events.RESIZE, onResize);
    }
    function removeEdges() {
        leftEdge.remove(), rightEdge.remove(), nextButtons = [], prevButtons = [], $(activeTextInstance).off(ActiveText.Events.BOOK_STRUCTURE_LOADED, refreshAllButtons), 
        $(activeTextInstance).off(ActiveText.Commands.GO_TO_PAGE, refreshAllButtons), $(activeTextInstance).off(ActiveText.Events.RESIZE, onResize);
    }
    /**
     * @const
     * @type {number}
     */
    var leftEdge, rightEdge, MINIMUM_OVERFLOW_WIDTH = 44, MAX_FONT_ICON_SIZE = 100, nextButtons = [], prevButtons = [];
    return {
        generateEdges: generateEdges,
        removeEdges: removeEdges,
        minimumWidth: 64
    };
}, /* global ActiveText, Innovation */
Innovation.Controls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        activeTextInstance.options.defaults || (activeTextInstance.options.defaults = {}), 
        activeTextInstance.options.defaults.generatePageEdges = !1, activeTextInstance.options.containerCoordinates = {
            top: 10,
            right: 10,
            bottom: 10,
            left: 10
        };
        var contentsSVG = '<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="50%" height="50%" viewBox="0 0 54.988 10.596" enable-background="new 0 0 54.988 10.596" xml:space="preserve"><g><path fill="url(#SVGID_1_)" d="M7.554,1.005c0.693,0.67,1.079,1.431,1.155,2.283H7.383C7.235,2.641,6.941,2.128,6.5,1.75S5.44,1.183,4.644,1.183 c-0.971,0-1.755,0.348-2.353,1.043C1.693,2.921,1.395,3.988,1.395,5.424c0,1.177,0.27,2.131,0.809,2.863 c0.54,0.732,1.344,1.098,2.414,1.098c0.985,0,1.735-0.385,2.25-1.155c0.273-0.406,0.477-0.939,0.611-1.6h1.326 C8.688,7.688,8.3,8.575,7.643,9.29c-0.789,0.861-1.852,1.292-3.189,1.292c-1.153,0-2.122-0.354-2.906-1.06 C0.516,8.587,0,7.144,0,5.192C0,3.71,0.387,2.495,1.162,1.546C2,0.515,3.155,0,4.628,0C5.885,0,6.86,0.335,7.554,1.005z"/><path fill="url(#SVGID_1_)" d="M15.702,3.725c0.647,0.628,0.971,1.553,0.971,2.773c0,1.18-0.285,2.154-0.855,2.923c-0.57,0.77-1.455,1.154-2.654,1.154 c-1,0-1.794-0.34-2.383-1.021S9.898,7.959,9.898,6.812c0-1.229,0.31-2.208,0.93-2.937c0.62-0.729,1.453-1.093,2.498-1.093 C14.263,2.782,15.055,3.097,15.702,3.725z M14.938,8.59c0.3-0.617,0.45-1.303,0.45-2.059c0-0.683-0.108-1.238-0.325-1.666 c-0.342-0.674-0.933-1.011-1.771-1.011c-0.744,0-1.285,0.287-1.623,0.86s-0.507,1.266-0.507,2.076c0,0.778,0.169,1.427,0.507,1.946 s0.874,0.778,1.609,0.778C14.085,9.516,14.638,9.207,14.938,8.59z"/><path fill="url(#SVGID_1_)" d="M18.184,2.994h1.169v1.039c0.346-0.428,0.713-0.736,1.101-0.923s0.818-0.28,1.292-0.28c1.039,0,1.741,0.362,2.105,1.087 c0.201,0.396,0.301,0.964,0.301,1.702v4.696H22.9V5.701c0-0.447-0.066-0.807-0.198-1.08c-0.219-0.456-0.615-0.684-1.189-0.684 c-0.292,0-0.531,0.03-0.718,0.089c-0.337,0.1-0.633,0.301-0.889,0.602c-0.205,0.242-0.338,0.491-0.4,0.749 s-0.092,0.625-0.092,1.104v3.835h-1.23V2.994z"/><path fill="url(#SVGID_1_)" d="M26.216,0.95h1.244v2.044h1.169v1.005H27.46v4.778c0,0.255,0.086,0.426,0.26,0.513c0.096,0.05,0.255,0.075,0.479,0.075 c0.059,0,0.123-0.001,0.191-0.004s0.148-0.011,0.239-0.023v0.978c-0.141,0.041-0.288,0.071-0.441,0.089s-0.318,0.027-0.496,0.027 c-0.574,0-0.964-0.147-1.169-0.441s-0.308-0.676-0.308-1.145V3.999h-0.991V2.994h0.991V0.95z"/><path fill="url(#SVGID_1_)" d="M34.381,3.196c0.485,0.244,0.854,0.56,1.107,0.947c0.245,0.369,0.408,0.8,0.489,1.292c0.073,0.337,0.109,0.875,0.109,1.613 h-5.325c0.022,0.745,0.197,1.342,0.522,1.792c0.325,0.45,0.83,0.675,1.512,0.675c0.638,0,1.146-0.213,1.526-0.639 c0.212-0.247,0.363-0.533,0.452-0.858h1.21c-0.032,0.269-0.138,0.568-0.318,0.899s-0.381,0.601-0.603,0.81 c-0.371,0.365-0.83,0.611-1.377,0.738c-0.294,0.073-0.626,0.109-0.998,0.109c-0.906,0-1.673-0.332-2.303-0.995 c-0.63-0.663-0.944-1.592-0.944-2.786c0-1.176,0.317-2.13,0.951-2.864c0.634-0.734,1.463-1.101,2.486-1.101 C33.396,2.83,33.897,2.952,34.381,3.196z M34.822,6.07c-0.05-0.533-0.165-0.959-0.346-1.278c-0.334-0.592-0.893-0.889-1.674-0.889 c-0.561,0-1.03,0.204-1.41,0.612c-0.38,0.408-0.581,0.926-0.604,1.555H34.822z"/><path fill="url(#SVGID_1_)" d="M37.646,2.994h1.169v1.039c0.346-0.428,0.713-0.736,1.101-0.923s0.818-0.28,1.292-0.28c1.039,0,1.741,0.362,2.105,1.087 c0.201,0.396,0.301,0.964,0.301,1.702v4.696h-1.251V5.701c0-0.447-0.066-0.807-0.198-1.08c-0.219-0.456-0.615-0.684-1.189-0.684 c-0.292,0-0.531,0.03-0.718,0.089c-0.337,0.1-0.633,0.301-0.889,0.602c-0.205,0.242-0.338,0.491-0.4,0.749 s-0.092,0.625-0.092,1.104v3.835h-1.23V2.994z"/><path fill="url(#SVGID_1_)" d="M45.678,0.95h1.244v2.044h1.169v1.005h-1.169v4.778c0,0.255,0.086,0.426,0.26,0.513c0.096,0.05,0.255,0.075,0.479,0.075 c0.059,0,0.123-0.001,0.191-0.004S48,9.35,48.091,9.338v0.978c-0.141,0.041-0.288,0.071-0.441,0.089s-0.318,0.027-0.496,0.027 c-0.574,0-0.964-0.147-1.169-0.441s-0.308-0.676-0.308-1.145V3.999h-0.991V2.994h0.991V0.95z"/><path fill="url(#SVGID_1_)" d="M50.053,8.019c0.037,0.41,0.142,0.725,0.314,0.943c0.316,0.396,0.865,0.595,1.646,0.595c0.465,0,0.875-0.099,1.228-0.297 s0.53-0.505,0.53-0.919c0-0.314-0.141-0.554-0.424-0.718c-0.181-0.1-0.537-0.216-1.07-0.349l-0.994-0.246 c-0.634-0.155-1.102-0.328-1.403-0.52c-0.537-0.333-0.806-0.793-0.806-1.381c0-0.693,0.253-1.253,0.759-1.682 c0.505-0.428,1.186-0.643,2.04-0.643c1.118,0,1.923,0.324,2.417,0.971c0.31,0.41,0.46,0.852,0.451,1.326H53.58 c-0.023-0.276-0.124-0.528-0.301-0.754c-0.29-0.322-0.791-0.483-1.505-0.483c-0.476,0-0.836,0.088-1.081,0.266 c-0.245,0.177-0.367,0.411-0.367,0.702c0,0.318,0.161,0.572,0.483,0.763c0.186,0.114,0.459,0.214,0.822,0.3l0.829,0.198 c0.901,0.214,1.504,0.421,1.811,0.622c0.479,0.314,0.718,0.809,0.718,1.483c0,0.652-0.25,1.214-0.751,1.688 s-1.263,0.711-2.288,0.711c-1.103,0-1.883-0.247-2.342-0.742c-0.459-0.495-0.705-1.106-0.737-1.835H50.053z"/></g></svg>', nextSVG = '<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="50%" height="50%" viewBox="0 0 6.364 11.29" enable-background="new 0 0 6.364 11.29" xml:space="preserve"><polygon fill="url(#SVGID_1_)" points="5.657,6.364 6.364,5.657 5.657,4.95 4.48,3.773 0.707,0 0,0.707 4.95,5.657 0.023,10.583 0.73,11.29 3.554,8.467 "/></svg>', previousSVG = '<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="50%" height="50%" viewBox="0 0 6.363 11.29" enable-background="new 0 0 6.363 11.29" xml:space="preserve"><polygon fill="url(#SVGID_1_)" points="0.707,4.926 0,5.633 0.707,6.34 1.883,7.517 5.655,11.29 6.363,10.583 1.414,5.633 6.34,0.707 5.632,0 2.809,2.824 "/></svg>', settingsSVG = '<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px" width="50%" height="50%" viewBox="0 0 50 50" enable-background="new 0 0 50 50" xml:space="preserve"><path fill="url(#SVGID_1_)" d="M28,2v3.325v1.549l1.5,0.388c1.697,0.438,3.316,1.12,4.812,2.028l1.342,0.814l1.109-1.11l2.379-2.378 l4.242,4.242l-2.459,2.459l-1.083,1.082l0.763,1.328c0.846,1.473,1.479,3.067,1.879,4.739L42.852,22h1.577H48v6h-3.74h-1.523 l-0.405,1.468c-0.438,1.583-1.094,3.102-1.951,4.514l-0.814,1.343l1.11,1.109l2.708,2.708l-4.242,4.242l-2.789-2.788l-1.083-1.083 l-1.327,0.763c-1.377,0.792-2.872,1.398-4.442,1.803L28,42.465v1.55V48h-6v-3.985v-1.55l-1.501-0.387 c-1.57-0.405-3.065-1.011-4.442-1.803l-1.328-0.763l-1.082,1.083l-2.789,2.789l-4.242-4.243l2.708-2.708l1.11-1.109l-0.815-1.343 c-0.857-1.412-1.514-2.931-1.951-4.514L7.263,28H5.74H2v-6h3.57h1.577l0.368-1.533c0.4-1.672,1.033-3.267,1.879-4.739l0.763-1.328 l-1.083-1.082l-2.459-2.459l4.242-4.242l2.379,2.378l1.109,1.11l1.342-0.814c1.496-0.908,3.115-1.59,4.812-2.028L22,6.874V5.325V2 H28 M25,34.002c4.963,0,9-4.038,9-9.002c0-4.963-4.037-9.001-9-9.001S16,20.037,16,25C16,29.964,20.037,34.002,25,34.002 M30,0H20 v5.325c-1.91,0.493-3.705,1.257-5.35,2.255l-3.793-3.793l-7.07,7.071l3.873,3.873C6.726,16.358,6.019,18.127,5.57,20H0v10h5.74 c0.494,1.788,1.228,3.47,2.169,5.02l-4.122,4.122l7.07,7.072l4.203-4.204c1.531,0.88,3.188,1.554,4.94,2.005V50h10v-5.985 c1.751-0.451,3.408-1.125,4.939-2.005l4.203,4.203l7.07-7.071l-4.122-4.122c0.94-1.55,1.675-3.232,2.169-5.02H50V20h-5.57 c-0.449-1.873-1.155-3.642-2.09-5.269l3.873-3.873l-7.07-7.071L35.35,7.58C33.705,6.582,31.91,5.818,30,5.325V0L30,0z M25,32.002 c-3.867,0-7-3.135-7-7.002c0-3.867,3.133-7.001,7-7.001s7,3.134,7,7.001C32,28.867,28.867,32.002,25,32.002L25,32.002z"/></svg>', instance = new ActiveText.UI.BasicControls(activeTextInstance, {
            leftButtons: leftButtons,
            rightButtons: rightButtons,
            leftButtonOptions: {
                left: "10px"
            },
            rightButtonOptions: {
                right: "10px"
            },
            openByDefault: !0,
            overlay: !1,
            barHeight: 74,
            barStyles: {
                backgroundColor: ActiveText.ColourUtils.convertHexToRGB("#000000", .8)
            },
            minWidth: 530,
            scaleMode: "scale",
            buttonStyles: {
                width: 44,
                height: 44,
                barClass: "innovation-2014"
            },
            options: {
                contents: {
                    popupnavwidth: 280,
                    svgData: contentsSVG,
                    style: {
                        width: 119
                    }
                },
                next: {
                    svgData: nextSVG
                },
                previous: {
                    svgData: previousSVG
                },
                settings: {
                    svgData: settingsSVG
                }
            }
        });
        return activeTextInstance.extensions.push(instance), instance;
    }
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "settings", rightButtons = options.rightButtons ? options.rightButtons : "contents,previous,next";
    return {
        init: init,
        key: "innovationcontrols"
    };
};

/* global ActiveText, ActiveText, Modernizr */
var BugClub = BugClub || {};

/**
 * @class BugClub.Player
 * @memberOf BugClub
 * @param {string} skinCode
 * @returns {{init: init, key: string}}
 * @constructor
 */
BugClub.Player = function(skinCode) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param dependencyKey {String}
     * @param skinCode {String}
     */
    function checkDependency(activeTextInstance, dependencyKey, skinCode) {
        var newClass, hasExtensionForDependency = Boolean(ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, dependencyKey));
        if (!hasExtensionForDependency) switch (dependencyKey) {
          case "overlaydataloader":
            newClass = new ActiveText.OverlayData(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubhotspots":
            newClass = new BugClub.Hotspots(skinCode), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "smildatamodel":
            newClass = new ActiveText.SMILDataModel(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "smildataloader":
            newClass = new ActiveText.SMILDataLoader(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "readtome":
            activeTextInstance.options.allowReadToMe !== !1 && (newClass = new ActiveText.ReadToMe(), 
            newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass));
            break;

          case "summaryscreen":
            newClass = new BugClub.SummaryScreen(skinCode), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "soundeffects":
            newClass = new ActiveText.SoundEffects(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "keyboardintegration":
            newClass = new ActiveText.KeyboardIntegration(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "drawingtools":
            newClass = new ActiveText.DrawingTools(), newClass.supported() && (newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass));
            break;

          case "readingcomplete":
            newClass = new ActiveText.ReadingComplete(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubactivitysummary":
            newClass = new BugClub.ActivitySummaryCollective(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubscorm":
            newClass = new BugClub.SCORM.ActivityData(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
        }
    }
    function setDefaultPropertiesFor(activeTextInstance) {
        function hotspotClickHandler(e) {
            /* jshint validthis:true */
            var activityIsComplete = $(e.currentTarget).hasClass("complete");
            if (activityIsComplete) debug.log("Not launching activity because activity is completed."); else {
                var data = $(e.currentTarget).data(), hotspotUri = data.data.uri, scormIntegrationExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "pipwerks");
                scormIntegrationExtension ? (debug.log("scormIntegrationExtension.launchActivity();", data), 
                scormIntegrationExtension.launchActivity(hotspotUri)) : (debug.log("Launching Hotspot Activity : " + hotspotUri), 
                setTimeout(function() {
                    alert("Launching Hotspot Activity : " + hotspotUri);
                }, 0));
            }
        }
        function audioPlaybackController(value) {
            var rtn, readToMe = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "readtome");
            if (readToMe) {
                var state = readToMe.getState();
                isUsingAutoPlay = state.shouldAutoPlay, void 0 === value ? rtn = state.shouldAutoPlay : state.shouldAutoPlay = Boolean(readToMe.options && readToMe.options.autoplay);
            }
            return rtn;
        }
        ActiveText.BrowserUtils.isMobileDevice && (activeTextInstance.options.allowAnimation = !1);
        var pathToAssets = ActiveText.SkinUtils.getPathToResources(activeTextInstance);
        activeTextInstance.options.containerElement.css(/**
         * Browser detection is bad, but IE is worse.
         *
         * Some versions of IE support SVG, and they support it for background images, but they don't scale it correctly
         * because they're dumb. So we're forced to do shit like this - using non SVG versions of images for the background.
         */
        !Modernizr.svg || navigator.userAgent.match(/(msie|trident)\/?\s*(\.?\d+(\.\d+)*)/i) ? {
            background: "url(" + pathToAssets + "img/bugclub/backdrop.png) no-repeat center center",
            filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src="' + pathToAssets + 'img/bugclub/backdrop.png", sizingMethod="scale")',
            MsFilter: "'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\"" + pathToAssets + 'img/bugclub/backdrop.png", sizingMethod="scale")\'',
            backgroundSize: "cover"
        } : {
            background: "url(" + pathToAssets + "img/bugclub/background.svg) no-repeat center center",
            backgroundSize: "cover"
        });
        /**
         * @type {Boolean}
         */
        var isUsingAutoPlay;
        void 0 === activeTextInstance.options.allowOverlap && (activeTextInstance.options.allowOverlap = !1), 
        void 0 === activeTextInstance.options.hotspotClickFunction && (activeTextInstance.options.hotspotClickFunction = hotspotClickHandler), 
        void 0 === activeTextInstance.options.audioPlaybackController && (activeTextInstance.options.audioPlaybackController = audioPlaybackController);
    }
    function getOverlayDataExtension(activeTextInstance) {
        return ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "overlaydataloader");
    }
    function preloadActivityData(activeTextInstance) {
        var overlayDataLoader = getOverlayDataExtension(activeTextInstance);
        if (overlayDataLoader) for (var i = 0, l = activeTextInstance.data.getFlatListOfNavigation().length; l > i; i++) overlayDataLoader.loadDataForPageIndex(i);
    }
    /**
     * @param activeTextInstance {ActiveText}
     */
    function init(activeTextInstance) {
        setDefaultPropertiesFor(activeTextInstance);
        for (var dependencyKey, dependencies = [ "overlaydataloader", "bugclubactivitysummary", "bugclubscorm", "bugclubhotspots", "smildatamodel", "smildataloader", "readtome", "summaryscreen", "soundeffects", "keyboardintegration", "drawingtools", "readingcomplete" ], i = 0, l = dependencies.length; l > i; i++) dependencyKey = dependencies[i], 
        checkDependency(activeTextInstance, dependencyKey, skinCode);
        $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, function() {
            if (activeTextInstance.utils.isFullWindowScalingMode()) {
                var rotationControl = new ActiveText.ViewOrientationDetection();
                rotationControl.init(activeTextInstance), activeTextInstance.extensions.push(rotationControl);
            }
        }), $(activeTextInstance).one(ActiveText.Events.BOOK_STRUCTURE_LOADED, function() {
            preloadActivityData(activeTextInstance);
        });
    }
    return {
        init: init,
        key: "bugclub"
    };
}, /* global ActiveText, BugClub */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    /**
     * @private
     * @param activeTextInstance {ActiveText}
     * @param options {object}
     * @returns {jQuery}
     */
    function create(activeTextInstance, options) {
        var width, factory = ActiveText.UI.BasicControls.ToggleButtonFactory, buttonElement = factory.createToggleButton(DEFAULT_BUTTON_OPTIONS, options), container = $("<div class='structure-container' style='width:" + buttonElement.outerWidth() + "px'></div>").append(buttonElement), popupController = new BugClub.StructurePopup();
        return options && options.options && options.options.popupnavwidth && (width = options.options.popupnavwidth), 
        popupController.init(activeTextInstance, buttonElement, void 0, width), container;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "activitystructure", DEFAULT_BUTTON_OPTIONS = {
        title: "Contents",
        icon: "icon-reorder",
        className: KEY,
        accesskey: "C"
    };
    /**
     * @type {{create: Function}}
     */
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create(activeTextInstance, options) {
        function showLayers() {
            ActiveText.LayerUtils.setLayerVisibility(activeTextInstance, "standalone_hotspots", !0);
        }
        function hideLayers() {
            ActiveText.LayerUtils.setLayerVisibility(activeTextInstance, "standalone_hotspots", !1);
        }
        function buttonClickHandler() {
            isVisible ? (isVisible = !1, newElement.toggle_button(!1), hideLayers()) : (isVisible = !0, 
            newElement.toggle_button(!0), showLayers());
        }
        function getNumberOfValidHotspotsFromData(data) {
            for (var objects = [], i = 0, l = data.data.length; l > i; i++) {
                var item = data.data[i];
                "hotspot" === item.type && objects.push(item);
            }
            return objects.length;
        }
        function checkDataIsForCurrentPage(event, data) {
            dataCache[data.index] = 0, updateButtonEnabled();
        }
        function updateButtonEnabled() {
            for (var visibleIndex = activeTextInstance.model.getCurrentIndex(), numberOfFrames = activeTextInstance.view.model.getDisplayedPages(), hasHotspots = !1, i = visibleIndex, l = visibleIndex + numberOfFrames; l > i; i++) dataCache[i] && dataCache[i] > 0 && (hasHotspots = !0);
            hasHotspots ? newElement.enable() : newElement.disable();
        }
        function checkLoadedDataIsForCurrentPage(event, data) {
            dataCache[data.index] = getNumberOfValidHotspotsFromData(data), updateButtonEnabled();
        }
        var isVisible = !0, dataCache = [], factory = ActiveText.UI.BasicControls.ToggleButtonFactory, newElement = factory.createToggleButton(DEFAULT_BUTTON_STYLES, options);
        return newElement.toggle_button(!0), newElement.on({
            click: buttonClickHandler
        }), $(activeTextInstance).on(ActiveText.Events.LOADED_OVERLAY_DATA, checkLoadedDataIsForCurrentPage), 
        $(activeTextInstance).on(ActiveText.Events.OVERLAY_DATA_FAIL, checkDataIsForCurrentPage), 
        newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "bugclubhotspots", DEFAULT_BUTTON_STYLES = {
        title_on: "Show Hotspots",
        title_off: "Hide Hotspots",
        icon_off: "icon-eye-close",
        icon_on: "icon-eye-open",
        className: KEY,
        accesskey: "H"
    };
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText, BugClub, requestAnimationFrame, ScrollFix */
ActiveText.namespace("BugClub.StructurePopup"), BugClub.StructurePopup = function() {
    "use strict";
    /**
     * @param instance {ActiveText}
     * @param element
     * @param scopePrefix
     * @param width {Number}
     */
    function init(instance, element, scopePrefix, width) {
        activeTextInstance = instance, buttonElement = element, factory = ActiveText.UI.StructurePopupFactory;
        var summaryData = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "bugclubactivitysummary");
        summaryData && $(summaryData).on(CHANGE, updateActivityStatusFromEvent), helper = new ActiveText.UI.StructurePopupDisplayHelper(), 
        helper.init(activeTextInstance, buttonElement, createPopupCallback), embedCSSStyleTag(scopePrefix, width), 
        attachButtonEventHandlers();
    }
    /**
     * @param links {jQuery}
     * @param item {{activityIds:Array, pageIndex:Number, status:String}}
     */
    function updateIndividualActivity(item) {
        var links = popupContents.find("li"), activityStatus = item.status, pageNumber = ActiveText.NavigationUtils.pageIndexToPageNumber(activeTextInstance, item.pageIndex), linksForPage = links.find("> a[data-page=" + pageNumber + "]");
        if (linksForPage.length > 0) {
            var statusIcon = linksForPage.find(".status-icon").get(0);
            statusIcon && (statusIcon.className = "status-icon", $(statusIcon).addClass(activityStatus));
        }
    }
    /**
     * @param data
     */
    function updateActivityStatus(data) {
        if (popupContents) if (data && $.isArray(data)) for (var i = 0, l = data.length; l > i; i++) {
            var item = data[i];
            item.pageIndex = i, updateIndividualActivity(item);
        } else updateIndividualActivity(data);
    }
    /**
     * @param event {object}
     * @param data {array}
     */
    function updateActivityStatusFromEvent(event, data) {
        updateActivityStatus(data);
    }
    /**
     * @returns {jQuery}
     */
    function getContainerElement() {
        return containerElement && 0 !== containerElement.length || (containerElement = buttonElement.parent()), 
        containerElement;
    }
    /**
     * @param scopePrefix
     * @param width
     */
    function embedCSSStyleTag(scopePrefix, width) {
        var scope;
        scope = "string" == typeof scopePrefix ? scopePrefix + " " : activeTextInstance.options.containerElement.selector + " ";
        var cssString = BugClub.StructurePopup.Style.getStyle(activeTextInstance, scope, activeTextInstance.theme, width);
        ActiveText.CSSUtils.embedCSS(cssString, scope + "structure-popup");
    }
    function hidePopup() {
        helper.hidePopup();
    }
    function showPopup() {
        helper.showPopup();
    }
    /**
     * @param obj {object|array}
     * @return {string}
     */
    function convertNavigationStructureToHTMLList(obj) {
        var output = "";
        if (obj && $.isArray(obj) && obj.length > 0) {
            output += "<ul>";
            for (var i = 0, len = obj.length; len > i; i++) output += convertNavigationStructureToHTMLList(obj[i]);
            output += "</ul>";
        } else output += obj && void 0 !== obj.number && void 0 !== obj.title ? '<li><a href="#" data-page="' + obj.number + '"><div class="status-icon"></div><span>' + obj.title + "</span></a></li>" : "";
        return output;
    }
    /**
     * @param navigationStructure
     * @returns {string}
     */
    function generateInitialContentForPopover(navigationStructure) {
        var content = convertNavigationStructureToHTMLList(navigationStructure);
        return '<div class="structured-navigation-popup"><div class="list-container scrollable">' + content + "</div></div>";
    }
    function createPopupCallback() {
        buttonElement.addClass("open"), buttonElement.toggle_button && buttonElement.toggle_button(!0);
        var summaryData = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "bugclubactivitysummary");
        if (summaryData) var statusObject = summaryData.getData();
        var navigationStructure = activeTextInstance.data.getNavigationStructure(), popoverContainerElement = getContainerElement(), initialContentForPopover = generateInitialContentForPopover(navigationStructure), currentPageNumber = activeTextInstance.model.getCurrentPageNumber();
        factory.createPopup(popoverContainerElement, initialContentForPopover), setTimeout(function() {
            popupContents = getContainerElement().find(".at-popover-content"), popupContents.find("a").click(linkClickHandler), 
            helper.highlightLinksForIndex(ROW_HEIGHT, currentPageNumber, 0), summaryData && updateActivityStatus(statusObject);
            new ScrollFix(popupContents.find(".scrollable").get(0));
        }, 0);
    }
    /**
     * @param event {object}
     * @return {Boolean}
     */
    function linkClickHandler(event) {
        var targetPageNumber = $(event.currentTarget).attr("data-page");
        return activeTextInstance.navigation.gotoPage(targetPageNumber), !1;
    }
    function attachButtonEventHandlers() {
        $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, updateCurrentPageHighlightOnEvent);
    }
    /**
     * @param event
     * @param data
     */
    function updateCurrentPageHighlightOnEvent(event, data) {
        helper.removeHighlightFromAllLinks(), helper.highlightLinksForIndex(ROW_HEIGHT, data.toPage);
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, popupContents, containerElement, buttonElement, factory, helper, ROW_HEIGHT = 41, CHANGE = "change";
    return {
        init: init,
        createPopup: createPopupCallback,
        showPopup: showPopup,
        hidePopup: hidePopup
    };
}, /* global ActiveText, BugClub */
ActiveText.namespace("BugClub.StructurePopup.Style"), BugClub.StructurePopup.Style = function(ActiveText, BugClub) {
    "use strict";
    /**
     * @param scope {string}
     * @param theme {ActiveText.Theme}
     * @param width {number}
     * @returns {string}
     */
    function getStyle(activeTextInstance, scope, theme, width) {
        var indent = 20;
        scope || (scope = ""), theme || (theme = new ActiveText.Theme(activeTextInstance)), 
        width || (width = 480);
        /**
         * @const
         * @type {string}
         */
        var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), controlsOutlineColor = theme.getControlsOutlineColor(), popupBackgroundColor = theme.getPopupBackgroundColor(), linkBackgroundActiveColor = theme.getControlsForegroundHoverColor(), linkBackgroundHoverColor = theme.getControlsForegroundHoverColor(.33), useHoverStyles = !ActiveText.BrowserUtils.isMobileDevice;
        return scope + ".at-popover{position: absolute;top: 0;left: 0;z-index: 1040;display: none;padding: 5px;}" + scope + ".at-popover.top{margin-top: -5px;}" + scope + ".at-popover.right{margin-left: 5px;}" + scope + ".at-popover.bottom{margin-top: 5px;}" + scope + ".at-popover.left{margin-left: -5px;}" + scope + ".at-popover.top .arrow{bottom: 0;left: 50%;margin-left: -5px;border-left: 5px solid transparent;border-right: 5px solid transparent;border-top: 5px solid " + controlsOutlineColor + ";}" + scope + ".at-popover.right .arrow{top: 50%;left: 0;margin-top: -5px;border-top: 5px solid transparent;border-bottom: 5px solid transparent;border-right: 5px solid " + controlsOutlineColor + ";}" + scope + ".at-popover.bottom .arrow{top: 0;left: 50%;margin-left: -5px;border-left: 5px solid transparent;border-right: 5px solid transparent;border-bottom: 5px solid " + controlsOutlineColor + ";}" + scope + ".at-popover.left .arrow{top: 50%;right: 0;margin-top: -5px;border-top: 5px solid transparent;border-bottom: 5px solid transparent;border-left: 5px solid " + controlsOutlineColor + ";}" + scope + ".at-popover .arrow{position: absolute;width: 0;height: 0;}" + scope + ".at-popover-inner{padding: 3px;overflow: hidden;background: " + controlsOutlineColor + ";background: " + theme.getControlsOutlineColor(.8) + ";-webkit-border-radius: 6px;-moz-border-radius: 6px;border-radius: 6px;-webkit-box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);-moz-box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);box-shadow: 0 3px 7px rgba(0, 0, 0, 0.3);}" + scope + ".at-popover-content{padding: 0;background-color: " + popupBackgroundColor + ";-webkit-border-radius: 3px;-moz-border-radius: 3px;border-radius: 3px;-webkit-background-clip: padding-box;-moz-background-clip: padding-box;background-clip: padding-box;width:" + width + "px;}" + scope + ".at-popover-content p," + scope + ".at-popover-content ul," + scope + ".at-popover-content ol{margin-bottom: 0; }.structured-navigation-popup ul {font-size:16px;line-height:2em;margin:0;padding:0}" + scope + ".list-container{overflow: scroll;-webkit-overflow-scrolling: touch;overflow-x:hidden;overflow-y:auto;height:250px;padding:3px 0 4px;margin:0 4px;}" + scope + ".structured-navigation-popup ul li{margin:0;text-align:left;list-style: none;line-height: 32px;}" + scope + ".structured-navigation-popup ul ul li a{padding-left:30px !important;width:" + (width - 3 * indent) + "px !important;}" + scope + ".structured-navigation-popup ul ul ul li a{padding-left:50px !important;width:" + (width - 4 * indent) + "px !important;}" + scope + ".structured-navigation-popup ul ul ul ul li a{padding-left:70px !important;width:" + (width - 5 * indent) + "px !important;}" + scope + ".structured-navigation-popup ul ul ul ul ul li a{padding-left:90px !important;width:" + (width - 6 * indent) + "px !important;}" + scope + ".structured-navigation-popup ul li a," + scope + ".structured-navigation-popup ul li a:link," + scope + ".structured-navigation-popup ul li a:visited{text-decoration:none;white-space: nowrap;text-overflow: ellipsis;display:inline-block;padding:0 10px;width:" + (width - 2 * indent) + "px;-webkit-border-radius: 3px;-moz-border-radius: 3px;border-radius: 3px;color:" + theme.getTextColor() + ";-webkit-transition: background .3s;-moz-transition: background .3s;-ms-transition: background .3s;-o-transition: background .3s;transition: background .3s;-webkit-touch-callout: none;-webkit-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none;}" + (useHoverStyles ? scope + ".structured-navigation-popup ul li a:hover{background:" + linkBackgroundHoverColor + ";-webkit-tap-highlight-color:" + linkBackgroundHoverColor + ";}" : "") + scope + ".structured-navigation-popup ul li a:active," + scope + ".structured-navigation-popup ul li a:focus{background:" + linkBackgroundActiveColor + ";}" + scope + " .structured-navigation-popup ul li {line-height:41px;}" + scope + " .status-icon{width:35px;height:35px;float:left;margin:3px 1ex 3px 0;-webkit-border-radius:50%;-moz-border-radius:50%;border-radius:50%;}" + scope + " .status-icon." + BugClub.ActivitySummaryStates.INCOMPLETE + "{background:white url(" + pathToResources + "img/bugclub/legacy/ks2/KS2_ActivityToggle_yellow_1.png) center center no-repeat;}" + scope + " .status-icon." + BugClub.ActivitySummaryStates.PROGRESS + "{background:white url(" + pathToResources + "img/bugclub/legacy/ks2/KS2_ActivityToggle_yellow_2.png) center center no-repeat;}" + scope + " .status-icon." + BugClub.ActivitySummaryStates.COMPLETED + "{background:white url(" + pathToResources + "img/bugclub/legacy/ks2/KS2_ActivityToggle_Green_face_yellow_1.png) center center no-repeat;}" + scope + " .status-icon." + BugClub.ActivitySummaryStates.NONE + "{background:transparent}.structure-container{display:inline-block;position:relative}";
    }
    return {
        getStyle: getStyle
    };
}(ActiveText, BugClub), /* global ActiveText, BugClub */
ActiveText.namespace("BugClub.ActivitySummaryCollective"), BugClub.ActivitySummaryCollective = function() {
    "use strict";
    function init(instance) {
        activeTextInstance = instance, /* jshint validthis:true */
        context = this, $(activeTextInstance).on(ActiveText.Events.LOADED_OVERLAY_DATA, onOverlayDataLoaded), 
        $(activeTextInstance).on(ActiveText.Events.OVERLAY_DATA_FAIL, onOverlayDataFail), 
        $(activeTextInstance).on(ActiveText.SCORMIntegration.SCORM_DATA_UPDATED, updateActivityState);
    }
    function updateActivityStatusForPage(pageIndex, state, activityIds) {
        var responses = getData();
        responses[pageIndex] = {
            status: state,
            activityIds: activityIds
        };
        var newEventData = {
            pageIndex: pageIndex,
            status: state,
            activityIds: activityIds
        };
        $(context).trigger(CHANGE, newEventData);
    }
    function onOverlayDataLoaded(event, data) {
        var state = calculateStateFromData(data.data), pageIndex = data.index, activityIds = getActivityIdsFromData(data.data);
        updateActivityStatusForPage(pageIndex, state, activityIds);
    }
    function onOverlayDataFail(event, data) {
        var pageIndex = data.index;
        updateActivityStatusForPage(pageIndex, BugClub.ActivitySummaryStates.NONE, []);
    }
    function getStateCodeForActivity(activityId) {
        var state = 0, scormActivityData = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "bugclubscorm"), scormData = scormActivityData.getSCORMStateForKey(activityId);
        return scormData && void 0 !== scormData.completion_status && scormData && void 0 !== scormData.completion_status && ("incomplete" === scormData.completion_status ? state = 1 : "completed" === scormData.completion_status && (state = 2)), 
        state;
    }
    function getActivityIdsFromData(data) {
        var rtn = [], scormActivityData = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "bugclubscorm"), validActivities = BugClub.ActivitySummaryUtils.getValidActivities(scormActivityData, data);
        if (validActivities.length) for (var i = 0, l = validActivities.length; l > i; i++) validActivities[i].data.id && rtn.push(validActivities[i].data.id);
        return rtn;
    }
    function calculateStateFromData(data) {
        for (var scormActivityData = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "bugclubscorm"), validActivities = BugClub.ActivitySummaryUtils.getValidActivities(scormActivityData, data), activityIds = [], i = 0, l = validActivities.length; l > i; i++) activityIds.push(validActivities[i].data.id);
        return calculateStateFromActivityIds(activityIds);
    }
    function calculateStateFromActivityIds(activityIds) {
        var rtn;
        if (activityIds.length) {
            for (var score = 0, i = 0, l = activityIds.length; l > i; i++) score += getStateCodeForActivity(activityIds[i]);
            rtn = score >= 2 * activityIds.length ? BugClub.ActivitySummaryStates.COMPLETED : 0 === score ? BugClub.ActivitySummaryStates.INCOMPLETE : BugClub.ActivitySummaryStates.PROGRESS;
        } else rtn = BugClub.ActivitySummaryStates.NONE;
        return rtn;
    }
    function updateActivityState(event, scormData) {
        // get the SCORM results object
        var resultsObject;
        resultsObject = scormData && scormData.items ? scormData.items : scormData;
        // find the hotspots affected by this data change
        var state, item, pageIndex;
        for (var activityId in resultsObject) item = resultsObject[activityId], pageIndex = getPageIndexForActivity(activityId), 
        state = calculateStateFromActivityIds(collectiveResponses[pageIndex].activityIds), 
        updateActivityStatusForPage(pageIndex, state, collectiveResponses[pageIndex].activityIds);
    }
    function getPageIndexForActivity(activityId) {
        for (var rtn = 0, allActivities = getData(), i = 0, l = allActivities.length; l > i; i++) for (var k = 0, kl = allActivities[i].activityIds.length; kl > k; k++) if (allActivities[i].activityIds[k] === activityId) {
            rtn = i;
            break;
        }
        return rtn;
    }
    function constructInitialSummaryObject() {
        for (var rtn = [], numberOfPages = activeTextInstance.data.getFlatListOfNavigation().length, i = 0; numberOfPages > i; i++) rtn.push({
            status: BugClub.ActivitySummaryStates.NONE,
            activityIds: []
        });
        return rtn;
    }
    function fetchData() {
        /* jshint validthis:true */
        collectiveResponses = constructInitialSummaryObject(), $(context).trigger(CHANGE, collectiveResponses);
    }
    function getData() {
        return collectiveResponses && 0 !== collectiveResponses.length || fetchData(), collectiveResponses;
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, collectiveResponses, context, CHANGE = "change";
    return {
        init: init,
        fetchData: fetchData,
        getData: getData,
        key: "bugclubactivitysummary"
    };
}, /* global ActiveText, BugClub */
/**
 * @class BugClub.ActivitySummaryIndividual
 * @memberOf BugClub
 * @returns {{init: init, getData: getData}}
 * @constructor
 */
BugClub.ActivitySummaryIndividual = function() {
    "use strict";
    function init(instance) {
        activeTextInstance = instance, /* jshint validthis:true */
        context = this, $(activeTextInstance).off(ActiveText.Events.LOADED_OVERLAY_DATA, onOverlayDataLoaded).on(ActiveText.Events.LOADED_OVERLAY_DATA, onOverlayDataLoaded), 
        $(activeTextInstance).off(ActiveText.SCORMIntegration.SCORM_DATA_UPDATED, updateActivityState).on(ActiveText.SCORMIntegration.SCORM_DATA_UPDATED, updateActivityState);
    }
    function updateActivityForId(activityId, state) {
        var responses = getData();
        responses[activityId] = {
            status: state
        };
        var newEventData = {
            activityId: activityId,
            status: state
        };
        $(context).trigger(CHANGE, newEventData);
    }
    function onOverlayDataLoaded(event, data) {
        var i, scormData, activityId, scormActivityData = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "bugclubscorm"), validActivities = BugClub.ActivitySummaryUtils.getValidActivities(scormActivityData, data.data);
        for (i in validActivities) activityId = validActivities[i].data.id, activityId || (activityId = data.index + i, 
        debug.warn("Activity Id is missing for hotspot on page " + data.index + ": Using an autogenerated one instead.")), 
        scormData = scormActivityData.getSCORMStateForKey(activityId), scormData ? updateActivityForId(activityId, getStateForActivity(scormData)) : updateActivityForId(activityId, BugClub.ActivitySummaryStates.INCOMPLETE);
    }
    function updateActivityState(event, scormData) {
        var resultsObject, activityId;
        resultsObject = scormData && scormData.items ? scormData.items : scormData;
        for (activityId in resultsObject) updateActivityForId(activityId, getStateForActivity(resultsObject[activityId]));
    }
    function getStateForActivity(scormData) {
        var state = BugClub.ActivitySummaryStates.INCOMPLETE;
        return scormData && void 0 !== scormData.completion_status && ("incomplete" === scormData.completion_status ? state = BugClub.ActivitySummaryStates.PROGRESS : "completed" === scormData.completion_status && (state = BugClub.ActivitySummaryStates.COMPLETED)), 
        state;
    }
    function getData() {
        return individualResponses && 0 !== individualResponses.length || (individualResponses = {}), 
        individualResponses;
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, individualResponses, context, CHANGE = "change";
    return {
        init: init,
        getData: getData
    };
}, /* global ActiveText, BugClub */
ActiveText.namespace("BugClub.ActivitySummaryUtils"), BugClub.ActivitySummaryUtils = function(ActiveText) {
    "use strict";
    /**
     * @param scormActivityData {BugClub.SCORM.ActivityData}
     * @param data {object}
     * @returns {Array}
     */
    function getValidActivities(scormActivityData, data) {
        for (var objects = [], i = 0, l = data.length; l > i; i++) {
            var item = data[i];
            if ("hotspot" === item.type) {
                if (item.data && item.data.uri) {
                    var parsed = ActiveText.DataUtils.parseURI(item.data.uri);
                    for (var key in parsed) item.data[key] = parsed[key];
                }
                objects.push(item), scormActivityData.setActivityById(item.data.seqid ? item.data.seqid : item.data.id, item);
            }
        }
        return objects;
    }
    return {
        getValidActivities: getValidActivities
    };
}(ActiveText), /* global ActiveText, BugClub */
ActiveText.namespace("BugClub.ActivitySummaryStates"), /**
 * @const
 * @type {{NONE: string, INCOMPLETE: string, PROGRESS: string, COMPLETED: string}}
 */
BugClub.ActivitySummaryStates = {
    NONE: "none",
    INCOMPLETE: "incomplete",
    PROGRESS: "progress",
    COMPLETED: "completed"
}, /* global ActiveText, BugClub */
ActiveText.namespace("BugClub.SummaryScreen"), BugClub.SummaryScreen = function(skinCode) {
    "use strict";
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        activeTextInstance = instance, ActiveText.CSSUtils.embedCSS(BugClub.DialogStyleText.getStyle(activeTextInstance), "bugclub-dialog-styles"), 
        ActiveText.CSSUtils.embedCSS(BugClub.SummaryScreen.DialogStyleText.getStyle(activeTextInstance), "bugclub-summary-screen-styles"), 
        summaryHTMLCache = [], BugClub.SummaryScreenIconFactory.preloadIconImages(activeTextInstance, skinCode), 
        summaryData = new BugClub.ActivitySummaryIndividual(), summaryData.init(instance), 
        $(summaryData).on("change", updateHotspotIcon), $(activeTextInstance).on(ActiveText.Events.RESOURCES_LOADED, preloadActivityData);
    }
    /**
     * @param event {Event}
     */
    function updateHotspotIcon(event, data) {
        data && data.activityId && (summaryHTMLCache[data.activityId] = BugClub.SummaryScreenIconFactory.getIconHTMLForStatus(activeTextInstance, data.status)), 
        updateHotspotIconsOnDialog();
    }
    function preloadActivityData() {
        var overlayDataLoader = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "overlaydataloader");
        if (overlayDataLoader) for (var i = 0, l = activeTextInstance.data.getFlatListOfNavigation().length; l > i; i++) //overlayDataLoader.loadDataForIndex(i);
        overlayDataLoader.loadDataForPageIndex(i);
    }
    function openSummary() {
        if (// todo: This would be better with some $(event.target) magic in future.
        $(".exit").blur(), newDialog) newDialog.open(); else {
            closeSummary();
            var closeFunction, container = activeTextInstance.options.containerElement, scormIntegrationFunction = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "pipwerks");
            scormIntegrationFunction && (closeFunction = scormIntegrationFunction.closeEBook), 
            newDialog = BugClub.SummaryScreenDialogFactory.createDialog(activeTextInstance, container, skinCode, closeFunction), 
            newDialog.on({
                dialogcreate: updateHotspotIconsOnDialog,
                dialogclose: removeRefsToDialog
            }), preloadActivityData();
        }
        return !1;
    }
    function removeRefsToDialog() {
        newDialog = null;
    }
    /**
     * @returns {boolean}
     */
    function updateHotspotIconsOnDialog() {
        var rtn = !1;
        if (newDialog) {
            var existingHTML = "";
            for (var icon in summaryHTMLCache) existingHTML += summaryHTMLCache[icon];
            var iconsContainer = newDialog.find(".summary-icons");
            iconsContainer.html(existingHTML);
            var allIcons = iconsContainer.find(".icon"), containerWidth = iconsContainer.width(), width = allIcons.width(), numIcons = allIcons.length;
            allIcons.css({
                margin: "15px " + Math.floor((containerWidth - numIcons * width) / numIcons) / 2 + "px"
            }), rtn = !0;
        }
        return rtn;
    }
    /**
     * @returns {boolean}
     */
    function closeSummary() {
        var rtn = !1;
        return newDialog && (newDialog.dialog("close"), rtn = !0), rtn;
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, summaryData, summaryHTMLCache, newDialog;
    return {
        init: init,
        openSummary: openSummary,
        closeSummary: closeSummary,
        key: "summaryscreen"
    };
}, /* global ActiveText, BugClub, Modernizr */
ActiveText.namespace("BugClub.SummaryScreenDialogFactory"), BugClub.SummaryScreenDialogFactory = function(ActiveText) {
    "use strict";
    function openSummary(activeTextInstance, container, skinCode, closeFunction) {
        function centerOnScreen() {
            $(newDialog).parent().css({
                top: (container.height() - dialogHeight) / 2,
                left: (container.width() - dialogWidth) / 2
            });
        }
        function closeHandler() {
            /* jshint validthis:true */
            $(this).dialog("destroy");
        }
        function createHandler() {
            setTimeout(centerOnScreen, 0), $(newDialog).focus(), $(activeTextInstance).on(ActiveText.Events.RESIZE, centerOnScreen);
        }
        function closeDialog() {
            return $(activeTextInstance).off(ActiveText.Events.RESIZE, centerOnScreen), $(newDialog).dialog("close"), 
            !1;
        }
        function closeBook() {
            return $(newDialog).dialog("close"), closeFunction && "function" == typeof closeFunction && closeFunction(), 
            !1;
        }
        var factory = ActiveText.UI.BasicControls.SimpleButtonFactory, prefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance), keepReadingSettings = {
            title: "Keep reading",
            tooltips: !1
        }, closeBookSettings = {
            title: "Close book",
            tooltips: !1
        }, dialogWidth = DIALOG_WIDTH, dialogHeight = DIALOG_HEIGHT, pathPrefix = prefix + "img/bugclub/", extension = "png";
        Modernizr.svg && (extension = "svg"), keepReadingSettings.style = {
            width: 204,
            height: 50
        }, keepReadingSettings.imageSrc = pathPrefix + "keepreading." + extension, keepReadingSettings.hoverImageSrc = pathPrefix + "keepreading-over." + extension, 
        keepReadingSettings.downImageSrc = pathPrefix + "keepreading-over." + extension, 
        closeBookSettings.style = {
            width: 204,
            height: 50
        }, closeBookSettings.imageSrc = pathPrefix + "closebook." + extension, closeBookSettings.hoverImageSrc = pathPrefix + "closebook-over." + extension, 
        closeBookSettings.downImageSrc = pathPrefix + "closebook-over." + extension;
        var keepReadingButton = factory.createSimpleButton(keepReadingSettings).click(closeDialog);
        keepReadingButton.attr("tabindex", 100);
        var closeBookButton = factory.createSimpleButton(closeBookSettings).click(closeBook);
        closeBookButton.attr("tabindex", 100);
        var template = $('<div class="content"><div class="summary-icons"></div><div class="buttons"></div></div>');
        template.find(".buttons").append(keepReadingButton, closeBookButton);
        var newDialog = template.dialog({
            width: dialogWidth,
            height: dialogHeight,
            modal: !0,
            appendTo: container,
            dialogClass: "summary-screenSVG " + skinCode,
            resizable: !1,
            close: closeHandler,
            create: createHandler
        });
        return centerOnScreen(), newDialog;
    }
    /**
     * @const
     * @type {number}
     */
    var DIALOG_HEIGHT = 280, DIALOG_WIDTH = 540;
    return {
        createDialog: openSummary
    };
}(ActiveText), /* global ActiveText, BugClub */
ActiveText.namespace("BugClub.SummaryScreenIconFactory"), BugClub.SummaryScreenIconFactory = function(ActiveText) {
    "use strict";
    function preloadIconImages(activeTextInstance) {
        function preload(images) {
            var i;
            for (i in images) $("<img/>")[0].src = images[i];
        }
        var pathPrefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/bugclub/legacy/ks2/";
        preload([ pathPrefix + "KS2_ActivityToggle_Green_face_yellow_1.png", pathPrefix + "KS2_ActivityToggle_yellow_2.png", pathPrefix + "KS2_ActivityToggle_yellow_1.png" ]);
    }
    function getIconHTMLForStatus(activeTextInstance, status) {
        var rtn = "", pathPrefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/bugclub/legacy/ks2/";
        return "completed" === status ? rtn = '<img class="icon" src="' + pathPrefix + 'KS2_ActivityToggle_Green_face_yellow_1.png" width="35" height="36" />' : "progress" === status ? rtn = '<img class="icon" src="' + pathPrefix + 'KS2_ActivityToggle_yellow_2.png" width="35" height="37" />' : "incomplete" === status && (rtn = '<img class="icon" src="' + pathPrefix + 'KS2_ActivityToggle_yellow_1.png" width="35" height="37" />'), 
        rtn;
    }
    return {
        preloadIconImages: preloadIconImages,
        getIconHTMLForStatus: getIconHTMLForStatus
    };
}(ActiveText);

/* global ActiveText */
var BugClub = BugClub || {};

/**
 * @class BugClub.Hotspots
 * @memberOf BugClub
 * @param keyStage {string}
 * @param options {*}
 * @returns {{init: init, keyStage: *, key: string}}
 * @constructor
 */
BugClub.Hotspots = function(keyStage, options) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     */
    function init(activeTextInstance) {
        function teardown() {
            $(activeTextInstance.options.containerElement).off("remove", teardown), controller.teardown();
        }
        activeTextInstance.options.keyStage = keyStage;
        var controller = new ActiveText.Hotspots.Controller(activeTextInstance, BugClub.Hotspots.Factory.createResourceIcon, activeTextInstance.options);
        controller.init(), BugClub.Hotspots.SCORMController(options, keyStage, activeTextInstance);
        var cssString = ".bugclub_icon div{background:none !important;cursor:pointer !important;}";
        ActiveText.CSSUtils.embedCSS(BugClub.DialogStyleText.getStyle(activeTextInstance) + cssString, "bugclub-hotspots"), 
        activeTextInstance.options && activeTextInstance.options.containerElement && $(activeTextInstance.options.containerElement).on("remove", teardown);
    }
    return {
        init: init,
        keyStage: keyStage,
        key: "bugclubhotspots"
    };
}, /* global ActiveText, BugClub, Modernizr */
ActiveText.namespace("BugClub.Hotspots.SCORMController"), /**
 * @class SCORMController
 * @memberOf BugClub.Hotspots
 * @param options {*}
 * @param keyStage {string}
 * @param activeTextInstance {ActiveText}
 * @param scormActivityData {BugClub.SCORM.ActivityData}
 * @returns {{}}
 * @constructor
 */
BugClub.Hotspots.SCORMController = function(options, keyStage, activeTextInstance) {
    "use strict";
    function getIdFromURI(uri) {
        var uriData = ActiveText.DataUtils.parseURI(uri), rtn = uri;
        return uriData.id && (rtn = uriData.id), uriData.seqid && (rtn = uriData.seqid), 
        rtn;
    }
    function init() {
        // attach event listeners
        var scormActivityData = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "bugclubscorm");
        scormActivityData && ($(activeTextInstance).on(ActiveText.SCORMIntegration.SCORM_DATA_UPDATED, updateStateOfHotspots), 
        $(activeTextInstance).on("activetext.hotspot.created", function(event, data) {
            var hotspotId = getIdFromURI(data.uri);
            scormActivityData.setIconForKey(hotspotId, data.hotspot), updateHotspotWithDataFromSCORMByKey(data.hotspot, hotspotId);
        }));
    }
    function updateStateOfHotspots(event, data) {
        function update() {
            var hotspot;
            // find the hotspots affected by this data change
            for (var activityId in resultsObject) hotspot = scormActivityData.getHotspotWithId(activityId), 
            hotspot ? updateHotspotWithDataFromSCORMByKey(hotspot, activityId) : debug.log("Error: Unable to find hotspot with Id of", activityId);
        }
        // get the SCORM results object
        var resultsObject, scormActivityData = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "bugclubscorm");
        resultsObject = data.items ? data.items : data, update(), setTimeout(update, 0);
    }
    /**
     * Splits the hotspot name to extract the value 'ks1' or 'ks2' and returns that.
     *
     * @param iconType {string}
     * @param defaultKeyStage {string}
     * @returns {string}
     */
    function keyForIcon(iconType, defaultKeyStage) {
        var key = defaultKeyStage, iconSuffix = iconType.split("-")[1];
        return iconSuffix && (key = iconSuffix), key;
    }
    function getSCORMStateForKey(key) {
        var rtn = 0, scormActivityData = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "bugclubscorm"), scormData = scormActivityData.getSCORMStateForKey(key);
        return scormData && void 0 !== scormData.completion_status && ("incomplete" === scormData.completion_status ? rtn = 1 : "completed" === scormData.completion_status && (rtn = 2)), 
        rtn;
    }
    function updateHotspotWithDataFromSCORMByKey(hotspot, key) {
        /**
         * @const
         * @type {string}
         */
        var images, pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), state = getSCORMStateForKey(key), iconType = hotspot.data() && hotspot.data().data && hotspot.data().data.icon ? hotspot.data().data.icon : "", isAKeyStageTwoIcon = "ks2" === keyForIcon(iconType, keyStage);
        if (isAKeyStageTwoIcon ? (images = [ pathToResources + "img/bugclub/legacy/ks2/hotspots/state-2.png", pathToResources + "img/bugclub/legacy/ks2/hotspots/state-1.png", pathToResources + "img/bugclub/legacy/ks2/hotspots/state-0.png" ], 
        $(hotspot).attr("src", images[state])) : (images = [ pathToResources + "img/bugclub/legacy/ks1/hotspots/state-2.png", pathToResources + "img/bugclub/legacy/ks1/hotspots/state-1.png", pathToResources + "img/bugclub/legacy/ks1/hotspots/state-0.png" ], 
        $(hotspot).attr("src", images[state])), $.browser.msie && !Modernizr.svg) {
            var img = $(hotspot), src = img.attr("src");
            img.attr("src", "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7").css("filter", "progid:DXImageTransform.Microsoft.AlphaImageLoader(enabled='true',sizingMethod='crop',src='" + src + "')");
        }
        $(hotspot).removeClass("complete,progress,incomplete"), $(hotspot).addClass(2 === state ? "complete" : 1 === state ? "progress" : "incomplete");
    }
    return init(), {};
}, /* global ActiveText, BugClub, ActiveText, Modernizr */
ActiveText.namespace("BugClub.Hotspots.Factory"), BugClub.Hotspots.Factory = function() {
    "use strict";
    function getIdFromURI(uri) {
        var uriData = ActiveText.DataUtils.parseURI(uri), rtn = uri;
        return uriData.id && (rtn = uriData.id), uriData.seqid && (rtn = uriData.seqid), 
        rtn;
    }
    function keyForIcon(iconType, defaultKeyStage) {
        var key = defaultKeyStage, iconSuffix = iconType.split("-")[1];
        return iconSuffix && (key = iconSuffix), key;
    }
    /**
     * @private
     * @param activeTextInstance {ActiveText}
     * @param hotspotDataObject {object}
     * @param containerDimensions {object}
     * @param key {string}
     * @returns {*|jQuery}
     */
    function createResourceIcon(activeTextInstance, hotspotDataObject, containerDimensions, options) {
        var key = keyForIcon(hotspotDataObject.data.icon, options.keyStage), iconType = hotspotDataObject.data.icon;
        hotspotDataObject.data.id = getIdFromURI(hotspotDataObject.data.uri);
        /**
         * @private
         * @type {string}
         */
        var iconWidth, resourceID = hotspotDataObject.data.id, xpos = hotspotDataObject.data.point[0], ypos = hotspotDataObject.data.point[1], pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), htmlString = "";
        iconWidth = "ks2" === key ? 60 : 118, htmlString = "ks2" === key ? "<img class='bugclub_icon noSwipe' src='" + pathToResources + "img/bugclub/legacy/ks2/hotspots/state-2.png' width='" + iconWidth + "' height='" + iconWidth + "' />" : "<img class='bugclub_icon noSwipe' src='" + pathToResources + "img/bugclub/legacy/ks1/hotspots/state-2.png' width='" + iconWidth + "' height='" + iconWidth + "' />";
        var hotspotCSS = ActiveText.Hotspots.Helper.getHotspotPositioningStyles({
            data: {
                point: [ xpos, ypos ]
            }
        }, iconWidth, containerDimensions), newIcon = $(htmlString).attr("data-resource-id", resourceID).attr("data-type", iconType).css(hotspotCSS);
        return newIcon.data(hotspotDataObject), newIcon;
    }
    return {
        createResourceIcon: createResourceIcon
    };
}(), /* global ActiveText, BugClub */
ActiveText.namespace("BugClub.SCORM.ActivityData"), BugClub.SCORM.ActivityData = function() {
    "use strict";
    function init() {
        dataCache = {}, scormDataCache = {};
    }
    function register(activeTextInstance) {
        deregister(activeTextInstance), $(activeTextInstance).on(ActiveText.Events.LOADED_OVERLAY_DATA, parseOverlayData), 
        $(activeTextInstance).on(ActiveText.SCORMIntegration.SCORM_DATA_UPDATED, updateStateOfHotspots);
    }
    function deregister(activeTextInstance) {
        $(activeTextInstance).off(ActiveText.Events.LOADED_OVERLAY_DATA, parseOverlayData), 
        $(activeTextInstance).off(ActiveText.SCORMIntegration.SCORM_DATA_UPDATED, updateStateOfHotspots);
    }
    function updateStateOfHotspots(event, data) {
        var resultsObject;
        resultsObject = data.items ? data.items : data;
        for (var uri in resultsObject) cacheSCORMStateForKey(uri, resultsObject[uri]);
    }
    function extractHotspotsFromOverlayData(data) {
        for (var allDivs, objects = [], i = 0, l = data.data.length; l > i; i++) {
            var item = data.data[i];
            "hotspot" === item.type && objects.push(item);
        }
        return allDivs = $(objects);
    }
    /**
     * @param id {String}
     * @returns {Object}
     */
    function getActivityById(id) {
        return activityCache[id.toString()];
    }
    function setActivityById(id, data) {
        activityCache || (activityCache = {}), id && "" !== id && (activityCache[id.toString()] = data);
    }
    function parseOverlayData(event, data) {
        var hotspotsData = extractHotspotsFromOverlayData(data);
        $(api).trigger(BugClub.SCORM.ActivityData.PARSED_DATA, {
            index: data.index,
            data: hotspotsData
        });
    }
    function getHotspotWithId(hotspotId) {
        return dataCache[hotspotId];
    }
    function setIconForKey(key, item) {
        dataCache[key] = item;
    }
    function cacheSCORMStateForKey(key, data) {
        scormDataCache[key] = data;
    }
    function getSCORMStateForKey(key) {
        return scormDataCache[key];
    }
    /**
     * @type {object}
     */
    var dataCache, activityCache, scormDataCache;
    init();
    var api = {
        init: register,
        deregister: deregister,
        parseOverlayData: parseOverlayData,
        getHotspotWithId: getHotspotWithId,
        setIconForKey: setIconForKey,
        cacheSCORMStateForKey: cacheSCORMStateForKey,
        getSCORMStateForKey: getSCORMStateForKey,
        getActivityById: getActivityById,
        setActivityById: setActivityById,
        key: "bugclubscorm"
    };
    return api;
}, /* global ActiveText, BugClub */
ActiveText.namespace("BugClub.SCORM.ActivityData.PARSED_DATA"), /**
 * @const
 * @type {string}
 */
BugClub.SCORM.ActivityData.PARSED_DATA = "bugclub.parsedData", /* global ActiveText, BugClub */
ActiveText.namespace("BugClub.DialogStyleText"), BugClub.DialogStyleText = function(ActiveText) {
    "use strict";
    function getStyle(activeTextInstance) {
        /**
         * @const
         * @type {string}
         */
        var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance);
        /**
         * @const
         * @type {string}
         */
        return ".ui-helper-hidden{display:none}.ui-helper-hidden-accessible{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.ui-helper-reset{margin:0;padding:0;border:0;outline:0;line-height:1.3;text-decoration:none;font-size:100%;list-style:none}.ui-helper-clearfix:before,.ui-helper-clearfix:after{content:'';display:table;border-collapse:collapse}.ui-helper-clearfix:after{clear:both}.ui-helper-clearfix{min-height:0}.ui-helper-zfix{width:100%;height:100%;top:0;left:0;position:absolute;opacity:0;filter:Alpha(Opacity=0)}.ui-front{z-index:1000}.ui-state-disabled{cursor:default!important}.ui-icon{display:block;text-indent:-99999px;overflow:hidden;background-repeat:no-repeat}.ui-widget-overlay{position:fixed;top:0;left:0;width:100%;height:100%}.ui-resizable{position:relative}.ui-resizable-handle{position:absolute;font-size:.1px;display:block}.ui-resizable-disabled .ui-resizable-handle,.ui-resizable-autohide .ui-resizable-handle{display:none}.ui-resizable-n{cursor:n-resize;height:7px;width:100%;top:-5px;left:0}.ui-resizable-s{cursor:s-resize;height:7px;width:100%;bottom:-5px;left:0}.ui-resizable-e{cursor:e-resize;width:7px;right:-5px;top:0;height:100%}.ui-resizable-w{cursor:w-resize;width:7px;left:-5px;top:0;height:100%}.ui-resizable-se{cursor:se-resize;width:12px;height:12px;right:1px;bottom:1px}.ui-resizable-sw{cursor:sw-resize;width:9px;height:9px;left:-5px;bottom:-5px}.ui-resizable-nw{cursor:nw-resize;width:9px;height:9px;left:-5px;top:-5px}.ui-resizable-ne{cursor:ne-resize;width:9px;height:9px;right:-5px;top:-5px}.ui-button{display:inline-block;position:relative;padding:0;line-height:normal;margin-right:.1em;cursor:pointer;vertical-align:middle;text-align:center;overflow:visible}.ui-button,.ui-button:link,.ui-button:visited,.ui-button:hover,.ui-button:active{text-decoration:none}.ui-button-icon-only{width:2.2em}button.ui-button-icon-only{width:2.4em}.ui-button-icons-only{width:3.4em}button.ui-button-icons-only{width:3.7em}.ui-button .ui-button-text{display:block;line-height:normal}.ui-button-text-only .ui-button-text{padding:.1em .2em}.ui-button-icon-only .ui-button-text,.ui-button-icons-only .ui-button-text{padding:.4em;text-indent:-9999999px}.ui-button-text-icon-primary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:.4em 1em .4em 2.1em}.ui-button-text-icon-secondary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:.4em 2.1em .4em 1em}.ui-button-text-icons .ui-button-text{padding-left:2.1em;padding-right:2.1em}input.ui-button{padding:.4em 1em}.ui-button-icon-only .ui-icon,.ui-button-text-icon-primary .ui-icon,.ui-button-text-icon-secondary .ui-icon,.ui-button-text-icons .ui-icon,.ui-button-icons-only .ui-icon{position:absolute;top:50%;margin-top:-8px}.ui-button-icon-only .ui-icon{left:50%;margin-left:-8px}.ui-button-text-icon-primary .ui-button-icon-primary,.ui-button-text-icons .ui-button-icon-primary,.ui-button-icons-only .ui-button-icon-primary{left:.5em}.ui-button-text-icon-secondary .ui-button-icon-secondary,.ui-button-text-icons .ui-button-icon-secondary,.ui-button-icons-only .ui-button-icon-secondary{right:.5em}.ui-buttonset{margin-right:7px}.ui-buttonset .ui-button{margin-left:0;margin-right:-.3em}input.ui-button::-moz-focus-inner,button.ui-button::-moz-focus-inner{border:0;padding:0}.ui-dialog{position:absolute;top:0;left:0;padding:0em;outline:0;-moz-box-shadow: 0 4px 8px rgba(0,0,0,0.5);-webkit-box-shadow: 0 4px 8px rgba(0,0,0,0.5);box-shadow: 0 4px 8px rgba(0,0,0,0.5);}.ui-dialog .ui-dialog-titlebar{padding:0 .2em;position:relative}.ui-dialog .ui-dialog-title{float:left;margin:.1em 0;white-space:nowrap;width:90%;overflow:hidden;text-overflow:ellipsis}.ui-dialog .ui-dialog-titlebar-close{position:absolute;right:.3em;top:50%;width:21px;margin:-10px 0 0 0;padding:1px;height:20px}.ui-dialog .ui-dialog-content{position:relative;border:0;padding:.5em;background:0;overflow:auto}.ui-dialog .ui-dialog-buttonpane{text-align:left;border-width:1px 0 0;background-image:none;margin-top:.5em;padding:.3em 1em .5em .4em}.ui-dialog .ui-dialog-buttonpane .ui-dialog-buttonset{float:right}.ui-dialog .ui-dialog-buttonpane button{margin:.5em .4em .5em 0;cursor:pointer}.ui-dialog .ui-resizable-se{width:12px;height:12px;right:-5px;bottom:-5px;background-position:16px 16px}.ui-draggable .ui-dialog-titlebar{cursor:move}.ui-widget .ui-widget{font-size:1em}.ui-widget input,.ui-widget select,.ui-widget textarea,.ui-widget button{font-family:Helvetica,Arial,sans-serif;font-size:1em}.ui-widget-content{border:1px solid #5693af;background:#649393;color:#222}.ui-widget-content .content{background:#fff;padding:.5em;}.ui-widget-content a{color:#222}.ui-widget-header{background:#649393 url(" + pathToResources + "img/bugclub/dialog/ui-bg_flat_0_649393_40x100.png) 50% 50% repeat-x;color:#fff;font-weight:bold}.ui-widget-header a{color:#fff}.ui-state-default,.ui-widget-content .ui-state-default,.ui-widget-header .ui-state-default{border:1px solid #5693af;background:#c8eafc url(" + pathToResources + "img/bugclub/dialog/ui-bg_glass_100_c8eafc_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#000}.ui-state-default a,.ui-state-default a:link,.ui-state-default a:visited{color:#000;text-decoration:none}.ui-state-hover,.ui-widget-content .ui-state-hover,.ui-widget-header .ui-state-hover,.ui-state-focus,.ui-widget-content .ui-state-focus,.ui-widget-header .ui-state-focus{border:1px solid #5693af;background:#a9e0fa url(" + pathToResources + "img/bugclub/dialog/ui-bg_glass_100_a9e0fa_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#000}.ui-state-hover a,.ui-state-hover a:hover,.ui-state-hover a:link,.ui-state-hover a:visited{color:#000;text-decoration:none}.ui-state-active,.ui-widget-content .ui-state-active,.ui-widget-header .ui-state-active{border:1px solid #5693af;background:#ffc70b url(" + pathToResources + "img/bugclub/dialog/ui-bg_glass_100_ffc70b_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#000}.ui-state-active a,.ui-state-active a:link,.ui-state-active a:visited{color:#000;text-decoration:none}.ui-state-highlight,.ui-widget-content .ui-state-highlight,.ui-widget-header .ui-state-highlight{border:1px solid #f47721;background:#ffc70b url(" + pathToResources + "img/bugclub/dialog/ui-bg_glass_100_ffc70b_1x400.png) 50% 50% repeat-x;color:#000}.ui-state-highlight a,.ui-widget-content .ui-state-highlight a,.ui-widget-header .ui-state-highlight a{color:#000}.ui-state-error,.ui-widget-content .ui-state-error,.ui-widget-header .ui-state-error{border:1px solid #cd0a0a;background:#fef1ec url(" + pathToResources + "img/bugclub/dialog/ui-bg_glass_95_fef1ec_1x400.png) 50% 50% repeat-x;color:#cd0a0a}.ui-state-error a,.ui-widget-content .ui-state-error a,.ui-widget-header .ui-state-error a{color:#cd0a0a}.ui-state-error-text,.ui-widget-content .ui-state-error-text,.ui-widget-header .ui-state-error-text{color:#cd0a0a}.ui-priority-primary,.ui-widget-content .ui-priority-primary,.ui-widget-header .ui-priority-primary{font-weight:bold}.ui-priority-secondary,.ui-widget-content .ui-priority-secondary,.ui-widget-header .ui-priority-secondary{opacity:.7;filter:Alpha(Opacity=70);font-weight:normal}.ui-state-disabled,.ui-widget-content .ui-state-disabled,.ui-widget-header .ui-state-disabled{opacity:.35;filter:Alpha(Opacity=35);background-image:none}.ui-state-disabled .ui-icon{filter:Alpha(Opacity=35)}.ui-icon{width:16px;height:16px}.ui-icon,.ui-widget-content .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_ffffff_256x240.png)}.ui-widget-header .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_91d0d0_256x240.png)}.ui-state-default .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_000000_256x240.png)}.ui-state-hover .ui-icon,.ui-state-focus .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_000000_256x240.png)}.ui-state-active .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_000000_256x240.png)}.ui-state-highlight .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_000000_256x240.png)}.ui-state-error .ui-icon,.ui-state-error-text .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_cd0a0a_256x240.png)}.ui-dialog .ui-dialog-titlebar-close {background:transparent !important;outline:none;width:26px;height:26px;margin-top:4px;margin-right:1px;top:0;}.ui-dialog .ui-dialog-titlebar-close.ui-button-icon-only .ui-icon {top:0;left:0;margin:0;padding:0;}.ui-icon-closethick {display:none;}.ui-dialog .ui-dialog-titlebar-close{width:26px;height:26px;background-size:contain;background:transparent url(" + pathToResources + "img/bugclub/closesmall.svg) top left no-repeat !important;border:none;margin:-10px;}.ui-dialog .ui-dialog-titlebar-close.ui-state-hover {background:transparent url(" + pathToResources + "img/bugclub/closesmall-over.svg) top left no-repeat !important;border:none;}.ui-icon-grip-dotted-vertical{background-position:0 -224px}.ui-icon-grip-dotted-horizontal{background-position:-16px -224px}.ui-icon-grip-solid-vertical{background-position:-32px -224px}.ui-icon-grip-solid-horizontal{background-position:-48px -224px}.ui-icon-gripsmall-diagonal-se{background-position:-64px -224px}.ui-icon-grip-diagonal-se{background-position:-80px -224px}.ui-corner-all,.ui-corner-top,.ui-corner-left,.ui-corner-tl{border-top-left-radius:6px}.ui-corner-all,.ui-corner-top,.ui-corner-right,.ui-corner-tr{border-top-right-radius:6px}.ui-corner-all,.ui-corner-bottom,.ui-corner-left,.ui-corner-bl{border-bottom-left-radius:6px}.ui-corner-all,.ui-corner-bottom,.ui-corner-right,.ui-corner-br{border-bottom-right-radius:6px}.ui-widget-overlay{background:#000 url(" + pathToResources + "img/bugclub/dialog/ui-bg_flat_50_000000_40x100.png) 50% 50% repeat-x;opacity:.3;filter:Alpha(Opacity=30)}.ui-widget-shadow{margin:-8px 0 0 -8px;padding:8px;background:#000 url(" + pathToResources + "img/bugclub/dialog/ui-bg_flat_50_000000_40x100.png) 50% 50% repeat-x;opacity:.25;filter:Alpha(Opacity=25);border-radius:8px}input[type=text]::-ms-clear{display:none;width:0;height:0}";
    }
    return {
        getStyle: getStyle
    };
}(ActiveText), /* global ActiveText, BugClub, Modernizr */
BugClub.SummaryScreen = BugClub.SummaryScreen || {}, BugClub.SummaryScreen.DialogStyleText = function(ActiveText) {
    "use strict";
    function getStyle(activeTextInstance) {
        /**
         * @const
         * @type {string}
         */
        var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), extension = "png";
        /**
         * @const
         * @type {string}
         */
        return Modernizr.svg && (extension = "svg"), ".ui-widget-content.summary-screenSVG{background:url(" + pathToResources + "img/bugclub/popup1." + extension + ") top left no-repeat transparent;z-index:2010;border:none;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;}.ui-widget-content.summary-screenSVG .content,.ui-widget-content.summary-screenSVG .ui-dialog-titlebar{background:transparent !important}.ui-widget-content.summary-screenSVG .buttons{margin-top:75px;}.ui-widget-content.summary-screenSVG .button{margin:26px 26px 0;}.ui-dialog,.ui-dialog *{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;}";
    }
    return {
        getStyle: getStyle
    };
}(ActiveText), /* global BugClub */
BugClub.StudentControlsKS1 = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "zoom", primary = options.primary ? options.primary : "previous,readtome,next", rightButtons = options.rightButtons ? options.rightButtons : "exit";
    return options.leftButtons = leftButtons, options.primary = primary, options.rightButtons = rightButtons, 
    new BugClub.Controls(options);
}, /* global BugClub */
BugClub.StudentControlsKS2 = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "zoom,viewtoggle", primary = options.primary ? options.primary : "", rightButtons = options.rightButtons ? options.rightButtons : "activitystructure,previous,quicknav,next,exit";
    return options.leftButtons = leftButtons, options.primary = primary, options.rightButtons = rightButtons, 
    new BugClub.Controls(options);
}, /* global BugClub */
BugClub.TeacherControlsKS1 = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "zoom,drawing,bugclubhotspots", primaryButtons = options.primaryButtons ? options.primaryButtons : "previous,readtome,next", rightButtons = options.rightButtons ? options.rightButtons : "quicknav,exit";
    return options.leftButtons = leftButtons, options.primary = primaryButtons, options.rightButtons = rightButtons, 
    new BugClub.Controls(options);
}, /* global BugClub */
BugClub.TeacherControlsKS2 = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "zoom,viewtoggle,drawing,bugclubhotspots", primary = options.primary ? options.primary : "", rightButtons = options.rightButtons ? options.rightButtons : "activitystructure,previous,quicknav,next,exit";
    return options.leftButtons = leftButtons, options.primary = primary, options.rightButtons = rightButtons, 
    new BugClub.Controls(options);
}, /* global ActiveText, BugClub, Modernizr */
ActiveText.namespace("BugClub.Controls"), BugClub.Controls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        /**
         * @type {Function}
         */
        var closeFunction, summaryScreenExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "summaryscreen");
        summaryScreenExtension && (closeFunction = summaryScreenExtension.openSummary), 
        options || (options = {});
        var leftButtons = options.leftButtons, primary = options.primary, rightButtons = options.rightButtons;
        activeTextInstance.options.allowReadToMe === !1 && (leftButtons = _.without(leftButtons.split(","), "readtome", "readtomeExtended").toString(), 
        void 0 !== primary && (options.primary = _.without(options.primary.split(","), "readtome", "readtomeExtended").toString()), 
        rightButtons = _.without(rightButtons.split(","), "readtome", "readtomeExtended").toString()), 
        options.leftButtons = leftButtons, void 0 !== primary && (options.primary = primary), 
        options.rightButtons = rightButtons;
        /**
         * @type {String}
         */
        var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), globalPath = ActiveText.SkinUtils.getPathToGlobalResource(), cssString = '@font-face{font-family:"heinemann-special";src:url("' + globalPath + 'font/1cf6f702b2f7c3f363d7a7475b771ad2519c7ae2.eot");src:url("' + globalPath + '/font/1cf6f702b2f7c3f363d7a7475b771ad2519c7ae2.eot?#iefix") format("embedded-opentype"),url("' + globalPath + 'font/8780f55bdc4d11d74eb8c065b895b242730874ca.woff") format("woff");font-weight: bold;font-style: italic;}@font-face{font-family:"heinemann-special";src:url("' + globalPath + 'font/be8783ef363b706a9d4e4a04dba99df31523ac38.eot");src:url("' + globalPath + '/font/be8783ef363b706a9d4e4a04dba99df31523ac38.eot?#iefix") format("embedded-opentype"),url("' + globalPath + 'font/74727931f38ae3d96fb103fa3e9f2ab609c07e0e.woff") format("woff");font-weight: normal;font-style: normal;}@font-face{font-family:"heinemann-special";src:url("' + globalPath + 'font/a14bed103c175e7e5f080c8f2912687e34e02218.eot");src:url("' + globalPath + '/font/a14bed103c175e7e5f080c8f2912687e34e02218.eot?#iefix") format("embedded-opentype"),url("' + globalPath + 'font/e916834581bf5571da0e6c64ada6d4a578caa1ac.woff") format("woff");font-weight: normal;font-style: italic;}@font-face{font-family:"heinemann-special";src:url("' + globalPath + 'font/d503710c5cb5a0c4ba67fcd57b8113bd9e6436cf.eot");src:url("' + globalPath + '/font/d503710c5cb5a0c4ba67fcd57b8113bd9e6436cf.eot?#iefix") format("embedded-opentype"),url("' + globalPath + 'font/f353d99d6d18eef861d08c4ccf61476a7e9996e3.woff") format("woff");font-weight: bold;font-style: normal;}.quicknav input{font-family:"heinemann-special";font-weight:normal;border: 3px solid #fff;background: #e6e6e6;background: -moz-linear-gradient(top, #e6e6e6 0%, #ffffff 100%);background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,#e6e6e6), color-stop(100%,#ffffff));background: -webkit-linear-gradient(top, #e6e6e6 0%,#ffffff 100%);background: -o-linear-gradient(top, #e6e6e6 0%,#ffffff 100%);background: -ms-linear-gradient(top, #e6e6e6 0%,#ffffff 100%);background: linear-gradient(to bottom, #e6e6e6 0%,#ffffff 100%);' + ($.browser.msie && 9 === $.browser.version ? "" : "background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIHZpZXdCb3g9IjAgMCAxIDEiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiPgo8bGluZWFyR3JhZGllbnQgaWQ9Imc1MjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjAlIiB5Mj0iMTAwJSI+CjxzdG9wIHN0b3AtY29sb3I9IiNFNkU2RTYiIG9mZnNldD0iMCIvPjxzdG9wIHN0b3AtY29sb3I9IiNGRkZGRkYiIG9mZnNldD0iMC45Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxyZWN0IHg9IjAiIHk9IjAiIHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9InVybCgjZzUyMSkiIC8+Cjwvc3ZnPg==);") + "font-size: 18px;}";
        ActiveText.CSSUtils.embedCSS(cssString, "bugclub-skin-styles");
        /**
         * @type {String}
         */
        var pathPrefix = pathToResources + "img/bugclub/", extension = ".png";
        Modernizr.svg && (extension = ".svg");
        var controls = new ActiveText.UI.BasicControls(activeTextInstance, {
            primary: primary,
            leftButtons: leftButtons,
            rightButtons: rightButtons,
            leftButtonOptions: {
                left: "10px"
            },
            rightButtonOptions: {
                right: "10px"
            },
            openByDefault: !0,
            overlay: !1,
            barHeight: 66,
            barStyles: {
                backgroundColor: "#9BCA3B",
                height: 66,
                fontSize: "18px"
            },
            minWidth: 800,
            scaleMode: "scale",
            buttonStyles: {
                width: 50,
                height: 50,
                background: "transparent"
            },
            hoverStyles: {
                background: "transparent"
            },
            options: {
                readtomeExtended: {
                    readtome: {
                        style: {
                            width: 186,
                            height: 50
                        },
                        imageSrc: pathPrefix + "large-readtome" + extension,
                        hoverImageSrc: pathPrefix + "large-readtome-over" + extension,
                        downImageSrc: pathPrefix + "large-readtome-over" + extension,
                        disabledImageSrc: pathPrefix + "large-readtome-disabled" + extension,
                        toggleButtonImageSrc: pathPrefix + "large-readtome-active" + extension,
                        toggleButtonHoverImageSrc: pathPrefix + "large-readtome-over" + extension,
                        enableBehaviour: "show"
                    },
                    done: {
                        style: {
                            width: 104,
                            height: 50
                        },
                        imageSrc: pathPrefix + "done-inactive" + extension,
                        hoverImageSrc: pathPrefix + "done-inactive" + extension,
                        downImageSrc: pathPrefix + "done-inactive" + extension,
                        toggleButtonImageSrc: pathPrefix + "done" + extension,
                        toggleButtonHoverImageSrc: pathPrefix + "done-over" + extension,
                        enableBehaviour: "show"
                    }
                },
                readtome: {
                    style: {
                        width: 186,
                        height: 50
                    },
                    imageSrc: pathPrefix + "large-readtome" + extension,
                    hoverImageSrc: pathPrefix + "large-readtome-over" + extension,
                    downImageSrc: pathPrefix + "large-readtome-over" + extension,
                    disabledImageSrc: pathPrefix + "large-readtome-disabled" + extension,
                    toggleButtonImageSrc: pathPrefix + "large-readtome-active" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "large-readtome-over" + extension,
                    enableBehaviour: "show"
                },
                zoom: {
                    //                    imageSrc: pathPrefix + 'zoomout' + extension,
                    imageSrc: pathPrefix + "zoomout-active" + extension,
                    hoverImageSrc: pathPrefix + "zoomout-over" + extension,
                    downImageSrc: pathPrefix + "zoomout-over" + extension,
                    toggleButtonImageSrc: pathPrefix + "zoomin" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "zoomin-over" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "zoomin-over" + extension
                },
                bugclubhotspots: {
                    imageSrc: pathPrefix + "activitytoggle-disabled" + extension,
                    hoverImageSrc: pathPrefix + "activitytoggle-disabled" + extension,
                    downImageSrc: pathPrefix + "activitytoggle-disabled" + extension,
                    disabledImageSrc: pathPrefix + "activitytoggle" + extension,
                    toggleButtonImageSrc: pathPrefix + "activitytoggle" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "activitytoggle-over" + extension,
                    enableBehaviour: "show"
                },
                viewtoggle: {
                    imageSrc: pathPrefix + "dps" + extension,
                    hoverImageSrc: pathPrefix + "dps-over" + extension,
                    downImageSrc: pathPrefix + "dps-over" + extension,
                    toggleButtonImageSrc: pathPrefix + "sps" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "sps-over" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "sps-over" + extension
                },
                previous: {
                    style: {
                        width: 96,
                        height: 50
                    },
                    imageSrc: pathPrefix + "back" + extension,
                    hoverImageSrc: pathPrefix + "back-over" + extension,
                    downImageSrc: pathPrefix + "back-over" + extension,
                    disabledImageSrc: pathPrefix + "back-disabled" + extension,
                    enableBehaviour: "show"
                },
                next: {
                    style: {
                        width: 96,
                        height: 50
                    },
                    imageSrc: pathPrefix + "next" + extension,
                    hoverImageSrc: pathPrefix + "next-over" + extension,
                    downImageSrc: pathPrefix + "next-over" + extension,
                    disabledImageSrc: pathPrefix + "next-disabled" + extension,
                    enableBehaviour: "show"
                },
                drawing: {
                    imageSrc: pathPrefix + "drawing" + extension,
                    hoverImageSrc: pathPrefix + "drawing-over" + extension,
                    downImageSrc: pathPrefix + "drawing-over" + extension,
                    toggleButtonImageSrc: pathPrefix + "drawing-active" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "drawing-over" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "drawing-active" + extension
                },
                activitystructure: {
                    style: {
                        width: 122,
                        height: 50
                    },
                    imageSrc: pathPrefix + "content" + extension,
                    hoverImageSrc: pathPrefix + "content-over" + extension,
                    downImageSrc: pathPrefix + "content-over" + extension,
                    toggleButtonImageSrc: pathPrefix + "content-active" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "content-over" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "content-over" + extension
                },
                quicknav: {
                    style: {
                        border: "",
                        background: "",
                        width: "auto",
                        padding: "13px"
                    },
                    popupnavwidth: 293,
                    textFormatSinglePage: "%%1 of %%2",
                    textFormatMultiPage: "%%1/%%2 of %%3"
                },
                exit: {
                    style: {
                        width: 50,
                        height: 50
                    },
                    imageSrc: pathPrefix + "close" + extension,
                    hoverImageSrc: pathPrefix + "close-over" + extension,
                    downImageSrc: pathPrefix + "close-over" + extension,
                    closeFunction: closeFunction
                }
            }
        });
        activeTextInstance.extensions.push(controls);
    }
    return {
        init: init
    };
}, /* global ActiveText, GenericAPIAdaptor, BugClub */
ActiveText.SCORM = ActiveText.SCORM || {}, /**
 * @class Pipwerks
 * @memberOf ActiveText.SCORM
 * @returns {{init: init, key: string, scormInterfaceReady: scormInterfaceReady, launchActivity: launchActivity, closeEBook: closeEBook}}
 * @constructor
 */
ActiveText.SCORM.Pipwerks = function() {
    "use strict";
    /**
	 * Makes the instance of ActiveText available to this class.
	 * @param instance {ActiveText}
	 */
    function init(instance) {
        activeTextInstance = instance, checkAllInterfacesAreReady();
    }
    /**
	 * It's possible that the workflow won't be init > scormInterfaceReady, so this function checks that
	 * all of the dependencies are set before we start working with the data, or we'll get errors.
	 */
    function checkAllInterfacesAreReady() {
        activeTextInstance && scormInterface && ebookLauncher && whenAllInterfacesAreReady();
    }
    /**
	 * Once we're ready, we start.
	 */
    function whenAllInterfacesAreReady() {
        // likelyhood is that we're already on a page so our 'resume' page index won't fire a new event unless
        // the user starts interacting, so we just want to stash the current page number at this point.
        if (!hasSetInitialPageNumber) {
            var currentPageNumber = activeTextInstance.model.getCurrentPageNumber();
            if (scormInterface && scormInterface.savePageNumber) try {
                scormInterface.savePageNumber(currentPageNumber);
            } catch (e) {
                debug.log("Failed to save current page number:", e);
            }
            hasSetInitialPageNumber = !0;
        }
        hasLoadedInitialState || (hasLoadedInitialState = !0), // bind events to the future page turn events.
        $(activeTextInstance).on(ActiveText.Commands.GO_TO_PAGE, onPageChange);
        var scormDataInstance = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "bugclubscorm");
        // when the hotspot overlays are loaded for a page, we need to also load their status
        $(scormDataInstance).on(BugClub.SCORM.ActivityData.PARSED_DATA, loadStatusForActivities);
        var overlayDataLoader = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "overlaydataloader");
        if (overlayDataLoader) for (var y = 0, ln = activeTextInstance.data.getFlatListOfNavigation().length; ln > y; y++) overlayDataLoader.loadDataForPageIndex(y);
    }
    /**
	 * When an overlay is loaded and parsed (to extract the proper id from the uri) get their status
	 * @param event {object}
	 * @param data {{ index : number, data : Array }}
	 */
    function loadStatusForActivities(event, data) {
        for (var immediateResponse = {}, arrayOfActivities = data.data, i = 0, l = arrayOfActivities.length; l > i; i++) if (arrayOfActivities[i].data.seqid) {
            var activityId = arrayOfActivities[i].data.seqid, baseScormKey = "cmi.objectives." + activityId + ".";
            immediateResponse[activityId.toString()] = {
                completion_status: scormInterface.getScormValue(baseScormKey + "completion_status"),
                progress_measure: scormInterface.getScormValue(baseScormKey + "progress_measure"),
                score: {
                    max: scormInterface.getScormValue(baseScormKey + "score.max"),
                    raw: scormInterface.getScormValue(baseScormKey + "score.raw")
                },
                success_status: scormInterface.getScormValue(baseScormKey + "success_status")
            };
        }
        $(activeTextInstance).trigger(ActiveText.SCORMIntegration.SCORM_DATA_UPDATED, immediateResponse);
    }
    /**
	 * Sets up the connection between the pipwerks SCORM classes and ActiveText.
	 * @param pipwerksEBookClass {{ ebookLauncher : function, savePageNumber : function }}
	 */
    function scormInterfaceReady(pipwerksEBookClass) {
        ebookLauncher = pipwerksEBookClass.ebookLauncher, scormInterface = ebookLauncher.scormClient, 
        phantom || debug.log("ActiveText.SCORM.Pipwerks: SCORM interface is ready:", scormInterface, ebookLauncher), 
        checkAllInterfacesAreReady();
    }
    /**
	 * Responds to page change events from ActiveText and forwards them to the
	 * scormInterface.savePageNumber function.
	 * @param event {object}
	 * @param data {object}
	 */
    function onPageChange(event, data) {
        scormInterface && scormInterface.savePageNumber && setTimeout(function() {
            try {
                scormInterface.savePageNumber(data.toPage);
            } catch (e) {
                debug.log("Failed to save current page number:", e);
            }
        }, 0);
    }
    /**
	 * Calls out to the ebookLauncher class and launches an activity.
	 * @param attrStr {string} The identifier for the activity id.
	 */
    function launchActivity(attrStr) {
        ebookLauncher && "function" == typeof ebookLauncher.launchActivity ? ebookLauncher.launchActivity(attrStr) : debug.debug("Unable to launch activity because ebookLauncher does not exist or ebookLauncher.launchActivity is not a function.", ebookLauncher);
    }
    function closeEBook() {
        ebookLauncher && "function" == typeof ebookLauncher.closeEbook ? ebookLauncher.closeEbook() : (window.open("", "_self", ""), 
        window.close());
    }
    var activeTextInstance, scormInterface, ebookLauncher, ua = navigator.userAgent, phantom = /phantom/i.test(ua), hasSetInitialPageNumber = !1, hasLoadedInitialState = !1;
    return {
        init: init,
        key: "pipwerks",
        scormInterfaceReady: scormInterfaceReady,
        launchActivity: launchActivity,
        closeEBook: closeEBook
    };
};

/* global ActiveText, ActiveText, Modernizr, BugClub */
var BugClubAus = BugClubAus || {};

/**
 * @class Player
 * @memberOf BugClub
 * @param {string} skinCode
 * @returns {{init: init, key: string}}
 * @constructor
 */
BugClubAus.Player = function(skinCode) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param dependencyKey {String}
     * @param skinCode {String}
     */
    function checkDependency(activeTextInstance, dependencyKey, skinCode) {
        var newClass, hasExtensionForDependency = Boolean(ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, dependencyKey));
        if (!hasExtensionForDependency) switch (dependencyKey) {
          case "overlaydataloader":
            newClass = new ActiveText.OverlayData(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubhotspots":
            newClass = new BugClub.Hotspots(skinCode), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "smildatamodel":
            newClass = new ActiveText.SMILDataModel(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "smildataloader":
            newClass = new ActiveText.SMILDataLoader(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "readtome":
            activeTextInstance.options.allowReadToMe !== !1 && (newClass = new ActiveText.ReadToMe(), 
            newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass));
            break;

          case "summaryscreen":
            newClass = new BugClubAus.SummaryScreen(skinCode), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "soundeffects":
            newClass = new ActiveText.SoundEffects(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "keyboardintegration":
            newClass = new ActiveText.KeyboardIntegration(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "drawingtools":
            newClass = new ActiveText.DrawingTools(), newClass.supported() && (newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass));
            break;

          case "readingcomplete":
            newClass = new ActiveText.ReadingComplete(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubactivitysummary":
            newClass = new BugClub.ActivitySummaryCollective(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubscorm":
            newClass = new BugClub.SCORM.ActivityData(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
        }
    }
    function setDefaultPropertiesFor(activeTextInstance) {
        function hotspotClickHandler(e) {
            /* jshint validthis:true */
            var activityIsComplete = $(e.currentTarget).hasClass("complete");
            if (activityIsComplete) debug.log("Not launching activity because activity is completed."); else {
                var data = $(e.currentTarget).data(), hotspotUri = data.data.uri, scormIntegrationExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "pipwerks");
                scormIntegrationExtension ? (debug.log("scormIntegrationExtension.launchActivity();", data), 
                scormIntegrationExtension.launchActivity(hotspotUri)) : (debug.log("Launching Hotspot Activity : " + hotspotUri), 
                setTimeout(function() {
                    alert("Launching Hotspot Activity : " + hotspotUri);
                }, 0));
            }
        }
        function audioPlaybackController(value) {
            var rtn, readToMe = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "readtome");
            if (readToMe) {
                var state = readToMe.getState();
                isUsingAutoPlay = state.shouldAutoPlay, void 0 === value ? rtn = state.shouldAutoPlay : state.shouldAutoPlay = Boolean(readToMe.options && readToMe.options.autoplay);
            }
            return rtn;
        }
        ActiveText.BrowserUtils.isMobileDevice && (activeTextInstance.options.allowAnimation = !1);
        var pathToAssets = ActiveText.SkinUtils.getPathToResources(activeTextInstance);
        activeTextInstance.options.containerElement.css(/**
         * Browser detection is bad, but IE is worse.
         *
         * Some versions of IE support SVG, and they support it for background images, but they don't scale it correctly
         * because they're dumb. So we're forced to do shit like this - using non SVG versions of images for the background.
         */
        !Modernizr.svg || navigator.userAgent.match(/(msie|trident)\/?\s*(\.?\d+(\.\d+)*)/i) ? {
            background: "url(" + pathToAssets + "img/bugclub/backdrop.png) no-repeat center center",
            filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src="' + pathToAssets + 'img/bugclub/backdrop.png", sizingMethod="scale")',
            MsFilter: "'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\"" + pathToAssets + 'img/bugclub/backdrop.png", sizingMethod="scale")\'',
            backgroundSize: "cover"
        } : {
            background: "url(" + pathToAssets + "img/bugclub/background.svg) no-repeat center center",
            backgroundSize: "cover"
        });
        /**
         * @type {Boolean}
         */
        var isUsingAutoPlay;
        void 0 === activeTextInstance.options.allowOverlap && (activeTextInstance.options.allowOverlap = !1), 
        void 0 === activeTextInstance.options.hotspotClickFunction && (activeTextInstance.options.hotspotClickFunction = hotspotClickHandler), 
        void 0 === activeTextInstance.options.audioPlaybackController && (activeTextInstance.options.audioPlaybackController = audioPlaybackController);
    }
    /**
     * @param activeTextInstance {ActiveText}
     */
    function init(activeTextInstance) {
        setDefaultPropertiesFor(activeTextInstance);
        for (var dependencyKey, dependencies = [ "overlaydataloader", "bugclubactivitysummary", "bugclubscorm", "bugclubhotspots", "smildatamodel", "smildataloader", "readtome", "summaryscreen", "soundeffects", "keyboardintegration", "drawingtools", "readingcomplete" ], i = 0, l = dependencies.length; l > i; i++) dependencyKey = dependencies[i], 
        checkDependency(activeTextInstance, dependencyKey, skinCode);
        $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, function() {
            if (activeTextInstance.utils.isFullWindowScalingMode()) {
                var rotationControl = new ActiveText.ViewOrientationDetection();
                rotationControl.init(activeTextInstance), activeTextInstance.extensions.push(rotationControl);
            }
        });
    }
    return {
        init: init,
        key: "bugclubaus"
    };
}, /* global ActiveText, BugClubAus, BugClub */
ActiveText.namespace("BugClubAus.SummaryScreen"), BugClubAus.SummaryScreen = function(skinCode) {
    "use strict";
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        activeTextInstance = instance, ActiveText.CSSUtils.embedCSS(BugClub.DialogStyleText.getStyle(activeTextInstance), "bugclubaus-dialog-styles"), 
        ActiveText.CSSUtils.embedCSS(BugClubAus.SummaryScreen.DialogStyleText.getStyle(activeTextInstance), "bugclubaus-summary-screen-styles"), 
        summaryHTMLCache = [], summaryHTMLCache[0] = "", BugClubAus.SummaryScreenIconFactory.preloadIconImages(activeTextInstance, skinCode), 
        summaryData = new BugClub.ActivitySummaryIndividual(), summaryData.init(instance), 
        $(summaryData).on("change", updateHotspotIcon), $(activeTextInstance).on(ActiveText.Events.RESOURCES_LOADED, preloadActivityData);
    }
    /**
     * @param event {Event}
     */
    function updateHotspotIcon(event, data) {
        summaryHTMLCache[data.activityId] = BugClubAus.SummaryScreenIconFactory.getIconHTMLForStatus(activeTextInstance, data.status, skinCode), 
        updateHotspotIconsOnDialog();
    }
    function preloadActivityData() {
        var overlayDataLoader = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "overlaydataloader");
        if (overlayDataLoader) for (var i = 0, l = activeTextInstance.data.getFlatListOfNavigation().length; l > i; i++) //overlayDataLoader.loadDataForIndex(i);
        overlayDataLoader.loadDataForPageIndex(i);
    }
    function openSummary() {
        if (newDialog) newDialog.open(); else {
            closeSummary();
            var closeFunction, container = activeTextInstance.options.containerElement, scormIntegrationFunction = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "pipwerks");
            scormIntegrationFunction && (closeFunction = scormIntegrationFunction.closeEBook), 
            newDialog = BugClubAus.SummaryScreenDialogFactory.createDialog(activeTextInstance, container, skinCode, closeFunction), 
            newDialog.on({
                dialogcreate: updateHotspotIconsOnDialog,
                dialogclose: removeRefsToDialog
            }), preloadActivityData();
        }
    }
    function removeRefsToDialog() {
        newDialog = null;
    }
    /**
     * @returns {boolean}
     */
    function updateHotspotIconsOnDialog() {
        var rtn = !1;
        if (newDialog) {
            var existingHTML = $(summaryHTMLCache.join("")), iconsContainer = newDialog.find(".summary-icons");
            iconsContainer.html(existingHTML);
            var allIcons = iconsContainer.find(".icon"), containerWidth = iconsContainer.width(), width = allIcons.width(), numIcons = allIcons.length;
            allIcons.css({
                margin: "15px " + Math.floor((containerWidth - numIcons * width) / numIcons) / 2 + "px"
            }), rtn = !0;
        }
        return rtn;
    }
    /**
     * @returns {boolean}
     */
    function closeSummary() {
        var rtn = !1;
        return newDialog && (newDialog.dialog("close"), rtn = !0), rtn;
    }
    /**
     * @type {ActiveText}
     */
    var activeTextInstance, summaryData, summaryHTMLCache, newDialog;
    return {
        init: init,
        openSummary: openSummary,
        closeSummary: closeSummary,
        key: "summaryscreen"
    };
}, /* global ActiveText, BugClubAus */
ActiveText.namespace("BugClubAus.SummaryScreenDialogFactory"), BugClubAus.SummaryScreenDialogFactory = function(ActiveText) {
    "use strict";
    function openSummary(activeTextInstance, container, skinCode, closeFunction) {
        function centerOnScreen() {
            $(newDialog).parent().css({
                top: (container.height() - dialogHeight) / 2,
                left: (container.width() - dialogWidth) / 2
            });
        }
        function closeHandler() {
            /* jshint validthis:true */
            $(this).dialog("destroy");
        }
        function createHandler() {
            setTimeout(centerOnScreen, 0), $(activeTextInstance).on(ActiveText.Events.RESIZE, centerOnScreen);
        }
        function closeDialog() {
            $(activeTextInstance).off(ActiveText.Events.RESIZE, centerOnScreen), $(newDialog).dialog("close"), 
            $("body").find(".button.exit").blur();
        }
        function closeBook() {
            $(newDialog).dialog("close"), closeFunction && "function" == typeof closeFunction && closeFunction();
        }
        function beforeCloseHandler() {
            $(activeTextInstance).tooltip("hide"), $(".tooltip[role=tooltip]").remove();
        }
        var characterIcon, factory = ActiveText.UI.BasicControls.SimpleButtonFactory, prefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance), pathPrefix = "", keepReadingSettings = {
            title: "Keep reading"
        }, closeBookSettings = {
            title: "Close book"
        }, dialogWidth = DIALOG_WIDTH, dialogHeight = DIALOG_HEIGHT;
        "ks1" === skinCode ? (pathPrefix = prefix + "img/bugclub/legacy/ks1/pupil/", characterIcon = "<img src='" + prefix + "img/bugclub/legacy/ks1/pupil/CloseBookDialog_image.png' width='106' height='118' />", 
        keepReadingSettings.style = {
            width: 260,
            height: 81
        }, keepReadingSettings.imageSrc = pathPrefix + "Button_keepReading_upSkin.png", 
        keepReadingSettings.hoverImageSrc = pathPrefix + "Button_keepReading_overSkin.png", 
        keepReadingSettings.downImageSrc = pathPrefix + "Button_keepReading_downSkin.png", 
        closeBookSettings.style = {
            width: 260,
            height: 82
        }, closeBookSettings.imageSrc = pathPrefix + "Button_closeBook_upSkin.png", closeBookSettings.hoverImageSrc = pathPrefix + "Button_closeBook_overSkin.png", 
        closeBookSettings.downImageSrc = pathPrefix + "Button_closeBook_downSkin.png") : (pathPrefix = prefix + "img/bugclub/legacy/ks2/", 
        characterIcon = "<img src='" + prefix + "img/bugclub/legacy/ks2/bee.png' width='133' height='175' />", 
        closeBookSettings.style = {
            width: 198,
            height: 49
        }, closeBookSettings.imageSrc = pathPrefix + "KS2_Close_book_3.png", closeBookSettings.hoverImageSrc = pathPrefix + "KS2_Close_book_1.png", 
        closeBookSettings.downImageSrc = pathPrefix + "KS2_Close_Book_2.png", keepReadingSettings.style = {
            width: 198,
            height: 49
        }, keepReadingSettings.imageSrc = pathPrefix + "KS2_Keep_Reading_3.png", keepReadingSettings.hoverImageSrc = pathPrefix + "KS2_Keep_Reading_1.png", 
        keepReadingSettings.downImageSrc = pathPrefix + "KS2_Keep_Reading_2.png");
        var keepReadingButton = factory.createSimpleButton(keepReadingSettings).click(closeDialog), closeBookButton = factory.createSimpleButton(closeBookSettings).click(closeBook), template = $("<div class='content'><div class='summary-icons'></div><div class='bug'>" + characterIcon + "</div><div class='buttons'></div></div>");
        template.find(".buttons").append(keepReadingButton, closeBookButton);
        var newDialog = template.dialog({
            width: dialogWidth,
            height: dialogHeight,
            modal: !0,
            appendTo: container,
            dialogClass: "summary-screen " + skinCode,
            resizable: !1,
            close: closeHandler,
            create: createHandler,
            beforeClose: beforeCloseHandler
        });
        return centerOnScreen(), newDialog;
    }
    /**
     * @const
     * @type {number}
     */
    var DIALOG_HEIGHT = 430, DIALOG_WIDTH = 730;
    return {
        createDialog: openSummary
    };
}(ActiveText), /* global ActiveText, BugClub */
ActiveText.namespace("BugClubAus.SummaryScreenIconFactory"), BugClubAus.SummaryScreenIconFactory = function(ActiveText) {
    "use strict";
    function preloadIconImages(activeTextInstance, skinCode) {
        function preload(images) {
            var i;
            for (i in images) $("<img/>")[0].src = images[i];
        }
        var pathPrefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance);
        preload("ks1" === skinCode ? [ pathPrefix + "img/bugclub/legacy/ks1/pupil/Canvas_bug.png", pathPrefix + "img/bugclub/legacy/ks1/pupil/Canvas_bugOverlay.png" ] : [ pathPrefix + "img/bugclub/legacy/ks2/KS2_ActivityToggle_Green_face_yellow_1.png", pathPrefix + "img/bugclub/legacy/ks2/KS2_ActivityToggle_yellow_2.png", pathPrefix + "img/bugclub/legacy/ks2/KS2_ActivityToggle_yellow_1.png" ]);
    }
    function getIconHTMLForStatus(activeTextInstance, status) {
        var rtn = "", pathPrefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance);
        return "completed" === status ? rtn = '<img class="icon" src="' + pathPrefix + 'img/bugclub/legacy/ks2/KS2_ActivityToggle_Green_face_yellow_1.png" width="35" height="36" />' : "progress" === status ? rtn = '<img class="icon" src="' + pathPrefix + 'img/bugclub/legacy/ks2/KS2_ActivityToggle_yellow_2.png" width="35" height="37" />' : "incomplete" === status && (rtn = '<img class="icon" src="' + pathPrefix + 'img/bugclub/legacy/ks2/KS2_ActivityToggle_yellow_1.png" width="35" height="37" />'), 
        rtn;
    }
    return {
        preloadIconImages: preloadIconImages,
        getIconHTMLForStatus: getIconHTMLForStatus
    };
}(ActiveText), /* global ActiveText, BugClubAus */
ActiveText.namespace("BugClubAus.DialogStyleText"), BugClubAus.DialogStyleText = function(ActiveText) {
    "use strict";
    function getStyle(activeTextInstance) {
        /**
         * @const
         * @type {string}
         */
        var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance);
        /**
         * @const
         * @type {string}
         */
        return '.ui-helper-hidden{display:none}.ui-helper-hidden-accessible{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.ui-helper-reset{margin:0;padding:0;border:0;outline:0;line-height:1.3;text-decoration:none;font-size:100%;list-style:none}.ui-helper-clearfix:before,.ui-helper-clearfix:after{content:"";display:table;border-collapse:collapse}.ui-helper-clearfix:after{clear:both}.ui-helper-clearfix{min-height:0}.ui-helper-zfix{width:100%;height:100%;top:0;left:0;position:absolute;opacity:0;filter:Alpha(Opacity=0)}.ui-front{z-index:1000}.ui-state-disabled{cursor:default!important}.ui-icon{display:block;text-indent:-99999px;overflow:hidden;background-repeat:no-repeat}.ui-widget-overlay{position:fixed;top:0;left:0;width:100%;height:100%}.ui-resizable{position:relative}.ui-resizable-handle{position:absolute;font-size:.1px;display:block}.ui-resizable-disabled .ui-resizable-handle,.ui-resizable-autohide .ui-resizable-handle{display:none}.ui-resizable-n{cursor:n-resize;height:7px;width:100%;top:-5px;left:0}.ui-resizable-s{cursor:s-resize;height:7px;width:100%;bottom:-5px;left:0}.ui-resizable-e{cursor:e-resize;width:7px;right:-5px;top:0;height:100%}.ui-resizable-w{cursor:w-resize;width:7px;left:-5px;top:0;height:100%}.ui-resizable-se{cursor:se-resize;width:12px;height:12px;right:1px;bottom:1px}.ui-resizable-sw{cursor:sw-resize;width:9px;height:9px;left:-5px;bottom:-5px}.ui-resizable-nw{cursor:nw-resize;width:9px;height:9px;left:-5px;top:-5px}.ui-resizable-ne{cursor:ne-resize;width:9px;height:9px;right:-5px;top:-5px}.ui-button{display:inline-block;position:relative;padding:0;line-height:normal;margin-right:.1em;cursor:pointer;vertical-align:initial;text-align:center;overflow:visible}.ui-button,.ui-button:link,.ui-button:visited,.ui-button:hover,.ui-button:active{text-decoration:none}.ui-button-icon-only{width:2.2em}button.ui-button-icon-only{width:2.4em}.ui-button-icons-only{width:3.4em}button.ui-button-icons-only{width:3.7em}.ui-button .ui-button-text{display:block;line-height:normal}.ui-button-text-only .ui-button-text{padding:.1em .2em}.ui-button-icon-only .ui-button-text,.ui-button-icons-only .ui-button-text{padding:.4em;text-indent:-9999999px}.ui-button-text-icon-primary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:.4em 1em .4em 2.1em}.ui-button-text-icon-secondary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:.4em 2.1em .4em 1em}.ui-button-text-icons .ui-button-text{padding-left:2.1em;padding-right:2.1em}input.ui-button{padding:.4em 1em}.ui-button-icon-only .ui-icon,.ui-button-text-icon-primary .ui-icon,.ui-button-text-icon-secondary .ui-icon,.ui-button-text-icons .ui-icon,.ui-button-icons-only .ui-icon{position:absolute;top:50%;margin-top:-8px}.ui-button-icon-only .ui-icon{left:50%;margin-left:-8px}.ui-button-text-icon-primary .ui-button-icon-primary,.ui-button-text-icons .ui-button-icon-primary,.ui-button-icons-only .ui-button-icon-primary{left:.5em}.ui-button-text-icon-secondary .ui-button-icon-secondary,.ui-button-text-icons .ui-button-icon-secondary,.ui-button-icons-only .ui-button-icon-secondary{right:.5em}.ui-buttonset{margin-right:7px}.ui-buttonset .ui-button{margin-left:0;margin-right:-.3em}input.ui-button::-moz-focus-inner,button.ui-button::-moz-focus-inner{border:0;padding:0}.ui-dialog{position:absolute;top:0;left:0;padding:0em;outline:0;-moz-box-shadow: 0 4px 8px rgba(0,0,0,0.5);-webkit-box-shadow: 0 4px 8px rgba(0,0,0,0.5);box-shadow: 0 4px 8px rgba(0,0,0,0.5);}img {vertical-align:initial;}.ui-dialog .ui-dialog-titlebar{padding:0 .2em;position:relative}.ui-dialog .ui-dialog-title{float:left;margin:.1em 0;white-space:nowrap;width:90%;overflow:hidden;text-overflow:ellipsis}.ui-dialog .ui-dialog-titlebar-close{position:absolute;right:.3em;top:50%;width:21px;margin:-10px 0 0 0;padding:1px;height:20px}.ui-dialog .ui-dialog-content{position:relative;border:0;padding:.5em;background:0;overflow:auto}.ui-dialog .ui-dialog-buttonpane{text-align:left;border-width:1px 0 0;background-image:none;margin-top:.5em;padding:.3em 1em .5em .4em}.ui-dialog .ui-dialog-buttonpane .ui-dialog-buttonset{float:right}.ui-dialog .ui-dialog-buttonpane button{margin:.5em .4em .5em 0;cursor:pointer}.ui-dialog .ui-resizable-se{width:12px;height:12px;right:-5px;bottom:-5px;background-position:16px 16px}.ui-draggable .ui-dialog-titlebar{cursor:move}.ui-widget .ui-widget{font-size:1em}.ui-widget input,.ui-widget select,.ui-widget textarea,.ui-widget button{font-family:Helvetica,Arial,sans-serif;font-size:1em}.ui-widget-content{border:1px solid #5693af;background:#649393;color:#222}.ui-widget-content .content{background:#fff;padding:.5em;}.ui-widget-content a{color:#222}.ui-widget-header{background:#649393 url(' + pathToResources + "img/bugclub/dialog/ui-bg_flat_0_649393_40x100.png) 50% 50% repeat-x;color:#fff;font-weight:bold}.ui-widget-header a{color:#fff}.ui-state-default,.ui-widget-content .ui-state-default,.ui-widget-header .ui-state-default{border:1px solid #5693af;background:#c8eafc url(" + pathToResources + "img/bugclub/dialog/ui-bg_glass_100_c8eafc_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#000}.ui-state-default a,.ui-state-default a:link,.ui-state-default a:visited{color:#000;text-decoration:none}.ui-state-hover,.ui-widget-content .ui-state-hover,.ui-widget-header .ui-state-hover,.ui-state-focus,.ui-widget-content .ui-state-focus,.ui-widget-header .ui-state-focus{border:1px solid #5693af;background:#a9e0fa url(" + pathToResources + "img/bugclub/dialog/ui-bg_glass_100_a9e0fa_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#000}.ui-state-hover a,.ui-state-hover a:hover,.ui-state-hover a:link,.ui-state-hover a:visited{color:#000;text-decoration:none}.ui-state-active,.ui-widget-content .ui-state-active,.ui-widget-header .ui-state-active{border:1px solid #5693af;background:#ffc70b url(" + pathToResources + "img/bugclub/dialog/ui-bg_glass_100_ffc70b_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#000}.ui-state-active a,.ui-state-active a:link,.ui-state-active a:visited{color:#000;text-decoration:none}.ui-state-highlight,.ui-widget-content .ui-state-highlight,.ui-widget-header .ui-state-highlight{border:1px solid #f47721;background:#ffc70b url(" + pathToResources + "img/bugclub/dialog/ui-bg_glass_100_ffc70b_1x400.png) 50% 50% repeat-x;color:#000}.ui-state-highlight a,.ui-widget-content .ui-state-highlight a,.ui-widget-header .ui-state-highlight a{color:#000}.ui-state-error,.ui-widget-content .ui-state-error,.ui-widget-header .ui-state-error{border:1px solid #cd0a0a;background:#fef1ec url(" + pathToResources + "img/bugclub/dialog/ui-bg_glass_95_fef1ec_1x400.png) 50% 50% repeat-x;color:#cd0a0a}.ui-state-error a,.ui-widget-content .ui-state-error a,.ui-widget-header .ui-state-error a{color:#cd0a0a}.ui-state-error-text,.ui-widget-content .ui-state-error-text,.ui-widget-header .ui-state-error-text{color:#cd0a0a}.ui-priority-primary,.ui-widget-content .ui-priority-primary,.ui-widget-header .ui-priority-primary{font-weight:bold}.ui-priority-secondary,.ui-widget-content .ui-priority-secondary,.ui-widget-header .ui-priority-secondary{opacity:.7;filter:Alpha(Opacity=70);font-weight:normal}.ui-state-disabled,.ui-widget-content .ui-state-disabled,.ui-widget-header .ui-state-disabled{opacity:.35;filter:Alpha(Opacity=35);background-image:none}.ui-state-disabled .ui-icon{filter:Alpha(Opacity=35)}.ui-icon{width:16px;height:16px}.ui-icon,.ui-widget-content .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_ffffff_256x240.png)}.ui-widget-header .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_91d0d0_256x240.png)}.ui-state-default .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_000000_256x240.png)}.ui-state-hover .ui-icon,.ui-state-focus .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_000000_256x240.png)}.ui-state-active .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_000000_256x240.png)}.ui-state-highlight .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_000000_256x240.png)}.ui-state-error .ui-icon,.ui-state-error-text .ui-icon{background-image:url(" + pathToResources + "img/bugclub/dialog/ui-icons_cd0a0a_256x240.png)}.ui-dialog .ui-dialog-titlebar-close {background:transparent !important;outline:none;width:26px;height:26px;margin-top:4px;margin-right:1px;top:0;}.ui-dialog .ui-dialog-titlebar-close.ui-button-icon-only .ui-icon {top:0;left:0;margin:0;padding:0;}.ui-icon-closethick,.ui-dialog .ui-dialog-titlebar-close{width:26px;height:26px;background-size:contain;background:transparent url(" + pathToResources + "img/bugclub/legacy/ks1/pupil/Button_smallteacherClose_upSkin.png) top left no-repeat !important;margin-top:2px;border:none;}.ui-icon-closethick:hover,.ui-icon-closethick.ui-state-hover,.ui-dialog .ui-dialog-titlebar-close.ui-state-hover{background:transparent url(" + pathToResources + "img/bugclub/legacy/ks1/pupil/Button_smallteacherClose_overSkin.png) top left no-repeat !important;border:none;}.ui-icon-grip-dotted-vertical{background-position:0 -224px}.ui-icon-grip-dotted-horizontal{background-position:-16px -224px}.ui-icon-grip-solid-vertical{background-position:-32px -224px}.ui-icon-grip-solid-horizontal{background-position:-48px -224px}.ui-icon-gripsmall-diagonal-se{background-position:-64px -224px}.ui-icon-grip-diagonal-se{background-position:-80px -224px}.ui-corner-all,.ui-corner-top,.ui-corner-left,.ui-corner-tl{border-top-left-radius:6px}.ui-corner-all,.ui-corner-top,.ui-corner-right,.ui-corner-tr{border-top-right-radius:6px}.ui-corner-all,.ui-corner-bottom,.ui-corner-left,.ui-corner-bl{border-bottom-left-radius:6px}.ui-corner-all,.ui-corner-bottom,.ui-corner-right,.ui-corner-br{border-bottom-right-radius:6px}.ui-widget-overlay{background:#000 url(" + pathToResources + "img/bugclub/dialog/ui-bg_flat_50_000000_40x100.png) 50% 50% repeat-x;opacity:.3;filter:Alpha(Opacity=30)}.ui-widget-shadow{margin:-8px 0 0 -8px;padding:8px;background:#000 url(" + pathToResources + "img/bugclub/dialog/ui-bg_flat_50_000000_40x100.png) 50% 50% repeat-x;opacity:.25;filter:Alpha(Opacity=25);border-radius:8px}.ui-widget-content.summary-screen{background:url(" + pathToResources + "img/bugclub/legacy/ks1/pupil/Canvas_closeBook_backgroundSkin.png) top left no-repeat;z-index:2010;border:none;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;}.ui-widget-content.summary-screen .ui-dialog-titlebar,.ui-widget-content.summary-screen .ui-dialog-buttonpane{background:transparent;}.ui-widget-content.summary-screen .ui-dialog-content{background:transparent;}.ui-widget-content.summary-screen .ui-dialog-titlebar-close{display:none;}.ui-widget-content.summary-screen .content .summary-icons{position:absolute;top:56px;left:50px;right:50px;height:64px;}.ui-widget-content.summary-screen.ks1 .content .bug{margin:220px 0 0 30px;}.ui-widget-content.summary-screen.ks2 .content .bug{margin:180px 0 0 50px;}.ui-widget-content.summary-screen .content .button-close{margin-left:1em;}.ui-widget-content.summary-screen .content .button-keep-reading{background:url(" + pathToResources + "img/bugclub/legacy/ks1/pupil/Button_keepReading_downSkin.png) top left no-repeat;width:260px;height:81px;}.ui-widget-content.summary-screen.ks1 .content .buttons{position:absolute;bottom:70px;right:30px;}.ui-widget-content.summary-screen.ks2 .content .buttons{position:absolute;bottom:90px;right:80px;}.ui-widget-content.summary-screen .content .buttons a{margin-left:1em;outline:0;border:none;}";
    }
    return {
        getStyle: getStyle
    };
}(ActiveText), /* global ActiveText, BugClubAus, Modernizr */
BugClubAus.SummaryScreen = BugClubAus.SummaryScreen || {}, BugClubAus.SummaryScreen.DialogStyleText = function(ActiveText) {
    "use strict";
    function getStyle(activeTextInstance) {
        /**
         * @const
         * @type {string}
         */
        var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance);
        /**
         * @const
         * @type {string}
         */
        return ".ui-widget-content.summary-screen{background:url(" + pathToResources + "img/bugclub/legacy/ks1/pupil/Canvas_closeBook_backgroundSkin.png) top left no-repeat;z-index:2010;border:none;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;}.ui-widget-content.summary-screen .ui-dialog-titlebar,.ui-widget-content.summary-screen .ui-dialog-buttonpane{background:transparent;}.ui-widget-content.summary-screen .ui-dialog-content{background:transparent;}.ui-widget-content.summary-screen .ui-dialog-titlebar-close{display:none;}.ui-widget-content.summary-screen .content .summary-icons{position:absolute;top:56px;left:50px;right:50px;height:64px;}.ui-widget-content.summary-screen.ks1 .content .bug{margin:220px 0 0 30px;}.ui-widget-content.summary-screen.ks2 .content .bug{margin:180px 0 0 50px;}.ui-widget-content.summary-screen .content .button-close{margin-left:1em;}.ui-widget-content.summary-screen .content .button-keep-reading{background:url(" + pathToResources + "img/bugclub/legacy/ks1/pupil/Button_keepReading_downSkin.png) top left no-repeat;width:260px;height:81px;}.ui-widget-content.summary-screen.ks1 .content .buttons{position:absolute;bottom:70px;right:30px;}.ui-widget-content.summary-screen.ks2 .content .buttons{position:absolute;bottom:90px;right:80px;}.ui-widget-content.summary-screen .content .buttons a{margin-left:1em;outline:0;border:none;}.ui-dialog,.ui-dialog *{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;}";
    }
    return {
        getStyle: getStyle
    };
}(ActiveText), /* global BugClub */
BugClubAus.StudentControlsKS1 = function(options) {
    "use strict";
    options || (options = {});
    var primary = options.rightButtons ? options.rightButtons : "previous,readtome,next", skinPathPrefix = "/ks1/pupil/";
    return options.primary = primary, options.skinName = "student-ks1", options.skinPathPrefix = skinPathPrefix, 
    new BugClubAus.Controls(options);
}, /* global BugClub */
BugClubAus.StudentControlsKS2 = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "zoom,viewtoggle", rightButtons = options.rightButtons ? options.rightButtons : "activitystructure,previous,quicknav,next,exit", skinPathPrefix = "/ks2/";
    return options.leftButtons = leftButtons, options.rightButtons = rightButtons, options.skinName = "student-ks2", 
    options.skinPathPrefix = skinPathPrefix, new BugClubAus.Controls(options);
}, /* global BugClubAus */
BugClubAus.TeacherControlsKS1 = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "readtome,drawing,zoom,bugclubhotspots", rightButtons = options.rightButtons ? options.rightButtons : "previous,quicknav,next,exit", skinPathPrefix = "/ks1/teacher/";
    /*
     if(activeTextInstance.options.allowReadToMe === false)
     {
     leftButtons = _.without(leftButtons.split(','), 'readtome', 'readtomeExtended').toString();
     rightButtons = _.without(rightButtons.split(','), 'readtome', 'readtomeExtended').toString();
     }
     */
    return options.leftButtons = leftButtons, options.rightButtons = rightButtons, options.skinName = "teacher-ks1", 
    options.skinPathPrefix = skinPathPrefix, new BugClubAus.Controls(options);
}, /* global BugClub */
BugClubAus.TeacherControlsKS2 = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "bugclubhotspots,zoom,viewtoggle,drawing", rightButtons = options.rightButtons ? options.rightButtons : "activitystructure,previous,quicknav,next,exit";
    return options.leftButtons = leftButtons, options.rightButtons = rightButtons, options.skinName = "teacher-ks2", 
    options.skinPathPrefix = "/ks2/", new BugClubAus.Controls(options);
}, /* global ActiveText, BugClubAus, Modernizr */
BugClubAus.Controls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        /**
         * @type {Function}
         */
        var closeFunction, summaryScreenExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "summaryscreen");
        summaryScreenExtension && (closeFunction = summaryScreenExtension.openSummary), 
        options || (options = {});
        //default student-ks1 layout - override for teacher layout in acticetext instance
        var leftButtons = options.leftButtons ? options.leftButtons : "zoom", primary = options.primary ? options.primary : null, rightButtons = options.rightButtons ? options.rightButtons : "exit";
        activeTextInstance.options.allowReadToMe === !1 && (leftButtons = _.without(leftButtons.split(","), "readtome", "readtomeExtended").toString(), 
        null !== primary && (options.primary = _.without(options.primary.split(","), "readtome", "readtomeExtended").toString()), 
        rightButtons = _.without(rightButtons.split(","), "readtome", "readtomeExtended").toString()), 
        options.leftButtons = leftButtons, null !== primary && (options.primary = primary), 
        options.rightButtons = rightButtons;
        /**
         * @type {String}
         */
        var controls, cssString, pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), pathPrefix = pathToResources + "img/bugclub/legacy/" + options.skinPathPrefix, skinName = options.skinName;
        "student-ks1" === skinName ? controls = new ActiveText.UI.BasicControls(activeTextInstance, {
            primary: primary,
            leftButtons: leftButtons,
            rightButtons: rightButtons,
            leftButtonOptions: {
                left: "10px",
                top: "0"
            },
            rightButtonOptions: {
                right: "10px"
            },
            openByDefault: !0,
            overlay: !1,
            barHeight: 102,
            barStyles: {
                backgroundColor: "#a3ca43",
                backgroundImage: "url(" + pathPrefix + "Canvas_backgroundSkin.png)",
                backgroundRepeat: "repeat-x",
                filter: "progid:DXImageTransform.Microsoft.AlphaImageLoader( src='" + pathPrefix + "Canvas_backgroundSkin.png', sizingMethod='scale')"
            },
            minWidth: 670,
            scaleMode: "scale",
            buttonStyles: {
                width: 94,
                height: 95,
                margin: "0",
                background: "transparent"
            },
            hoverStyles: {
                background: "transparent"
            },
            options: {
                readtome: {
                    style: {
                        width: 174,
                        height: 95
                    },
                    imageSrc: pathPrefix + "Button_readMe_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_readMe_overSkin.png",
                    downImageSrc: pathPrefix + "Button_readMe_downSkin.png",
                    toggleButtonImageSrc: pathPrefix + "Button_readMe_selectedSkin.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_readMe_selectedSkin.png"
                },
                zoom: {
                    imageSrc: pathPrefix + "Button_zoomOut_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_zoomOut_overSkin.png",
                    downImageSrc: pathPrefix + "Button_zoomOut_downSkin.png",
                    toggleButtonImageSrc: pathPrefix + "Button_zoomIn_upSkin.png",
                    toggleButtonDownImageSrc: pathPrefix + "Button_zoomIn_downSkin.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_zoomIn_overSkin.png"
                },
                previous: {
                    style: {
                        width: 120,
                        height: 92
                    },
                    imageSrc: pathPrefix + "Button_backArrow_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_backArrow_overSkin.png",
                    downImageSrc: pathPrefix + "Button_backArrow_downSkin.png",
                    enableBehaviour: "hide"
                },
                next: {
                    style: {
                        width: 120,
                        height: 92
                    },
                    imageSrc: pathPrefix + "Button_forArrow_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_forArrow_overSkin.png",
                    downImageSrc: pathPrefix + "Button_forArrow_downSkin.png",
                    enableBehaviour: "hide"
                },
                exit: {
                    style: {
                        width: 50,
                        height: 51
                    },
                    imageSrc: pathPrefix + "Button_Close_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_Close_overSkin.png",
                    downImageSrc: pathPrefix + "Button_Close_downSkin.png",
                    closeFunction: closeFunction
                }
            }
        }) : "student-ks2" === skinName ? (cssString = ".quicknav{background:transparent url(" + pathPrefix + "text-input-background.png) center center no-repeat;width:128px;}.quicknav input{background:transparent;}", 
        ActiveText.CSSUtils.embedCSS(cssString, "bugclub-skin-styles"), controls = new ActiveText.UI.BasicControls(activeTextInstance, {
            leftButtons: leftButtons,
            rightButtons: rightButtons,
            leftButtonOptions: {
                left: "10px",
                top: "0"
            },
            rightButtonOptions: {
                right: "10px"
            },
            openByDefault: !0,
            overlay: !1,
            barHeight: 51,
            barStyles: {
                backgroundColor: "#92c7c6",
                backgroundImage: "url(" + pathPrefix + "bar.png)",
                backgroundRepeat: "repeat-x",
                lineHeight: "46px"
            },
            minWidth: 545,
            scaleMode: "scale",
            buttonStyles: {
                width: 41,
                height: 41,
                background: "transparent",
                margin: "0"
            },
            options: {
                readtome: {
                    imageSrc: pathPrefix + "button-volume-on-up.png",
                    hoverImageSrc: pathPrefix + "button-volume-on-hover.png",
                    downImageSrc: pathPrefix + "button-volume-on-down.png",
                    toggleButtonImageSrc: pathPrefix + "button-volume-on-up-toggle.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-volume-on-hover-toggle.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-volume-on-down-toggle.png"
                },
                edittext: {
                    imageSrc: pathPrefix + "button-edittext-up.png",
                    hoverImageSrc: pathPrefix + "button-edittext-hover.png",
                    toggleButtonImageSrc: pathPrefix + "button-edittext-up-toggle.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-edittext-hover-toggle.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-edittext-down-toggle.png"
                },
                drawing: {
                    imageSrc: pathPrefix + "button-drawing-up.png",
                    hoverImageSrc: pathPrefix + "button-drawing-hover.png",
                    downImageSrc: pathPrefix + "button-drawing-down.png",
                    toggleButtonImageSrc: pathPrefix + "button-drawing-up-toggle.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-drawing-hover-toggle.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-drawing-down-toggle.png"
                },
                zoom: {
                    imageSrc: pathPrefix + "button-zoom-out-up-toggle.png",
                    hoverImageSrc: pathPrefix + "button-zoom-out-hover-toggle.png",
                    downImageSrc: pathPrefix + "button-zoom-out-down-toggle.png",
                    toggleButtonImageSrc: pathPrefix + "button-zoom-in-up.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-zoom-in-hover.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-zoom-in-down.png"
                },
                viewtoggle: {
                    imageSrc: pathPrefix + "button-dps-view-up.png",
                    hoverImageSrc: pathPrefix + "button-dps-view-hover.png",
                    downImageSrc: pathPrefix + "button-dps-view-down.png",
                    toggleButtonImageSrc: pathPrefix + "button-sps-view-up.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-sps-view-hover.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-sps-view-down.png"
                },
                previous: {
                    style: {
                        width: 49,
                        height: 43
                    },
                    imageSrc: pathPrefix + "button-left-up.png",
                    hoverImageSrc: pathPrefix + "button-left-hover.png",
                    enableBehaviour: "hide"
                },
                next: {
                    style: {
                        width: 49,
                        height: 43
                    },
                    imageSrc: pathPrefix + "button-right-up.png",
                    hoverImageSrc: pathPrefix + "button-right-hover.png",
                    enableBehaviour: "hide"
                },
                quicknav: {
                    style: {
                        border: "none",
                        width: 152,
                        padding: "12px 12px 14px 12px"
                    },
                    popupnavwidth: 293,
                    textFormatSinglePage: "%%1 of %%2",
                    textFormatMultiPage: "%%1/%%2 of %%3"
                },
                activitystructure: {
                    style: {
                        width: 102,
                        height: 41
                    },
                    imageSrc: pathPrefix + "button-contents-up.png",
                    hoverImageSrc: pathPrefix + "button-contents-hover.png",
                    downImageSrc: pathPrefix + "button-contents-down.png",
                    toggleButtonImageSrc: pathPrefix + "button-contents-up.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-contents-hover.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-contents-down.png"
                },
                exit: {
                    style: {
                        width: 36,
                        height: 36
                    },
                    imageSrc: pathPrefix + "button-exit-up.png",
                    hoverImageSrc: pathPrefix + "button-exit-hover.png",
                    downImageSrc: pathPrefix + "button-exit-down.png",
                    closeFunction: closeFunction
                }
            }
        })) : "teacher-ks1" === skinName ? (cssString = ".quicknav{background:transparent url(" + pathPrefix + "Canvas_teacherButtonBar_TextInput.png) center center no-repeat;}.quicknav input{background:transparent;}", 
        ActiveText.CSSUtils.embedCSS(cssString, "bugclub-skin-styles"), controls = new ActiveText.UI.BasicControls(activeTextInstance, {
            leftButtons: leftButtons,
            rightButtons: rightButtons,
            leftButtonOptions: {
                left: "10px",
                top: "0"
            },
            rightButtonOptions: {
                right: "10px"
            },
            openByDefault: !0,
            overlay: !1,
            barHeight: 101,
            barStyles: {
                backgroundColor: "#456b68",
                backgroundImage: "url(" + pathPrefix + "Element_Background2.png)",
                backgroundRepeat: "repeat-x"
            },
            minWidth: 670,
            scaleMode: "scale",
            buttonStyles: {
                width: 64,
                height: 64,
                margin: "0",
                background: "transparent"
            },
            hoverStyles: {
                background: "transparent"
            },
            options: {
                readtome: {
                    imageSrc: pathPrefix + "Button_readMe_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_readMe_overSkin.png",
                    downImageSrc: pathPrefix + "Button_readMe_downSkin.png",
                    toggleButtonImageSrc: pathPrefix + "Button_readMe_selectedSkin.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_readMe_selectedSkin.png"
                },
                drawing: {
                    imageSrc: pathPrefix + "Button_userTools_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_userTools_overSkin.png",
                    downImageSrc: pathPrefix + "Button_userTools_downSkin.png",
                    toggleButtonImageSrc: pathPrefix + "Button_userTools_selectedSkin.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_userTools_selectedSkin.png"
                },
                zoom: {
                    imageSrc: pathPrefix + "Button_zoomOut_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_zoomOut_overSkin.png",
                    downImageSrc: pathPrefix + "Button_zoomOut_downSkin.png",
                    toggleButtonImageSrc: pathPrefix + "Button_zoomIn_upSkin.png",
                    toggleButtonDownImageSrc: pathPrefix + "Button_zoomIn_downSkin.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_zoomIn_overSkin.png"
                },
                bugclubhotspots: {
                    imageSrc: pathPrefix + "Button_activityToggle_disabledSkin.png",
                    hoverImageSrc: pathPrefix + "Button_activityToggle_disabledSkin.png",
                    downImageSrc: pathPrefix + "Button_activityToggle_downButton.png",
                    toggleButtonImageSrc: pathPrefix + "Button_activityToggle_upSkin.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_activityToggle_overSkin.png",
                    enableBehaviour: "show"
                },
                previous: {
                    style: {
                        width: 80,
                        height: 60
                    },
                    imageSrc: pathPrefix + "Button_backArrow_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_backArrow_overSkin.png",
                    downImageSrc: pathPrefix + "Button_backArrow_downSkin.png",
                    enableBehaviour: "hide"
                },
                next: {
                    style: {
                        width: 80,
                        height: 60
                    },
                    imageSrc: pathPrefix + "Button_forArrow_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_forArrow_overSkin.png",
                    downImageSrc: pathPrefix + "Button_forArrow_downSkin.png",
                    enableBehaviour: "hide"
                },
                quicknav: {
                    style: {
                        border: "none",
                        width: 120,
                        padding: "18px 12px"
                    },
                    popupnavwidth: 293,
                    textFormatSinglePage: "%%1 of %%2",
                    textFormatMultiPage: "%%1/%%2 of %%3"
                },
                exit: {
                    style: {
                        width: 53,
                        height: 53,
                        margin: "0"
                    },
                    imageSrc: pathPrefix + "Button_teacherClose_upSkin.png",
                    hoverImageSrc: pathPrefix + "Button_teacherClose_overSkin.png",
                    downImageSrc: pathPrefix + "Button_teacherClose_downSkin.png",
                    closeFunction: closeFunction
                }
            }
        })) : "teacher-ks2" === skinName && (cssString = ".quicknav{background:transparent url(" + pathPrefix + "text-input-background.png) center center no-repeat;width:128px;}.quicknav input{background:transparent;}", 
        ActiveText.CSSUtils.embedCSS(cssString, "bugclub-skin-styles"), controls = new ActiveText.UI.BasicControls(activeTextInstance, {
            leftButtons: leftButtons,
            rightButtons: rightButtons,
            leftButtonOptions: {
                left: "10px",
                top: "0"
            },
            rightButtonOptions: {
                right: "10px"
            },
            openByDefault: !0,
            overlay: !1,
            barHeight: 51,
            barStyles: {
                backgroundColor: "#92c7c6",
                backgroundImage: "url(" + pathPrefix + "bar.png)",
                backgroundRepeat: "repeat-x",
                lineHeight: "46px"
            },
            minWidth: 645,
            scaleMode: "scale",
            buttonStyles: {
                width: 41,
                height: 41,
                background: "transparent"
            },
            hoverStyles: {
                background: "transparent"
            },
            options: {
                readtome: {
                    imageSrc: pathPrefix + "button-volume-on-up.png",
                    hoverImageSrc: pathPrefix + "button-volume-on-hover.png",
                    downImageSrc: pathPrefix + "button-volume-on-down.png",
                    toggleButtonImageSrc: pathPrefix + "button-volume-on-up-toggle.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-volume-on-hover-toggle.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-volume-on-down-toggle.png"
                },
                edittext: {
                    imageSrc: pathPrefix + "button-edittext-up.png",
                    hoverImageSrc: pathPrefix + "button-edittext-hover.png",
                    toggleButtonImageSrc: pathPrefix + "button-edittext-up-toggle.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-edittext-hover-toggle.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-edittext-down-toggle.png"
                },
                drawing: {
                    imageSrc: pathPrefix + "button-drawing-up.png",
                    hoverImageSrc: pathPrefix + "button-drawing-hover.png",
                    downImageSrc: pathPrefix + "button-drawing-down.png",
                    toggleButtonImageSrc: pathPrefix + "button-drawing-up-toggle.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-drawing-hover-toggle.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-drawing-down-toggle.png"
                },
                zoom: {
                    imageSrc: pathPrefix + "button-zoom-out-up-toggle.png",
                    hoverImageSrc: pathPrefix + "button-zoom-out-hover-toggle.png",
                    downImageSrc: pathPrefix + "button-zoom-out-down-toggle.png",
                    toggleButtonImageSrc: pathPrefix + "button-zoom-in-up.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-zoom-in-hover.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-zoom-in-down.png"
                },
                bugclubhotspots: {
                    imageSrc: pathPrefix + "button-hotspots-up-disabled.png",
                    hoverImageSrc: pathPrefix + "button-hotspots-hover-disabled.png",
                    downImageSrc: pathPrefix + "button-hotspots-down-disabled.png",
                    toggleButtonImageSrc: pathPrefix + "button-hotspots-up.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-hotspots-hover.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-hotspots-down.png",
                    enableBehaviour: "show"
                },
                viewtoggle: {
                    imageSrc: pathPrefix + "button-dps-view-up.png",
                    hoverImageSrc: pathPrefix + "button-dps-view-hover.png",
                    downImageSrc: pathPrefix + "button-dps-view-down.png",
                    toggleButtonImageSrc: pathPrefix + "button-sps-view-up.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-sps-view-hover.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-sps-view-down.png"
                },
                previous: {
                    style: {
                        width: 49,
                        height: 43
                    },
                    imageSrc: pathPrefix + "button-left-up.png",
                    hoverImageSrc: pathPrefix + "button-left-hover.png",
                    enableBehaviour: "hide"
                },
                next: {
                    style: {
                        width: 49,
                        height: 43
                    },
                    imageSrc: pathPrefix + "button-right-up.png",
                    hoverImageSrc: pathPrefix + "button-right-hover.png",
                    enableBehaviour: "hide"
                },
                quicknav: {
                    style: {
                        border: "none",
                        width: 152,
                        padding: "12px 12px 14px 12px"
                    },
                    popupnavwidth: 293,
                    textFormatSinglePage: "%%1 of %%2",
                    textFormatMultiPage: "%%1/%%2 of %%3"
                },
                activitystructure: {
                    style: {
                        width: 102,
                        height: 41
                    },
                    imageSrc: pathPrefix + "button-contents-up.png",
                    hoverImageSrc: pathPrefix + "button-contents-hover.png",
                    downImageSrc: pathPrefix + "button-contents-down.png",
                    toggleButtonImageSrc: pathPrefix + "button-contents-up.png",
                    toggleButtonHoverImageSrc: pathPrefix + "button-contents-hover.png",
                    toggleButtonDownImageSrc: pathPrefix + "button-contents-down.png"
                },
                exit: {
                    style: {
                        width: 36,
                        height: 36
                    },
                    imageSrc: pathPrefix + "button-exit-up.png",
                    hoverImageSrc: pathPrefix + "button-exit-hover.png",
                    downImageSrc: pathPrefix + "button-exit-down.png",
                    closeFunction: closeFunction
                }
            }
        })), activeTextInstance.extensions.push(controls);
    }
    return {
        init: init
    };
};

/* global ActiveText, BugClub, ActiveText, Modernizr */
var JDPlays = JDPlays || {};

/**
 * @class Player
 * @memberOf JDPlays
 * @param {string} skinCode
 * @returns {{init: init, isInPerformanceMode: isInPerformanceMode, key: string}}
 * @constructor
 */
JDPlays.Player = function(skinCode) {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param dependencyKey {String}
     * @param skinCode {String}
     */
    function checkDependency(activeTextInstance, dependencyKey, skinCode) {
        function audioPlaybackController(value, eventType) {
            if (void 0 === value) {
                if (isInPerformanceMode(activeTextInstance)) {
                    var extension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "readtome"), currentCharacter = ActiveText.CharacterSelection.getCharacter(), activeCharacter = extension.getState().getActiveCharacter();
                    return !(currentCharacter === activeCharacter);
                }
                return eventType === ActiveText.Commands.GO_TO_PAGE ? !1 : !0;
            }
        }
        activeTextInstance.options.audioPlaybackController = audioPlaybackController;
        var newClass, hasExtensionForDependency = Boolean(ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, dependencyKey));
        if (!hasExtensionForDependency) switch (dependencyKey) {
          case "overlaydataloader":
            newClass = new ActiveText.OverlayData(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubhotspots":
            newClass = new BugClub.Hotspots(skinCode), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "smildatamodel":
            newClass = new ActiveText.SMILDataModel(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "smildataloader":
            newClass = new ActiveText.SMILDataLoader(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "texthighlightaudiosync":
            activeTextInstance.options.allowReadToMe !== !1 && (newClass = new ActiveText.TextHighlightAudioSync(), 
            newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass));
            break;

          case "summaryscreen":
            newClass = new BugClub.SummaryScreen(skinCode), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "soundeffects":
            newClass = new ActiveText.SoundEffects(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "keyboardintegration":
            newClass = new ActiveText.KeyboardIntegration(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "drawingtools":
            newClass = new ActiveText.DrawingTools(), newClass.supported() && (newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass));
            break;

          case "clicktoprompt":
            newClass = new ActiveText.ClickToPrompt(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "readingcomplete":
            newClass = new ActiveText.ReadingComplete(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubactivitysummary":
            newClass = new BugClub.ActivitySummaryCollective(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubscorm":
            newClass = new BugClub.SCORM.ActivityData(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
        }
    }
    function setDefaultPropertiesFor(activeTextInstance) {
        function hotspotClickHandler(e) {
            /* jshint validthis:true */
            var activityIsComplete = $(e.currentTarget).hasClass("complete");
            if (activityIsComplete) debug.log("Not launching activity because activity is completed."); else {
                var data = $(e.currentTarget).data(), scormIntegrationExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "pipwerks");
                scormIntegrationExtension ? (debug.log("scormIntegrationExtension.launchActivity();", data), 
                scormIntegrationExtension.launchActivity(data.data.uri)) : (debug.log("Launching Hotspot Activity : " + data.data.uri), 
                alert("Launching Hotspot Activity : " + data.data.uri));
            }
        }
        var pathToAssets = ActiveText.SkinUtils.getPathToResources(activeTextInstance);
        activeTextInstance.options.containerElement.css(/**
         * Browser detection is bad, but IE is worse.
         *
         * Some versions of IE support SVG, and they support it for background images, but they don't scale it correctly
         * because they're dumb. So we're forced to do shit like this - using non SVG versions of images for the background.
         */
        !Modernizr.svg || navigator.userAgent.match(/(msie|trident)\/?\s*(\.?\d+(\.\d+)*)/i) ? {
            background: "url(" + pathToAssets + "img/bugclub/backdrop.png) no-repeat center center",
            filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src="' + pathToAssets + 'img/bugclub/backdrop.png", sizingMethod="scale")',
            MsFilter: "'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\"" + pathToAssets + 'img/bugclub/backdrop.png", sizingMethod="scale")\'',
            backgroundSize: "cover"
        } : {
            background: "url(" + pathToAssets + "img/bugclub/background.svg) no-repeat center center",
            backgroundSize: "cover"
        }), void 0 === activeTextInstance.options.allowOverlap && (activeTextInstance.options.allowOverlap = !1), 
        void 0 === activeTextInstance.options.hotspotClickFunction && (activeTextInstance.options.hotspotClickFunction = hotspotClickHandler), 
        ActiveText.BrowserUtils.isMobileDevice && (activeTextInstance.options.allowAnimation = !1), 
        void 0 === activeTextInstance.options.autoPop && (activeTextInstance.options.autoPop = function() {
            var autoPopData = {
                index: 2,
                data: [ {
                    type: "target-area",
                    data: {
                        id: "ATX-autoPop",
                        shape: "rectangle",
                        uri: pathToAssets + "wdgt/JDPlays.wdgt/index.html?transparent=true",
                        x: -1,
                        y: -1,
                        width: 1,
                        height: 1
                    }
                } ]
            };
            return autoPopData;
        });
    }
    /**
     * @param activeTextInstance {ActiveText}
     * @returns {boolean}
     */
    function isInPerformanceMode(activeTextInstance) {
        var currentCharacter = ActiveText.CharacterSelection.getCharacter();
        return "" !== currentCharacter ? activeTextInstance.model.getCurrentPageNumber() >= 4 : !1;
    }
    /**
     * @param activeTextInstance {ActiveText}
     */
    function init(activeTextInstance) {
        setDefaultPropertiesFor(activeTextInstance);
        for (var dependencyKey, dependencies = [ "overlaydataloader", "bugclubactivitysummary", "bugclubscorm", "bugclubhotspots", "smildatamodel", "smildataloader", "texthighlightaudiosync", "summaryscreen", "soundeffects", "keyboardintegration", "drawingtools", "clicktoprompt", "readingcomplete" ], i = 0, l = dependencies.length; l > i; i++) dependencyKey = dependencies[i], 
        checkDependency(activeTextInstance, dependencyKey, skinCode);
        $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, function() {
            if (activeTextInstance.utils.isFullWindowScalingMode()) {
                var rotationControl = new ActiveText.ViewOrientationDetection();
                rotationControl.init(activeTextInstance), activeTextInstance.extensions.push(rotationControl);
            }
        });
    }
    return {
        init: init,
        isInPerformanceMode: isInPerformanceMode,
        key: "jdplays"
    };
};

/* global BugClub */
var JDPlays = JDPlays || {};

JDPlays.StudentControls = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "zoom", primary = options.primary ? options.primary : "previous,readtomeExtended,next", rightButtons = options.rightButtons ? options.rightButtons : "exit";
    return options.leftButtons = leftButtons, options.primary = primary, options.rightButtons = rightButtons, 
    new BugClub.Controls(options);
};

/* global BugClub */
var JDPlays = JDPlays || {};

JDPlays.TeacherControls = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "zoom,drawing,bugclubhotspots", primaryButtons = options.primaryButtons ? options.primaryButtons : "previous,readtomeExtended,next", rightButtons = options.rightButtons ? options.rightButtons : "quicknav,exit";
    return options.leftButtons = leftButtons, options.primary = primaryButtons, options.rightButtons = rightButtons, 
    new BugClub.Controls(options);
};

/* global ActiveText, ActiveText, Modernizr */
var Rapid = Rapid || {};

Rapid.Player = function() {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param dependencyKey {String}
     * @param skinCode {String}
     */
    function checkDependency(activeTextInstance, dependencyKey, skinCode) {
        var newClass, hasExtensionForDependency = Boolean(ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, dependencyKey));
        if (!hasExtensionForDependency) switch (dependencyKey) {
          case "overlaydataloader":
            newClass = new ActiveText.OverlayData(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubhotspots":
            newClass = new BugClub.Hotspots(skinCode), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "smildatamodel":
            newClass = new ActiveText.SMILDataModel(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "smildataloader":
            newClass = new ActiveText.SMILDataLoader(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "recordandplay":
            newClass = new ActiveText.RecordAndPlay(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "texthighlightaudiosync":
            activeTextInstance.options.allowReadToMe !== !1 && (newClass = new ActiveText.TextHighlightAudioSync({
                selectionModeHighlightByDefault: !0
            }), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass));
            break;

          case "summaryscreen":
            newClass = new BugClub.SummaryScreen(skinCode), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "closebook":
            newClass = new Rapid.CloseBook(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "soundeffects":
            newClass = new ActiveText.SoundEffects(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "keyboardintegration":
            newClass = new ActiveText.KeyboardIntegration(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "drawingtools":
            newClass = new ActiveText.DrawingTools(), newClass.supported() && (newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass));
            break;

          case "clicktoprompt":
            newClass = new ActiveText.ClickToPrompt(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "readingcomplete":
            newClass = new ActiveText.ReadingComplete(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubactivitysummary":
            newClass = new BugClub.ActivitySummaryCollective(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "bugclubscorm":
            newClass = new BugClub.SCORM.ActivityData(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
        }
    }
    function audioPlaybackController(value, eventType) {
        return void 0 === value ? eventType === ActiveText.Commands.GO_TO_PAGE ? !1 : !0 : void 0;
    }
    function setDefaultPropertiesFor(activeTextInstance) {
        function hotspotClickHandler(e) {
            /* jshint validthis:true */
            var activityIsComplete = $(e.currentTarget).hasClass("complete");
            if (activityIsComplete) debug.log("Not launching activity because activity is completed."); else {
                var data = $(e.currentTarget).data(), hotspotUri = data.data.uri, scormIntegrationExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "pipwerks");
                scormIntegrationExtension ? (debug.log("scormIntegrationExtension.launchActivity();", data), 
                scormIntegrationExtension.launchActivity(hotspotUri)) : (debug.log("Launching Hotspot Activity : " + hotspotUri), 
                setTimeout(function() {
                    alert("Launching Hotspot Activity : " + hotspotUri);
                }, 0));
            }
        }
        void 0 === activeTextInstance.options.audioPlaybackController && (activeTextInstance.options.audioPlaybackController = audioPlaybackController), 
        void 0 === activeTextInstance.options.hotspotClickFunction && (activeTextInstance.options.hotspotClickFunction = hotspotClickHandler), 
        void 0 === activeTextInstance.options.allowOverlap && (activeTextInstance.options.allowOverlap = !1), 
        void 0 === activeTextInstance.options.allowAnimation && (activeTextInstance.options.allowAnimation = !1);
    }
    /**
     * @param activeTextInstance {ActiveText}
     * @returns {boolean}
     */
    function isInPerformanceMode(activeTextInstance) {
        var currentCharacter = ActiveText.CharacterSelection.getCharacter();
        return "" !== currentCharacter ? activeTextInstance.model.getCurrentPageNumber() >= 4 : !1;
    }
    function setRandomBackground(activeTextInstance) {
        var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), bg = [ "green", "orange", "purple", "blue" ][Math.floor(4 * Math.random())];
        activeTextInstance.options.containerElement.css(/**
         * Browser detection is bad, but IE is worse.
         *
         * Some versions of IE support SVG, and they support it for background images, but they don't scale it correctly
         * because they're dumb. So we're forced to do shit like this - using non SVG versions of images for the background.
         */
        !Modernizr.svg || navigator.userAgent.match(/(msie|trident)\/?\s*(\.?\d+(\.\d+)*)/i) ? {
            background: "url(" + pathToResources + "/img/rapid/background-" + bg + ".png) no-repeat center center",
            filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src="' + pathToResources + "/img/rapid/background-" + bg + '.png", sizingMethod="scale")',
            MsFilter: "'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\"" + pathToResources + "/img/rapid/background-" + bg + '.png", sizingMethod="scale")\'',
            backgroundSize: "cover"
        } : {
            background: "url(" + pathToResources + "img/rapid/background-" + bg + ".svg) no-repeat center center",
            backgroundSize: "cover"
        });
    }
    /** @constructor */
    return function() {
        /**
         * @param activeTextInstance {ActiveText}
         */
        function init(activeTextInstance) {
            setRandomBackground(activeTextInstance), setDefaultPropertiesFor(activeTextInstance);
            for (var dependencyKey, dependencies = [ "overlaydataloader", "bugclubactivitysummary", "bugclubscorm", "bugclubhotspots", "smildatamodel", "smildataloader", "texthighlightaudiosync", "closebook", "soundeffects", "keyboardintegration", "drawingtools", "clicktoprompt", "recordandplay", "readingcomplete" ], i = 0, l = dependencies.length; l > i; i++) dependencyKey = dependencies[i], 
            checkDependency(activeTextInstance, dependencyKey);
            $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, function() {
                if (activeTextInstance.utils.isFullWindowScalingMode()) {
                    var rotationControl = new ActiveText.ViewOrientationDetection();
                    rotationControl.init(activeTextInstance), activeTextInstance.extensions.push(rotationControl);
                }
            });
        }
        return {
            init: init,
            isInPerformanceMode: isInPerformanceMode,
            key: "rapid"
        };
    };
}();

/* global ActiveText, Modernizr */
var Rapid = Rapid || {};

Rapid.Controls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        var closeFunction, closeBookExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "closebook");
        closeBookExtension && (closeFunction = closeBookExtension.open), options || (options = {});
        var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), pathPrefix = pathToResources + "img/rapid/", extension = ".png";
        Modernizr.svg && (extension = ".svg");
        var controls = new ActiveText.UI.BasicControls(activeTextInstance, {
            primary: options.primary,
            leftButtons: options.leftButtons,
            rightButtons: options.rightButtons,
            leftButtonOptions: {
                left: "10px"
            },
            rightButtonOptions: {
                right: "10px"
            },
            openByDefault: !0,
            overlay: !1,
            barHeight: 50,
            barStyles: {
                backgroundColor: "#000000"
            },
            minWidth: 670,
            scaleMode: "scale",
            buttonStyles: {
                width: 41,
                height: 41,
                tooltips: !1,
                background: "transparent",
                display: "inline-block",
                "vertical-align": "top"
            },
            hoverStyles: {
                background: "transparent"
            },
            options: {
                readtome: {
                    style: {
                        width: 157,
                        height: 41
                    },
                    imageSrc: pathPrefix + "ReadToMeUp" + extension,
                    hoverImageSrc: pathPrefix + "ReadToMeOver" + extension,
                    downImageSrc: pathPrefix + "ReadToMeDown" + extension,
                    toggleButtonImageSrc: pathPrefix + "ReadToMeActive" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "ReadToMeActiveDown" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "ReadToMeActiveOver" + extension
                },
                zoom: {
                    imageSrc: pathPrefix + "ZoomActive" + extension,
                    hoverImageSrc: pathPrefix + "ZoomActiveOver" + extension,
                    downImageSrc: pathPrefix + "ZoomActiveDown" + extension,
                    toggleButtonImageSrc: pathPrefix + "ZoomUp" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "ZoomDown" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "ZoomOver" + extension
                },
                bugclubhotspots: {
                    imageSrc: pathPrefix + "HeadActive" + extension,
                    hoverImageSrc: pathPrefix + "HeadActiveOver" + extension,
                    downImageSrc: pathPrefix + "HeadActiveDown" + extension,
                    toggleButtonImageSrc: pathPrefix + "HeadUp" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "HeadOver" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "HeadDown" + extension
                },
                previous: {
                    style: {
                        width: 69,
                        height: 45
                    },
                    imageSrc: pathPrefix + "LeftArrowUp" + extension,
                    hoverImageSrc: pathPrefix + "LeftArrowOver" + extension,
                    enableBehaviour: "hide"
                },
                next: {
                    style: {
                        width: 69,
                        height: 45
                    },
                    imageSrc: pathPrefix + "RightArrowUp" + extension,
                    hoverImageSrc: pathPrefix + "RightArrowOver" + extension,
                    downImageSrc: pathPrefix + "RightArrowDown" + extension,
                    enableBehaviour: "hide"
                },
                record: {
                    imageSrc: pathPrefix + "RecordUp" + extension,
                    hoverImageSrc: pathPrefix + "RecordOver" + extension,
                    downImageSrc: pathPrefix + "RecordDown" + extension,
                    toggleButtonImageSrc: pathPrefix + "StopUp" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "StopOver" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "StopDown" + extension
                },
                play: {
                    imageSrc: pathPrefix + "PlayUp" + extension,
                    hoverImageSrc: pathPrefix + "PlayOver" + extension,
                    downImageSrc: pathPrefix + "PlayDown" + extension,
                    disabledImageSrc: pathPrefix + "PlayDisabled" + extension,
                    toggleButtonImageSrc: pathPrefix + "PauseUp" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "PauseOver" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "PauseDown" + extension
                },
                exit: {
                    imageSrc: pathPrefix + "CloseUp" + extension,
                    hoverImageSrc: pathPrefix + "CloseOver" + extension,
                    downImageSrc: pathPrefix + "CloseDown" + extension,
                    closeFunction: closeFunction
                }
            }
        });
        activeTextInstance.extensions.push(controls);
    }
    return {
        init: init
    };
};

/* global ActiveText */
var Rapid = Rapid || {};

Rapid.StudentControls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        options || (options = {});
        var primary = options.primary ? options.primary : "previous,readtome,next", leftButtons = options.leftButtons ? options.leftButtons : "zoom", rightButtons = options.rightButtons ? options.rightButtons : "record,play,exit";
        activeTextInstance.options.allowReadToMe === !1 && (primary = _.without(primary.split(","), "readtome", "readtomeExtended").toString()), 
        options.primary = primary, options.leftButtons = leftButtons, options.rightButtons = rightButtons;
        var controls = new Rapid.Controls(options);
        controls.init(activeTextInstance), activeTextInstance.extensions.push(controls);
    }
    return {
        init: init
    };
};

/* global ActiveText */
var Rapid = Rapid || {};

Rapid.TeacherControls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        options || (options = {});
        var primary = options.primary ? options.primary : "previous,readtome,next", leftButtons = options.leftButtons ? options.leftButtons : "bugclubhotspots,zoom", rightButtons = options.rightButtons ? options.rightButtons : "record,play,exit";
        activeTextInstance.options.allowReadToMe === !1 && (primary = _.without(primary.split(","), "readtome", "readtomeExtended").toString()), 
        options.primary = primary, options.leftButtons = leftButtons, options.rightButtons = rightButtons;
        var controls = new Rapid.Controls(options);
        controls.init(activeTextInstance), activeTextInstance.extensions.push(controls);
    }
    return {
        init: init
    };
};

/* global ActiveText, Modernizr */
var Rapid = Rapid || {};

Rapid.CloseBook = function() {
    "use strict";
    function createDialog() {
        function closeHandler() {
            /* jshint validthis:true */
            $(this).dialog("destroy"), newDialog = null;
        }
        function createHandler() {
            setTimeout(centerOnScreen, 0), $(newDialog).focus(), $(activeTextInstance).on(ActiveText.Events.RESIZE, centerOnScreen);
        }
        var extension = "png";
        Modernizr.svg && (extension = "svg");
        var keepReadingSettings = {
            title: "Keep reading",
            className: "button-keep-reading",
            tooltips: !1,
            style: {
                width: 198,
                height: 42
            },
            width: 198,
            height: 42,
            imageSrc: pathPrefix + "keepReadingUp." + extension,
            hoverImageSrc: pathPrefix + "keepReadingOver." + extension,
            downImageSrc: pathPrefix + "keepReadingUp." + extension
        }, closeBookSettings = {
            title: "Close book",
            className: "button-close",
            tooltips: !1,
            style: {
                width: 198,
                height: 42
            },
            width: 198,
            height: 42,
            imageSrc: pathPrefix + "closeBookUp." + extension,
            hoverImageSrc: pathPrefix + "closeBookOver." + extension,
            downImageSrc: pathPrefix + "closeBookUp." + extension
        }, factory = ActiveText.UI.BasicControls.SimpleButtonFactory, keepReadingButton = factory.createSimpleButton(keepReadingSettings).click(closeDialog);
        keepReadingButton.attr("tabindex", 100);
        var closeBookButton = factory.createSimpleButton(closeBookSettings).click(closeBook);
        closeBookButton.attr("tabindex", 100);
        var template = $('<div class="content"><div class="buttons"></div></div>');
        template.find(".buttons").append(keepReadingButton, closeBookButton), newDialog = template.dialog({
            width: DIALOG_WIDTH,
            height: DIALOG_HEIGHT,
            modal: !0,
            appendTo: container,
            dialogClass: "close-book",
            resizable: !1,
            close: closeHandler,
            create: createHandler
        }), centerOnScreen();
    }
    function toggleFlashZIndex(toggle) {
        toggle = toggle ? -1 : 999, $(".recordingWidget").css("z-index", toggle);
    }
    function centerOnScreen() {
        $(newDialog).parent().css({
            top: (container.height() - DIALOG_HEIGHT) / 2,
            left: (container.width() - DIALOG_WIDTH) / 2
        });
    }
    function closeDialog() {
        $(activeTextInstance).off(ActiveText.Events.RESIZE, centerOnScreen), toggleFlashZIndex(!1), 
        $(newDialog).dialog("close");
    }
    function closeBook() {
        closeDialog(), closeFunction && "function" == typeof closeFunction && closeFunction();
    }
    function insertCSS() {
        ActiveText.CSSUtils.embedCSS(Rapid.CloseBook.DialogStyleText.getStyle(activeTextInstance), "rapid-close-screen");
    }
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        instance && instance.options && instance.options.containerElement && (activeTextInstance = instance, 
        container = activeTextInstance.options.containerElement, pathPrefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/rapid/", 
        insertCSS());
    }
    function open() {
        if (newDialog) $(newDialog).dialog("open"); else {
            var scormIntegrationFunction = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "pipwerks");
            scormIntegrationFunction && (closeFunction = scormIntegrationFunction.closeEBook), 
            createDialog();
        }
        toggleFlashZIndex(!0);
    }
    /**
     * @const
     * @type {number}
     */
    var activeTextInstance, container, newDialog, pathPrefix, closeFunction, DIALOG_HEIGHT = 194, DIALOG_WIDTH = 416;
    return {
        init: init,
        open: open,
        key: "closebook"
    };
};

/* global ActiveText, Modernizr */
var Rapid = Rapid || {};

Rapid.CloseBook = Rapid.CloseBook || {}, Rapid.CloseBook.DialogStyleText = function(ActiveText) {
    "use strict";
    function getStyle(activeTextInstance) {
        var pathPrefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/rapid/", extension = "png";
        /**
         * @const
         * @type {string}
         */
        return Modernizr.svg && (extension = "svg"), ".ui-widget-content.close-book{background: url(" + pathPrefix + "closeBookPanel." + extension + ") top left no-repeat;-webkit-background-size:cover;-moz-background-size:cover;-o-background-size:cover;background-size:cover;z-index:2010;border:none;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;}.ui-widget-content.close-book .ui-dialog-titlebar,.ui-widget-content.close-book .ui-dialog-buttonpane{background:transparent;}.ui-widget-content.close-book .ui-dialog-content{background:transparent;}.ui-widget-content.close-book .ui-dialog-titlebar-close{display:none;}.ui-widget-content.close-book .content .button-close{margin-bottom: 10px;}.ui-widget-content.close-book .content .buttons{position:absolute;width:198px;top:0;right:20px;line-height:65px;}.ui-widget-content.close-book .content .buttons a{font-size:0;}";
    }
    return {
        getStyle: getStyle
    };
}(ActiveText);

/* global ActiveText, ActiveText, Modernizr */
var RapidPlays = RapidPlays || {};

/**
 * @class Player
 * @memberOf RapidPlays
 * @returns {{init: init, isInPerformanceMode: isInPerformanceMode, key: string}}
 * @constructor
 */
RapidPlays.Player = function() {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param dependencyKey {String}
     * @param skinCode {String}
     */
    function checkDependency(activeTextInstance, dependencyKey) {
        function audioPlaybackController(value, eventType) {
            if (void 0 === value) {
                if (isInPerformanceMode(activeTextInstance)) {
                    var extension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "readtome"), currentCharacter = ActiveText.CharacterSelection.getCharacter(), activeCharacter = extension.getState().getActiveCharacter();
                    return !(currentCharacter === activeCharacter);
                }
                return eventType === ActiveText.Commands.GO_TO_PAGE ? !1 : !0;
            }
        }
        activeTextInstance.options.audioPlaybackController = audioPlaybackController;
        var newClass, hasExtensionForDependency = Boolean(ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, dependencyKey));
        if (!hasExtensionForDependency) switch (dependencyKey) {
          case "overlaydataloader":
            newClass = new ActiveText.OverlayData(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "hotspots":
            newClass = new ActiveText.Hotspots(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "smildatamodel":
            newClass = new ActiveText.SMILDataModel(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "smildataloader":
            newClass = new ActiveText.SMILDataLoader(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "recordandplay":
            newClass = new ActiveText.RecordAndPlay(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "texthighlightaudiosync":
            activeTextInstance.options.allowReadToMe !== !1 && (newClass = new ActiveText.TextHighlightAudioSync({
                selectionModeHighlightByDefault: !0
            }), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass));
            break;

          case "closebook":
            newClass = new RapidPlays.CloseBook(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "soundeffects":
            newClass = new ActiveText.SoundEffects(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "keyboardintegration":
            newClass = new ActiveText.KeyboardIntegration(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "drawingtools":
            newClass = new ActiveText.DrawingTools(), newClass.supported() && (newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass));
            break;

          case "clicktoprompt":
            newClass = new ActiveText.ClickToPrompt(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "readingcomplete":
            newClass = new ActiveText.ReadingComplete(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
        }
    }
    function audioPlaybackController(value, eventType) {
        return void 0 === value ? eventType === ActiveText.Commands.GO_TO_PAGE ? !1 : !0 : void 0;
    }
    function setDefaultPropertiesFor(activeTextInstance) {
        var pathToAssets = ActiveText.SkinUtils.getPathToResources(activeTextInstance);
        void 0 === activeTextInstance.options.audioPlaybackController && (activeTextInstance.options.audioPlaybackController = audioPlaybackController), 
        void 0 === activeTextInstance.options.allowOverlap && (activeTextInstance.options.allowOverlap = !1), 
        void 0 === activeTextInstance.options.allowAnimation && (activeTextInstance.options.allowAnimation = !1), 
        void 0 === activeTextInstance.options.autoPop && (activeTextInstance.options.autoPop = function() {
            var autoPopData = {
                index: 0,
                data: [ {
                    type: "target-area",
                    data: {
                        id: "ATX-autoPop",
                        shape: "rectangle",
                        uri: pathToAssets + "wdgt/RapidPlays.wdgt/index.html?transparent=true",
                        x: -1,
                        y: -1,
                        width: 1,
                        height: 1
                    }
                } ]
            };
            return autoPopData;
        });
    }
    /**
     * @param activeTextInstance {ActiveText}
     * @returns {boolean}
     */
    function isInPerformanceMode(activeTextInstance) {
        var currentCharacter = ActiveText.CharacterSelection.getCharacter();
        return "" !== currentCharacter ? activeTextInstance.model.getCurrentPageNumber() >= 3 : !1;
    }
    function setRandomBackground(activeTextInstance) {
        var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), bg = [ "green", "orange", "purple", "blue" ][Math.floor(4 * Math.random())];
        activeTextInstance.options.containerElement.css(/**
         * Browser detection is bad, but IE is worse.
         *
         * Some versions of IE support SVG, and they support it for background images, but they don't scale it correctly
         * because they're dumb. So we're forced to do shit like this - using non SVG versions of images for the background.
         */
        !Modernizr.svg || navigator.userAgent.match(/(msie|trident)\/?\s*(\.?\d+(\.\d+)*)/i) ? {
            background: "url(" + pathToResources + "/img/rapid/background-" + bg + ".png) no-repeat center center",
            filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src="' + pathToResources + "/img/rapid/background-" + bg + '.png", sizingMethod="scale")',
            MsFilter: "'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\"" + pathToResources + "/img/rapid/background-" + bg + '.png", sizingMethod="scale")\'',
            backgroundSize: "cover"
        } : {
            background: "url(" + pathToResources + "img/rapid/background-" + bg + ".svg) no-repeat center center",
            backgroundSize: "cover"
        });
    }
    /** @constructor */
    return function() {
        /**
         * @param activeTextInstance {ActiveText}
         */
        function init(activeTextInstance) {
            setRandomBackground(activeTextInstance), setDefaultPropertiesFor(activeTextInstance);
            for (var dependencyKey, dependencies = [ "overlaydataloader", "hotspots", "smildatamodel", "smildataloader", "texthighlightaudiosync", "closebook", "soundeffects", "keyboardintegration", "drawingtools", "clicktoprompt", "recordandplay", "readingcomplete" ], i = 0, l = dependencies.length; l > i; i++) dependencyKey = dependencies[i], 
            checkDependency(activeTextInstance, dependencyKey);
            $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, function() {
                if (activeTextInstance.utils.isFullWindowScalingMode()) {
                    var rotationControl = new ActiveText.ViewOrientationDetection();
                    rotationControl.init(activeTextInstance), activeTextInstance.extensions.push(rotationControl);
                }
            });
        }
        return {
            init: init,
            isInPerformanceMode: isInPerformanceMode,
            key: "rapidplays"
        };
    };
}();

/* global ActiveText, Modernizr */
var RapidPlays = RapidPlays || {};

RapidPlays.Controls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        var closeFunction, closeBookExtension = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "closebook");
        closeBookExtension && (closeFunction = closeBookExtension.open), options || (options = {});
        var pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), pathPrefix = pathToResources + "img/rapid/", extension = ".png";
        Modernizr.svg && (extension = ".svg");
        var controls = new ActiveText.UI.BasicControls(activeTextInstance, {
            primary: options.primary,
            leftButtons: options.leftButtons,
            rightButtons: options.rightButtons,
            leftButtonOptions: {
                left: "10px"
            },
            rightButtonOptions: {
                right: "10px"
            },
            openByDefault: !0,
            overlay: !1,
            barHeight: 50,
            barStyles: {
                backgroundColor: "#000000"
            },
            minWidth: 670,
            scaleMode: "scale",
            buttonStyles: {
                width: 41,
                height: 41,
                tooltips: !1,
                background: "transparent",
                display: "inline-block",
                "vertical-align": "top"
            },
            hoverStyles: {
                background: "transparent"
            },
            options: {
                readtomeExtended: {
                    readtome: {
                        style: {
                            width: 157,
                            height: 41,
                            tooltips: !1
                        },
                        imageSrc: pathPrefix + "large-readtome" + extension,
                        hoverImageSrc: pathPrefix + "large-readtome-over" + extension,
                        downImageSrc: pathPrefix + "large-readtome-over" + extension,
                        disabledImageSrc: pathPrefix + "large-readtome-disabled" + extension,
                        toggleButtonImageSrc: pathPrefix + "large-readtome-active" + extension,
                        toggleButtonHoverImageSrc: pathPrefix + "large-readtome-over" + extension,
                        enableBehaviour: "show"
                    },
                    done: {
                        style: {
                            width: 93,
                            height: 41,
                            tooltips: !1
                        },
                        imageSrc: pathPrefix + "done-inactive" + extension,
                        hoverImageSrc: pathPrefix + "done-inactive" + extension,
                        downImageSrc: pathPrefix + "done-inactive" + extension,
                        toggleButtonImageSrc: pathPrefix + "done" + extension,
                        toggleButtonHoverImageSrc: pathPrefix + "done-over" + extension,
                        enableBehaviour: "show"
                    }
                },
                readtome: {
                    style: {
                        width: 157,
                        height: 41
                    },
                    imageSrc: pathPrefix + "ReadToMeUp" + extension,
                    hoverImageSrc: pathPrefix + "ReadToMeOver" + extension,
                    downImageSrc: pathPrefix + "ReadToMeDown" + extension,
                    toggleButtonImageSrc: pathPrefix + "ReadToMeActive" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "ReadToMeActiveDown" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "ReadToMeActiveOver" + extension
                },
                zoom: {
                    imageSrc: pathPrefix + "ZoomActive" + extension,
                    hoverImageSrc: pathPrefix + "ZoomActiveOver" + extension,
                    downImageSrc: pathPrefix + "ZoomActiveDown" + extension,
                    toggleButtonImageSrc: pathPrefix + "ZoomUp" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "ZoomDown" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "ZoomOver" + extension
                },
                bugclubhotspots: {
                    imageSrc: pathPrefix + "HeadActive" + extension,
                    hoverImageSrc: pathPrefix + "HeadActiveOver" + extension,
                    downImageSrc: pathPrefix + "HeadActiveDown" + extension,
                    toggleButtonImageSrc: pathPrefix + "HeadUp" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "HeadOver" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "HeadDown" + extension
                },
                previous: {
                    style: {
                        width: 69,
                        height: 45
                    },
                    imageSrc: pathPrefix + "LeftArrowUp" + extension,
                    hoverImageSrc: pathPrefix + "LeftArrowOver" + extension,
                    enableBehaviour: "hide"
                },
                next: {
                    style: {
                        width: 69,
                        height: 45
                    },
                    imageSrc: pathPrefix + "RightArrowUp" + extension,
                    hoverImageSrc: pathPrefix + "RightArrowOver" + extension,
                    downImageSrc: pathPrefix + "RightArrowDown" + extension,
                    enableBehaviour: "hide"
                },
                record: {
                    imageSrc: pathPrefix + "RecordUp" + extension,
                    hoverImageSrc: pathPrefix + "RecordOver" + extension,
                    downImageSrc: pathPrefix + "RecordDown" + extension,
                    toggleButtonImageSrc: pathPrefix + "StopUp" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "StopOver" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "StopDown" + extension
                },
                play: {
                    imageSrc: pathPrefix + "PlayUp" + extension,
                    hoverImageSrc: pathPrefix + "PlayOver" + extension,
                    downImageSrc: pathPrefix + "PlayDown" + extension,
                    disabledImageSrc: pathPrefix + "PlayDisabled" + extension,
                    toggleButtonImageSrc: pathPrefix + "PauseUp" + extension,
                    toggleButtonHoverImageSrc: pathPrefix + "PauseOver" + extension,
                    toggleButtonDownImageSrc: pathPrefix + "PauseDown" + extension
                },
                exit: {
                    imageSrc: pathPrefix + "CloseUp" + extension,
                    hoverImageSrc: pathPrefix + "CloseOver" + extension,
                    downImageSrc: pathPrefix + "CloseDown" + extension,
                    closeFunction: closeFunction
                }
            }
        });
        activeTextInstance.extensions.push(controls);
    }
    return {
        init: init
    };
};

/* global ActiveText */
var RapidPlays = RapidPlays || {};

RapidPlays.StudentControls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        options || (options = {});
        var primary = options.primary ? options.primary : "previous,readtomeExtended,next", leftButtons = options.leftButtons ? options.leftButtons : "zoom", rightButtons = options.rightButtons ? options.rightButtons : "record,play,exit";
        activeTextInstance.options.allowReadToMe === !1 && (primary = _.without(primary.split(","), "readtome", "readtomeExtended").toString()), 
        options.primary = primary, options.leftButtons = leftButtons, options.rightButtons = rightButtons;
        var controls = new RapidPlays.Controls(options);
        controls.init(activeTextInstance), activeTextInstance.extensions.push(controls);
    }
    return {
        init: init
    };
};

/* global ActiveText */
var RapidPlays = RapidPlays || {};

RapidPlays.TeacherControls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        options || (options = {});
        var primary = options.primary ? options.primary : "previous,readtomeExtended,next", leftButtons = options.leftButtons ? options.leftButtons : "bugclubhotspots,zoom", rightButtons = options.rightButtons ? options.rightButtons : "record,play,exit";
        activeTextInstance.options.allowReadToMe === !1 && (primary = _.without(primary.split(","), "readtome", "readtomeExtended").toString()), 
        options.primary = primary, options.leftButtons = leftButtons, options.rightButtons = rightButtons;
        var controls = new RapidPlays.Controls(options);
        controls.init(activeTextInstance), activeTextInstance.extensions.push(controls);
    }
    return {
        init: init
    };
};

/* global ActiveText, Modernizr */
var RapidPlays = RapidPlays || {};

RapidPlays.CloseBook = function() {
    "use strict";
    function createDialog() {
        function closeHandler() {
            /* jshint validthis:true */
            $(this).dialog("destroy"), newDialog = null;
        }
        function createHandler() {
            setTimeout(centerOnScreen, 0), $(newDialog).focus(), $(activeTextInstance).on(ActiveText.Events.RESIZE, centerOnScreen);
        }
        var extension = "png";
        Modernizr.svg && (extension = "svg");
        var keepReadingSettings = {
            title: "Keep reading",
            className: "button-keep-reading",
            tooltips: !1,
            style: {
                width: 198,
                height: 42
            },
            width: 198,
            height: 42,
            imageSrc: pathPrefix + "keepReadingUp." + extension,
            hoverImageSrc: pathPrefix + "keepReadingOver." + extension,
            downImageSrc: pathPrefix + "keepReadingUp." + extension
        }, closeBookSettings = {
            title: "Close book",
            className: "button-close",
            tooltips: !1,
            style: {
                width: 198,
                height: 42
            },
            width: 198,
            height: 42,
            imageSrc: pathPrefix + "closeBookUp." + extension,
            hoverImageSrc: pathPrefix + "closeBookOver." + extension,
            downImageSrc: pathPrefix + "closeBookUp." + extension
        }, factory = ActiveText.UI.BasicControls.SimpleButtonFactory, keepReadingButton = factory.createSimpleButton(keepReadingSettings).click(closeDialog);
        keepReadingButton.attr("tabindex", 100);
        var closeBookButton = factory.createSimpleButton(closeBookSettings).click(closeBook);
        closeBookButton.attr("tabindex", 100);
        var template = $('<div class="content"><div class="buttons"></div></div>');
        template.find(".buttons").append(keepReadingButton, closeBookButton), newDialog = template.dialog({
            width: DIALOG_WIDTH,
            height: DIALOG_HEIGHT,
            modal: !0,
            appendTo: container,
            dialogClass: "close-book",
            resizable: !1,
            close: closeHandler,
            create: createHandler
        }), centerOnScreen();
    }
    function toggleFlashZIndex(toggle) {
        toggle = toggle ? -1 : 999, $(".recordingWidget").css("z-index", toggle);
    }
    function centerOnScreen() {
        $(newDialog).parent().css({
            top: (container.height() - DIALOG_HEIGHT) / 2,
            left: (container.width() - DIALOG_WIDTH) / 2
        });
    }
    function closeDialog() {
        $(activeTextInstance).off(ActiveText.Events.RESIZE, centerOnScreen), toggleFlashZIndex(!1), 
        $(newDialog).dialog("close");
    }
    function closeBook() {
        closeDialog(), closeFunction && "function" == typeof closeFunction && closeFunction();
    }
    function insertCSS() {
        ActiveText.CSSUtils.embedCSS(RapidPlays.CloseBook.DialogStyleText.getStyle(activeTextInstance), "rapid-close-screen");
    }
    /**
     * @param instance {ActiveText}
     */
    function init(instance) {
        instance && instance.options && instance.options.containerElement && (activeTextInstance = instance, 
        container = activeTextInstance.options.containerElement, pathPrefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/rapid/", 
        insertCSS());
    }
    function open() {
        if (newDialog) $(newDialog).dialog("open"); else {
            var scormIntegrationFunction = ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, "pipwerks");
            scormIntegrationFunction && (closeFunction = scormIntegrationFunction.closeEBook), 
            createDialog();
        }
        toggleFlashZIndex(!0);
    }
    /**
     * @const
     * @type {number}
     */
    var activeTextInstance, container, newDialog, pathPrefix, closeFunction, DIALOG_HEIGHT = 194, DIALOG_WIDTH = 416;
    return {
        init: init,
        open: open,
        key: "closebook"
    };
};

/* global ActiveText, Modernizr */
var RapidPlays = RapidPlays || {};

RapidPlays.CloseBook = RapidPlays.CloseBook || {}, RapidPlays.CloseBook.DialogStyleText = function(ActiveText) {
    "use strict";
    function getStyle(activeTextInstance) {
        var pathPrefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/rapid/", extension = "png";
        /**
         * @const
         * @type {string}
         */
        return Modernizr.svg && (extension = "svg"), ".ui-widget-content.close-book{background: url(" + pathPrefix + "closeBookPanel." + extension + ") top left no-repeat;-webkit-background-size:cover;-moz-background-size:cover;-o-background-size:cover;background-size:cover;z-index:2010;border:none;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;}.ui-widget-content.close-book .ui-dialog-titlebar,.ui-widget-content.close-book .ui-dialog-buttonpane{background:transparent;}.ui-widget-content.close-book .ui-dialog-content{background:transparent;}.ui-widget-content.close-book .ui-dialog-titlebar-close{display:none;}.ui-widget-content.close-book .content .button-close{margin-bottom: 10px;}.ui-widget-content.close-book .content .buttons{position:absolute;width:198px;top:0;right:20px;line-height:65px;}.ui-widget-content.close-book .content .buttons a{font-size:0;}";
    }
    return {
        getStyle: getStyle
    };
}(ActiveText), /* global ActiveText, WordSmith, ActiveText, Modernizr */
ActiveText.namespace("WordSmith.Layers.Hotspots.Factory"), WordSmith.Layers.Hotspots.Factory = function() {
    "use strict";
    function embedCSSStyles() {
        runOnce || $("<style>.wordsmith_icon div{cursor:pointer !important;}</style>").appendTo("head"), 
        runOnce = !0;
    }
    /**
     * @private
     * @param currentLoc
     * @param dimensions
     * @returns {*|jQuery}
     */
    function createResourceIcon(activeTextInstance, currentLoc, dimensions) {
        embedCSSStyles();
        /**
         * @type {string}
         */
        var iconType = currentLoc.data.icon, resourceID = currentLoc.data.id, pathToResources = ActiveText.SkinUtils.getPathToResources(activeTextInstance), hotspotImageFilename = ActiveText.Hotspots.Helper.getDefaultFilenameFromHotspotData(currentLoc, "wordsmith-paw"), iconWidth = 118;
        iconWidth *= 1.33;
        /**
         * @type {string}
         */
        var htmlString = "<div class='wordsmith_icon noSwipe'><img class='wordsmith_icon' src='" + pathToResources + "img/wordsmith/hotspots/" + hotspotImageFilename + "' width='" + iconWidth + "' height='" + iconWidth + "'/></div>", newIcon = $(htmlString).attr("data-resource-id", resourceID).attr("data-type", iconType).css(ActiveText.Hotspots.Helper.getHotspotPositioningStyles(currentLoc, iconWidth, dimensions));
        return newIcon.data(currentLoc), newIcon;
    }
    var runOnce = !1;
    return {
        createResourceIcon: createResourceIcon
    };
}(), /* global ActiveText, WordSmith */
WordSmith.Controls = function(options) {
    "use strict";
    function init(activeTextInstance) {
        ActiveText.BrowserUtils.isMobileDevice && (activeTextInstance.options.defaults || (activeTextInstance.options.defaults = {}), 
        activeTextInstance.options.defaults.generatePageEdges = !1, activeTextInstance.options.allowAnimation = !1);
        var scope = activeTextInstance.options.containerElement.selector + " ", cssString = "" + scope + ".controls-bar a{vertical-align:middle;}" + scope + ".controls-bar a img{vertical-align:top;}";
        ActiveText.CSSUtils.embedCSS(cssString, "wordsmith-skin-styles");
        var pathPrefix = ActiveText.SkinUtils.getPathToResources(activeTextInstance) + "img/wordsmith/", controls = new ActiveText.UI.BasicControls(activeTextInstance, {
            leftButtons: leftButtons,
            rightButtons: rightButtons,
            leftButtonOptions: {
                left: "10px"
            },
            rightButtonOptions: {
                right: "10px"
            },
            openByDefault: !0,
            overlay: !1,
            barHeight: 74,
            barStyles: {
                backgroundColor: "#000000"
            },
            minWidth: 530,
            scaleMode: "scale",
            buttonStyles: {
                width: 44,
                height: 44,
                background: "transparent"
            },
            hoverStyles: {
                background: "transparent"
            },
            options: {
                drawing: {
                    imageSrc: pathPrefix + "Button_PencilUp.png",
                    hoverImageSrc: pathPrefix + "Button_PencilHoverSelected.png",
                    downImageSrc: pathPrefix + "Button_PencilDown.png",
                    toggleButtonImageSrc: pathPrefix + "Button_PencilHoverSelected.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_PencilHoverSelected.png",
                    toggleButtonDownImageSrc: pathPrefix + "Button_PencilDown.png"
                },
                viewtoggle: {
                    imageSrc: pathPrefix + "Button_DpageUp.png",
                    hoverImageSrc: pathPrefix + "Button_DpageHoverSelected.png",
                    downImageSrc: pathPrefix + "Button_DpageDown.png",
                    toggleButtonImageSrc: pathPrefix + "Button_SpageUp.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_SpageHoverSelected.png",
                    toggleButtonDownImageSrc: pathPrefix + "Button_SpageDown.png"
                },
                zoom: {
                    imageSrc: pathPrefix + "Button_MagMinusUp.png",
                    hoverImageSrc: pathPrefix + "Button_MagMinusHoverSelected.png",
                    downImageSrc: pathPrefix + "Button_MagMinusDown.png",
                    toggleButtonImageSrc: pathPrefix + "Button_MagUp.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_MagHoverSelected.png",
                    toggleButtonDownImageSrc: pathPrefix + "Button_MagDown.png"
                },
                animations: {
                    imageSrc: pathPrefix + "Button_PauseUp.png",
                    hoverImageSrc: pathPrefix + "Button_PauseHoverSelected.png",
                    downImageSrc: pathPrefix + "Button_PauseDown.png",
                    toggleButtonImageSrc: pathPrefix + "Button_PlayUp.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_PlayHoverSelected.png",
                    toggleButtonDownImageSrc: pathPrefix + "Button_PLayDown.png"
                },
                contents: {
                    style: {
                        width: 119,
                        height: 33
                    },
                    width: 119,
                    height: 33,
                    imageSrc: pathPrefix + "Button_ContentsUp.png",
                    hoverImageSrc: pathPrefix + "Button_ContentsHoverSelected.png",
                    downImageSrc: pathPrefix + "Button_ContentsDown.png",
                    toggleButtonImageSrc: pathPrefix + "Button_ContentsHoverSelected.png",
                    toggleButtonHoverImageSrc: pathPrefix + "Button_ContentsHoverSelected.png",
                    toggleButtonDownImageSrc: pathPrefix + "Button_ContentsDown.png"
                },
                quicknav: {
                    style: {
                        border: "none",
                        background: "transparent url(" + pathPrefix + "PageNav.png) 0 3px no-repeat",
                        width: 119,
                        padding: "11px 0px 9px 0px",
                        "vertical-align": "middle"
                    },
                    popupnavwidth: 293,
                    textFormatSinglePage: "%%title%%",
                    textFormatMultiPage: "%%title%%  %%title2%%"
                },
                previous: {
                    imageSrc: pathPrefix + "Button_BckArrowUp.png",
                    hoverImageSrc: pathPrefix + "Button_BckArrowHoverSelected.png",
                    downImageSrc: pathPrefix + "Button_BckArrowDown.png"
                },
                next: {
                    imageSrc: pathPrefix + "Button_ForwArrowUp.png",
                    hoverImageSrc: pathPrefix + "Button_ForwArrowHoverSelected.png",
                    downImageSrc: pathPrefix + "Button_ForwArrowDown.png"
                }
            }
        });
        //            controls.init(activeTextInstance);
        activeTextInstance.extensions.push(controls);
    }
    options || (options = {});
    var animationButton = "";
    options && void 0 !== options.displayAnimationControl && options.displayAnimationControl && (animationButton = ",animations");
    var leftButtons = options.leftButtons ? options.leftButtons : "wslogo,drawing,viewtoggle,zoom" + animationButton, rightButtons = options.rightButtons ? options.rightButtons : "contents,quicknav,previous,next";
    return {
        init: init,
        key: "wordsmithcontrols"
    };
}, /* global WordSmith */
/**
 * @class FictionControl
 * @memberOf WordSmith
 * @param options
 * @returns {WordSmith.Controls}
 * @constructor
 */
WordSmith.FictionControl = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "drawing,viewtoggle,zoom", rightButtons = options.rightButtons ? options.rightButtons : "quicknav,previous,next";
    return options.leftButtons = leftButtons, options.rightButtons = rightButtons, new WordSmith.Controls(options);
}, /* global WordSmith */
/**
 * @class NonFictionControl
 * @memberOf WordSmith
 * @param options
 * @returns {WordSmith.Controls}
 * @constructor
 */
WordSmith.NonFictionControl = function(options) {
    "use strict";
    options || (options = {});
    var leftButtons = options.leftButtons ? options.leftButtons : "drawing,viewtoggle,zoom", rightButtons = options.rightButtons ? options.rightButtons : "previous,next";
    return options.leftButtons = leftButtons, options.rightButtons = rightButtons, new WordSmith.Controls(options);
}, /* global ActiveText, WordSmith, ActiveText */
ActiveText.namespace("WordSmith.Player"), WordSmith.Player = function() {
    "use strict";
    /**
     * @param activeTextInstance {ActiveText}
     * @param dependencyKey {String}
     * @param options {{ hotspotClickFunction: function }}
     */
    function checkDependency(activeTextInstance, dependencyKey, options) {
        var newClass, hasExtensionForDependency = Boolean(ActiveText.ExtensionUtils.getExtensionByKey(activeTextInstance, dependencyKey));
        if (!hasExtensionForDependency) switch (dependencyKey) {
          case "overlaydataloader":
            newClass = new ActiveText.OverlayData(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "hotspots":
            newClass = new ActiveText.Hotspots(WordSmith.Layers.Hotspots.Factory.createResourceIcon, options), 
            newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "soundeffects":
            newClass = new ActiveText.SoundEffects(), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "wordsmithcontrols":
            newClass = new WordSmith.Controls(options), newClass.init(activeTextInstance), activeTextInstance.extensions.push(newClass);
            break;

          case "keyboardintegration":
            newClass = new ActiveText.KeyboardIntegration(), newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass);
            break;

          case "drawingtools":
            newClass = new ActiveText.DrawingTools(), newClass.supported() && (newClass.init(activeTextInstance), 
            activeTextInstance.extensions.push(newClass));
        }
    }
    function setDefaultPropertiesFor(activeTextInstance) {
        activeTextInstance.options.scheme = {
            color: "#000000",
            backgroundColor: "#d78c23",
            textColor: "#000000",
            controlColor: "#000000",
            controlHoverColor: "#d78c23",
            altControlHoverColor: "#d78c23",
            widgetBackgroundColour: "#000000",
            widgetBorderColour: "#d78c23",
            widgetCloseBackgroundColour: "#d78c23",
            widgetCloseBorderColour: "#000000",
            widgetTitleColour: "#d78c23"
        }, activeTextInstance.options.containerElement.css("background", "#d38e00");
    }
    /** @constructor */
    return function(options) {
        /**
         * @param activeTextInstance {ActiveText}
         */
        function init(activeTextInstance) {
            setDefaultPropertiesFor(activeTextInstance);
            for (var dependencyKey, dependencies = [ "overlaydataloader", "hotspots", "soundeffects", "wordsmithcontrols", "keyboardintegration", "drawingtools" ], i = 0, l = dependencies.length; l > i; i++) dependencyKey = dependencies[i], 
            checkDependency(activeTextInstance, dependencyKey, options);
            $(activeTextInstance).one(ActiveText.Commands.INIT_WHITEBOARD, function() {
                if (activeTextInstance.utils.isFullWindowScalingMode()) {
                    var rotationControl = new ActiveText.ViewOrientationDetection();
                    rotationControl.init(activeTextInstance), activeTextInstance.extensions.push(rotationControl);
                }
            });
        }
        return {
            init: init,
            key: "wordsmith"
        };
    };
}(), /* global ActiveText */
ActiveText.namespace("ActiveText.UI.BasicControls.AvailableControls"), function(ActiveText) {
    "use strict";
    function create() {
        var newElement = $('<div class="ws-logo">' + svgData + "</div>").css({
            margin: 8,
            lineHeight: 0,
            display: "inline-block",
            "float": "left"
        });
        return newElement;
    }
    /**
     * @const
     * @type {string}
     */
    var KEY = "wslogo", svgData = '<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" x="0px" y="0px"width="57.398px" height="57.819px" viewBox="0 0 57.398 57.819" enable-background="new 0 0 57.398 57.819" xml:space="preserve">    <g>    <path fill="none" d="M10.703,51.028c0,0-0.002,0.021-0.006,0.06c0.002-0.021,0.003-0.041,0.009-0.06H10.703z"/>    <radialGradient id="SVGID_1_" cx="28.6992" cy="28.9097" r="28.8046" gradientUnits="userSpaceOnUse">    <stop  offset="0.7975" style="stop-color:#F7B131"/>    <stop  offset="1" style="stop-color:#A44F24"/>    </radialGradient><ellipse fill-rule="evenodd" clip-rule="evenodd" fill="url(#SVGID_1_)" cx="28.699" cy="28.909" rx="28.699" ry="28.91"/>    <g>    <path d="M28.293,50.828c-0.061-0.155-0.145-0.287-0.213-0.421c-0.393-0.85-0.771-1.427-1.107-2.118c-0.012-0.033-0.024-0.062-0.037-0.089l1.744,0.604l-0.584-2.896l-1.672,0.915c-0.721-2.645,1.125-1.821,2.41-1.608c4.412,0.716,12.895,1.079,17.429-3.849c0.188-0.206,0.364-0.397,0.532-0.583c0.34,0.189,0.73,0.301,1.146,0.301c1.304,0,2.359-1.065,2.359-2.381c0-1.312-1.056-2.376-2.359-2.376c-1.119,0-2.055,0.784-2.298,1.837c-0.229,0.027-0.429,0.049-0.608,0.069c-0.391,0.035-0.961,0.083-1.701,0.128c-0.057,0.004-0.115,0.008-0.176,0.011c-0.53,0.029-1.137,0.056-1.814,0.073c0.814-1.045,3.117-3.721,3.117-8.654c0-1.552-0.265-3.046-0.752-4.447c0.157-0.061,0.327-0.111,0.508-0.154c0.563-0.081,4.48-1.261,4.825-5.786c0.181-2.351,0.053-4.034-0.102-5.658c-0.118-1.235-0.131-1.663-0.229-2.348c-0.071-0.491,0-1.289-1.114-0.88c-0.373,0.141-0.899,0.743-2.186,1.777c-1.934,1.556-4.499,3.786-5.258,5.203c-0.376,0.699-0.636,1.186-0.82,1.534c-1.97-1.677-4.401-2.91-7.103-3.522c0.874-0.405,1.591-0.599,1.591-0.599s-1.326-1.159-4.094-0.238c-1.236,0.408,3.322-1.842,3.046-1.908c-1.155-0.265-2.731-0.422-5.606,0.897c0,0,0.573-1.002,3.443-1.962c1.334-0.45-5.303-0.785-8.299,2.19c-1.621,1.604-2.031,2.64-2.238,3.268c-0.4,0.219-0.789,0.451-1.166,0.698c-0.58,0.413-0.738,0.118-0.848-0.141c-0.129-0.326-0.264-0.7-0.408-1.147c-0.828-2.587-1.066-4.879-1.515-6.083c-0.282-1.07-0.836-1.67-1.934-1.555c-4.435,0.458-5.334,4.302-7.489,8.156c-2.154,3.859,0.602,2.564,0.602,2.564s1.997-0.729,4.34-2.63c1.199,1.916,2.637,4.233,2.711,5.477l-0.718,1.227c-0.917,1.849-1.435,3.901-1.435,6.067c0,5.92,3.832,11.019,9.352,13.351c0.047,0.057,0.096,0.117,0.141,0.178c0.338,0.457,0.609,0.915,0.818,1.373c0.322,0.728,0.486,1.451,0.527,2.159l-2.358-0.822l0.75,3.524l1.417-0.777c-0.266,1.013-0.765,1.955-1.411,2.779c-0.638,0.814-1.694,2.107-2.871,3.336c3.057,1.19,6.371,1.864,9.831,1.923C28.902,55.938,29.291,53.352,28.293,50.828z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.31,26.334"/>    <path fill="#FFFFFF" d="M23.643,40.903c-0.705-1.291-1.27-0.053-0.72,0.763c1.478,2.19,5.524,1.875,6.651,1.645C29.574,43.311,24.83,43.085,23.643,40.903z"/><path fill="#FFFFFF" d="M23.395,21.789c-3.466,0.288-6.039,3.357-5.748,6.848c0.29,3.49,3.334,6.078,6.797,5.79c3.465-0.293,6.04-3.359,5.747-6.852C29.901,24.089,26.859,21.495,23.395,21.789z M24.117,30.494c-1.311,0.109-2.461-0.87-2.568-2.188c-0.076-0.9,0.352-1.725,1.046-2.191c-0.115-0.161-0.183-0.358-0.183-0.572c0-0.542,0.438-0.982,0.976-0.982c0.538,0,0.974,0.441,0.974,0.982c0,0.07-0.008,0.14-0.021,0.206c1.034,0.189,1.858,1.051,1.949,2.156C26.398,29.225,25.427,30.383,24.117,30.494z"/><path d="M24.34,25.749c-0.094,0.442-0.484,0.777-0.952,0.777c-0.328,0-0.616-0.162-0.793-0.411c-0.694,0.467-1.122,1.291-1.046,2.191c0.107,1.317,1.258,2.297,2.568,2.188c1.31-0.111,2.281-1.27,2.172-2.589C26.198,26.8,25.374,25.938,24.34,25.749z"/><path fill="#FFFFFF" d="M42.332,30.364c-0.217-2.586-2.471-4.509-5.039-4.29c-2.569,0.219-4.479,2.488-4.262,5.076c0.215,2.59,2.471,4.513,5.04,4.294C40.64,35.226,42.547,32.951,42.332,30.364z M37.35,33.037c-1.225,0.102-2.303-0.815-2.402-2.05c-0.065-0.769,0.264-1.478,0.816-1.931c-0.021-0.081-0.033-0.165-0.033-0.256c0-0.539,0.438-0.982,0.977-0.982c0.473,0,0.869,0.344,0.955,0.797c0.92,0.212,1.636,1.001,1.72,1.998C39.483,31.846,38.576,32.933,37.35,33.037z"/><path d="M37.662,28.616c0.011,0.061,0.018,0.124,0.018,0.185c0,0.545-0.438,0.986-0.973,0.986c-0.453,0-0.832-0.31-0.943-0.73c-0.553,0.453-0.882,1.162-0.816,1.931c0.1,1.235,1.178,2.151,2.402,2.05c1.227-0.105,2.134-1.191,2.032-2.423C39.298,29.617,38.582,28.828,37.662,28.616z"/><path fill="#FFFFFF" d="M23.388,26.526c0.468,0,0.858-0.335,0.952-0.777c0.014-0.066,0.021-0.136,0.021-0.206c0-0.542-0.435-0.982-0.974-0.982c-0.538,0-0.976,0.441-0.976,0.982c0,0.214,0.067,0.411,0.183,0.572C22.771,26.364,23.06,26.526,23.388,26.526z"/><path fill="#FFFFFF" d="M36.707,29.787c0.535,0,0.973-0.441,0.973-0.986c0-0.061-0.007-0.124-0.018-0.185c-0.086-0.453-0.482-0.797-0.955-0.797c-0.539,0-0.977,0.442-0.977,0.982c0,0.091,0.012,0.175,0.033,0.256C35.875,29.478,36.254,29.787,36.707,29.787z"/><path fill="#FFFFFF" d="M23.528,18.101c1.67,0.115,3.14,0.969,3.14,0.969s-1.648-1.411-4.004-1.472c-1.119-0.031-1.881,0.376-2.397,0.933c-0.971,1.035-1.083,2.586-1.092,2.723c0.009-0.039,0.072-0.218,0.525-1.071c0.318-0.604,0.807-1.079,1.363-1.424C21.836,18.28,22.742,18.05,23.528,18.101z"/><path fill="#FFFFFF" d="M40.846,25.236c0.758,0.726,1.117,1.731,1.117,1.731s-0.22-1.348-1.33-2.322c-1.516-1.335-3.074,0.289-3.162,0.385c0.019-0.019,0.121-0.079,0.688-0.312C39.107,24.321,40.23,24.655,40.846,25.236z"/><path fill="#FFFFFF" d="M19.253,20.749V20.74C19.248,20.749,19.253,20.749,19.253,20.749z"/>    <line fill="none" stroke="#FFFFFF" stroke-width="0" stroke-linecap="round" stroke-linejoin="round" x1="37.506" y1="24.837" x2="37.51" y2="24.831"/>    <g>    <path fill-rule="evenodd" clip-rule="evenodd" fill="#FFFFFF" d="M18.504,34.807c0.174,0.011,0.306,0.159,0.295,0.333c-0.011,0.174-0.156,0.305-0.328,0.294c-0.17-0.01-0.302-0.157-0.293-0.326C18.187,34.933,18.334,34.797,18.504,34.807z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#FFFFFF" d="M17.57,35.329c0.234,0.014,0.418,0.214,0.405,0.455c-0.013,0.239-0.217,0.424-0.454,0.409c-0.237-0.011-0.42-0.216-0.406-0.456C17.129,35.495,17.329,35.315,17.57,35.329z"/><path fill-rule="evenodd" clip-rule="evenodd" fill="#FFFFFF" d="M18.652,36.013c0.141,0.006,0.247,0.125,0.242,0.268c-0.01,0.141-0.129,0.25-0.27,0.242c-0.14-0.005-0.248-0.126-0.24-0.271C18.393,36.111,18.512,36.002,18.652,36.013z"/></g><path opacity="0.33" fill-rule="evenodd" clip-rule="evenodd" fill="#FFFFFF" d="M45.438,38.163c0,0-2.618,0.351-7.017,0.299c-4.067-0.042-7.046-2.254-7.046-2.254s1.996,2.516,7.046,2.872c2.983,0.212,7.011-0.566,7.011-0.566L45.438,38.163z"/>    <g><path fill="#FFFFFF" d="M23.643,40.903c-0.705-1.291-1.27-0.053-0.72,0.763c1.478,2.19,5.524,1.875,6.651,1.645C29.574,43.311,24.83,43.085,23.643,40.903z"/></g></g></g></svg>';
    ActiveText.UI.BasicControls.AvailableControls[KEY] = {
        create: create
    };
}(ActiveText), /* global ActiveText, ActiveText */
ActiveText.DialogStyleText = function() {
    "use strict";
    function getStyle(activeTextInstance) {
        var pathToResources = ActiveText.SkinUtils.getPathToGlobalResource(activeTextInstance), widgetBackgroundColour = activeTextInstance.theme.getWidgetBackgroundColour(), widgetBorderColour = activeTextInstance.theme.getWidgetBorderColour(), widgetCloseBackgroundColour = activeTextInstance.theme.getWidgetCloseBackgroundColour(), widgetCloseBorderColour = activeTextInstance.theme.getWidgetCloseBorderColour(), widgetCloseHoverColour = activeTextInstance.theme.getWidgetCloseHoverColour(), widgetTitleColour = activeTextInstance.theme.getWidgetTitleColour();
        /**
         * @const
         * @type {string}
         */
        return '.ui-helper-hidden{display:none}.ui-helper-hidden-accessible{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.ui-helper-reset{margin:0;padding:0;border:0;outline:0;line-height:1.3;text-decoration:none;font-size:100%;list-style:none}.ui-helper-clearfix:before,.ui-helper-clearfix:after{content:"";display:table;border-collapse:collapse}.ui-helper-clearfix:after{clear:both}.ui-helper-clearfix{min-height:0}.ui-helper-zfix{width:100%;height:100%;top:0;left:0;position:absolute;opacity:0;filter:Alpha(Opacity=0)}.ui-front{z-index:1000}.ui-state-disabled{cursor:default!important}.ui-icon{display:block;text-indent:-99999px;overflow:hidden;background-repeat:no-repeat}.ui-widget-overlay{position:fixed;top:0;left:0;width:100%;height:100%}.ui-resizable{position:relative}.ui-resizable-handle{position:absolute;font-size:.1px;display:block}.ui-resizable-disabled .ui-resizable-handle,.ui-resizable-autohide .ui-resizable-handle{display:none}.ui-resizable-n{cursor:n-resize;height:7px;width:100%;top:-5px;left:0}.ui-resizable-s{cursor:s-resize;height:7px;width:100%;bottom:-5px;left:0}.ui-resizable-e{cursor:e-resize;width:7px;right:-5px;top:0;height:100%}.ui-resizable-w{cursor:w-resize;width:7px;left:-5px;top:0;height:100%}.ui-resizable-se{cursor:se-resize;width:12px;height:12px;right:1px;bottom:1px}.ui-resizable-sw{cursor:sw-resize;width:9px;height:9px;left:-5px;bottom:-5px}.ui-resizable-nw{cursor:nw-resize;width:9px;height:9px;left:-5px;top:-5px}.ui-resizable-ne{cursor:ne-resize;width:9px;height:9px;right:-5px;top:-5px}.ui-button{display:inline-block;position:relative;padding:0;line-height:normal;margin-right:.1em;cursor:pointer;vertical-align:middle;text-align:center;overflow:visible}.ui-button,.ui-button:link,.ui-button:visited,.ui-button:hover,.ui-button:active{text-decoration:none}.ui-button-icon-only{width:2.2em}button.ui-button-icon-only{width:2.4em}.ui-button-icons-only{width:3.4em}button.ui-button-icons-only{width:3.7em}.ui-button .ui-button-text{display:block;line-height:normal}.ui-button-text-only .ui-button-text{padding:.1em .2em}.ui-button-icon-only .ui-button-text,.ui-button-icons-only .ui-button-text{padding:.4em;text-indent:-9999999px}.ui-button-text-icon-primary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:.4em 1em .4em 2.1em}.ui-button-text-icon-secondary .ui-button-text,.ui-button-text-icons .ui-button-text{padding:.4em 2.1em .4em 1em}.ui-button-text-icons .ui-button-text{padding-left:2.1em;padding-right:2.1em}input.ui-button{padding:.4em 1em}.ui-button-icon-only .ui-icon,.ui-button-text-icon-primary .ui-icon,.ui-button-text-icon-secondary .ui-icon,.ui-button-text-icons .ui-icon,.ui-button-icons-only .ui-icon{position:absolute;top:50%;margin-top:-8px}.ui-button-icon-only .ui-icon{left:50%;margin-left:-8px}.ui-button-text-icon-primary .ui-button-icon-primary,.ui-button-text-icons .ui-button-icon-primary,.ui-button-icons-only .ui-button-icon-primary{left:.5em}.ui-button-text-icon-secondary .ui-button-icon-secondary,.ui-button-text-icons .ui-button-icon-secondary,.ui-button-icons-only .ui-button-icon-secondary{right:.5em}.ui-buttonset{margin-right:7px}.ui-buttonset .ui-button{margin-left:0;margin-right:-.3em}input.ui-button::-moz-focus-inner,button.ui-button::-moz-focus-inner{border:0;padding:0}.ui-dialog{position:absolute;top:0;left:0;padding:0em;outline:0;-moz-box-shadow: 0 4px 8px rgba(0,0,0,0.5);-webkit-box-shadow: 0 4px 8px rgba(0,0,0,0.5);box-shadow: 0 4px 8px rgba(0,0,0,0.5);-webkit-transform-origin: 50% 50%;-moz-transform-origin: 50% 50%;-ms-transform-origin: 50% 50%;-o-transform-origin: 50% 50%;transform-origin: 50% 50%;-webkit-transition: opacity 0.3s cubic-bezier(0.250, 0.460, 0.450, 0.940), -webkit-transform 0.3s cubic-bezier(0.250, 0.460, 0.450, 0.940);-moz-transition: opacity 0.3s cubic-bezier(0.250, 0.460, 0.450, 0.940), -moz-transform 0.3s cubic-bezier(0.250, 0.460, 0.450, 0.940);-ms-transition: opacity 0.3s cubic-bezier(0.250, 0.460, 0.450, 0.940), -ms-transform 0.3s cubic-bezier(0.250, 0.460, 0.450, 0.940);-o-transition: opacity 0.3s cubic-bezier(0.250, 0.460, 0.450, 0.940), -o-transform 0.3s cubic-bezier(0.250, 0.460, 0.450, 0.940);transition: opacity 0.3s cubic-bezier(0.250, 0.460, 0.450, 0.940), transform 0.3s cubic-bezier(0.250, 0.460, 0.450, 0.940);}.ui-dialog .ui-dialog-titlebar{z-index:1;padding:0 .2em;position:relative}.ui-dialog .ui-dialog-title{float:left;margin:.1em 0;white-space:nowrap;width:90%;overflow:hidden;text-overflow:ellipsis;color:' + widgetTitleColour + "}.ui-dialog .ui-dialog-titlebar-close{position:absolute;right:.3em;top:50%;width:21px;margin:-10px 0 0 0;padding:1px;height:20px}.ui-dialog .ui-dialog-content{position:relative;border:0;padding:0;background:0;overflow:hidden}.ui-dialog.scrollable .ui-dialog-content{overflow:auto}.ui-dialog .ui-dialog-buttonpane{text-align:left;border-width:1px 0 0;background-image:none;margin-top:.5em;padding:.3em 1em .5em .4em}.ui-dialog .ui-dialog-buttonpane .ui-dialog-buttonset{float:right}.ui-dialog .ui-dialog-buttonpane button{margin:.5em .4em .5em 0;cursor:pointer}.ui-dialog .ui-resizable-se{width:12px;height:12px;right:-5px;bottom:-5px;background-position:16px 16px}.ui-draggable .ui-dialog-titlebar{cursor:move}.ui-widget .ui-widget{font-size:1em}.ui-widget input,.ui-widget select,.ui-widget textarea,.ui-widget button{font-family:Helvetica,Arial,sans-serif;font-size:1em}.ui-widget-content{border:1px solid " + widgetBorderColour + ";background:" + widgetBackgroundColour + ";color:#222}.ui-widget-content .content{background:#fff;padding:.5em;}.ui-widget-content a{color:#222}.ui-widget-header{background:" + widgetBackgroundColour + " url(" + pathToResources + "img/dialog/ui-bg_flat_0_ffffff_40x100.png) 50% 50% repeat-x;color:#fff;font-weight:bold}.ui-widget-header a{color:#fff}.ui-state-default,.ui-widget-content .ui-state-default,.ui-widget-header .ui-state-default{border:1px solid " + widgetCloseBorderColour + ";background:#c8eafc url(" + pathToResources + "img/dialog/ui-bg_glass_100_c8eafc_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#000}.ui-state-default a,.ui-state-default a:link,.ui-state-default a:visited{color:#000;text-decoration:none}.ui-state-hover,.ui-widget-content .ui-state-hover,.ui-widget-header .ui-state-hover,.ui-state-focus,.ui-widget-content .ui-state-focus,.ui-widget-header .ui-state-focus{border:1px solid " + widgetCloseBorderColour + ";background:#a9e0fa url(" + pathToResources + "img/dialog/ui-bg_glass_100_a9e0fa_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#000}.ui-state-hover a,.ui-state-hover a:hover,.ui-state-hover a:link,.ui-state-hover a:visited{color:#000;text-decoration:none}.ui-state-active,.ui-widget-content .ui-state-active,.ui-widget-header .ui-state-active{border:1px solid " + widgetCloseBorderColour + ";background:#ffc70b url(" + pathToResources + "img/dialog/ui-bg_glass_100_ffc70b_1x400.png) 50% 50% repeat-x;font-weight:normal;color:#000}.ui-state-active a,.ui-state-active a:link,.ui-state-active a:visited{color:#000;text-decoration:none}.ui-state-highlight,.ui-widget-content .ui-state-highlight,.ui-widget-header .ui-state-highlight{border:1px solid #f47721;background:#ffc70b url(" + pathToResources + "img/dialog/ui-bg_glass_100_ffc70b_1x400.png) 50% 50% repeat-x;color:#000}.ui-state-highlight a,.ui-widget-content .ui-state-highlight a,.ui-widget-header .ui-state-highlight a{color:#000}.ui-state-error,.ui-widget-content .ui-state-error,.ui-widget-header .ui-state-error{border:1px solid #cd0a0a;background:#fef1ec url(" + pathToResources + "img/dialog/ui-bg_glass_95_fef1ec_1x400.png) 50% 50% repeat-x;color:#cd0a0a}.ui-state-error a,.ui-widget-content .ui-state-error a,.ui-widget-header .ui-state-error a{color:#cd0a0a}.ui-state-error-text,.ui-widget-content .ui-state-error-text,.ui-widget-header .ui-state-error-text{color:#cd0a0a}.ui-priority-primary,.ui-widget-content .ui-priority-primary,.ui-widget-header .ui-priority-primary{font-weight:bold}.ui-priority-secondary,.ui-widget-content .ui-priority-secondary,.ui-widget-header .ui-priority-secondary{opacity:.7;filter:Alpha(Opacity=70);font-weight:normal}.ui-state-disabled,.ui-widget-content .ui-state-disabled,.ui-widget-header .ui-state-disabled{opacity:.35;filter:Alpha(Opacity=35);background-image:none}.ui-state-disabled .ui-icon{filter:Alpha(Opacity=35)}.ui-icon{width:16px;height:16px}.ui-icon,.ui-widget-content .ui-icon{background-image:url(" + pathToResources + "img/dialog/ui-icons_ffffff_256x240.png)}.ui-widget-header .ui-icon{background-image:url(" + pathToResources + "img/dialog/ui-icons_91d0d0_256x240.png)}.ui-state-default .ui-icon{background-image:url(" + pathToResources + "img/dialog/ui-icons_000000_256x240.png)}.ui-state-hover .ui-icon,.ui-state-focus .ui-icon{background-image:url(" + pathToResources + "img/dialog/ui-icons_000000_256x240.png)}.ui-state-active .ui-icon{background-image:url(" + pathToResources + "img/dialog/ui-icons_000000_256x240.png)}.ui-state-highlight .ui-icon{background-image:url(" + pathToResources + "img/dialog/ui-icons_000000_256x240.png)}.ui-state-error .ui-icon,.ui-state-error-text .ui-icon{background-image:url(" + pathToResources + "img/dialog/ui-icons_cd0a0a_256x240.png)}.ui-dialog .ui-dialog-titlebar-close {background: " + widgetCloseBackgroundColour + " !important;outline:none;position: absolute;right: .3em;top: 50%;width: 21px;margin: -10px 0 0 0;padding: 1px;height: 20px;-webkit-transition: 0.3s all ease;-moz-transition: 0.3s all ease;-ms-transition: 0.3s all ease;-o-transition: 0.3s all ease;transition: 0.3s all ease;}.ui-dialog .ui-dialog-titlebar-close.ui-state-hover {background:" + widgetCloseHoverColour + " !important;border:1px solid " + widgetCloseBorderColour + ";}.ui-dialog .ui-dialog-titlebar-close.ui-button-icon-only .ui-icon {top:0;left:0;margin:0;padding:0;}.ui-dialog .ui-dialog-titlebar-close.ui-button-icon-only .ui-icon.ui-icon-closethick {top:1px;left:1px;margin:0;padding:0;}.ui-icon-closethick{background-position: -96px -128px;}.ui-icon-grip-dotted-vertical{background-position:0 -224px}.ui-icon-grip-dotted-horizontal{background-position:-16px -224px}.ui-icon-grip-solid-vertical{background-position:-32px -224px}.ui-icon-grip-solid-horizontal{background-position:-48px -224px}.ui-icon-gripsmall-diagonal-se{background-position:-64px -224px}.ui-icon-grip-diagonal-se{background-position:-80px -224px}.ui-corner-all,.ui-corner-top,.ui-corner-left,.ui-corner-tl{border-top-left-radius:6px}.ui-corner-all,.ui-corner-top,.ui-corner-right,.ui-corner-tr{border-top-right-radius:6px}.ui-corner-all,.ui-corner-bottom,.ui-corner-left,.ui-corner-bl{border-bottom-left-radius:6px}.ui-corner-all,.ui-corner-bottom,.ui-corner-right,.ui-corner-br{border-bottom-right-radius:6px}.ui-widget-overlay{background:#000 url(" + pathToResources + "img/dialog/ui-bg_flat_50_000000_40x100.png) 50% 117% repeat-x;opacity:" + MODAL_OPACITY_DEFAULT + ";filter:Alpha(Opacity=" + 100 * MODAL_OPACITY_DEFAULT + ")}.ui-widget-shadow{margin:-8px 0 0 -8px;padding:8px;background:#000 url(" + pathToResources + "img/dialog/ui-bg_flat_50_000000_40x100.png) 50% 50% repeat-x;opacity:.25;filter:Alpha(Opacity=25);border-radius:8px}.widget-dialog.chromeless{-moz-box-shadow: none;-webkit-box-shadow: none;box-shadow: none;}.widget-dialog.chromeless,.widget-dialog.chromeless .ui-widget-header{background:transparent;border:none;display:none}.widget-dialog.chromeless .ui-button{display:none}.widget-dialog{z-index:2010;}.ui-dialog .ui-dialog-content .widget-widget,.ui-dialog.chromeless .ui-dialog-content .widget-widget{overflow:hidden}.widget-widget iframe{width:100%;height:100%}.chromeless-closebutton{position:absolute;cursor:pointer;top:0;right:0}.hidden-dialog-overlay{position:absolute;top:0;left:0;right:0;bottom:0;z-order:100000;}.dialog-resize-modal{position:fixed;top:0;left:0;height:100%;width:100%;background-color:#000;}";
    }
    /**
     * @const
     * @type {number}
     */
    var MODAL_OPACITY_DEFAULT = .6;
    return {
        getStyle: getStyle
    };
}();
//# sourceMappingURL=../js-source/activetext.js.map